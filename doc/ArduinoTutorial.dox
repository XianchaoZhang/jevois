/*! \page ArduinoTutorial 教程：如何编写与 JeVois 交互的 Arduino 代码

<h1>使用 JeVois 和 Arduino 控制伺服器</h1>

<h2>JeVois 模块输出的串行字符串</h2>

在这个简单的示例中，我们创建一个 Arduino 程序，它将监听来自 \jvmod{DemoSaliency}、\jvmod{RoadNavigation}、\jvmod{ObjectTracker}、\jvmod{DemoArUco} 或其他模块的消息，这些模块通过串行端口输出包含目标位置信息的消息。这些模块输出以下形式的字符串：

\verbatim
T1 <target_x>
\endverbatim

用于一维导航（例如 \jvmod{RoadNavigation} 中消失点的方向），或

\verbatim
T2 <target_x> <target_y>
\endverbatim

用于二维坐标。有关自定义串行消息的信息，请参阅 \ref UserSerialStyle。

为了使输出独立于视频图像分辨率，所有模块始终将坐标标准化为 -1000（全左或全上）到 1000（全右或全下）的范围。

每个视频帧通常输出一个字符串，也就是说，这些字符串以每秒 30 个、每秒 60 个或更高的速率从 JeVois 相机输出。

<h2>Arduino 伺服控制</h2>

这是一段简单的 Arduino 代码，可以解析 JeVois 发送的字符串并将其转换为控制伺服电机角度的脉冲。此代码可用于控制无线电遥控汽车的转向，或控制安装 JeVois 相机的伺服电动云台的 pan 和 titl 角度。

\code
// JeVois control steering or a pan/tilt head from the output of JeVois modules
//
// We handle messages "T2 <targetx> <targety>", "T1 <targetx>", "PANGAIN <gain>", and "TILTGAIN <gain>".
// targetx and targety are assumed to be in the -1000 ... 1000 range as output by the JeVois Kalman filters.
// Here we only do simple PD control under the assumption that target coordinates have already been filtered upstream.

#include <Servo.h>

// Pin for LED, blinks as we receive serial commands:
#define LEDPIN 13

// Serial port to use: on chips with USB (e.g., 32u4), that usually is Serial1. On chips without USB, use Serial:
#define SERIAL Serial1

// Pins for up to two servos:
Servo panservo;
#define PANPIN 3
Servo tiltservo;
#define TILTPIN 5

// Initial servo values in degrees:
#define PANZERO 90
#define TILTZERO 90

// With updates typically coming in at 60Hz or up to 120Hz, we will often need to move by a fraction of a
// degree. Hence we keep track of the pan and tilt values multiplied by SCALE. For the gains, a gain of 100
// means we will update servo angle by the 0.1*(target value/SCALE) degrees on each update. Higher gains mean
// larger angular updates.
#define SCALE 100
long pangain = 100;
long tiltgain = 100;
long panval = PANZERO * SCALE;
long tiltval = TILTZERO * SCALE;

// Buffer for received serial port bytes:
#define INLEN 128
char instr[INLEN + 1];

void setup()
{
  SERIAL.begin(115200);
  SERIAL.setTimeout(1000000);

  pinMode(LEDPIN, OUTPUT);
  digitalWrite(LEDPIN, LOW);
  
  panservo.attach(PANPIN);
  panservo.write(panval / SCALE);

  tiltservo.attach(TILTPIN);
  tiltservo.write(tiltval / SCALE);

  // We are ready to rock, disable logs and turn on serial outputs on JeVois platform:
  SERIAL.println("setpar serlog None");
  SERIAL.println("setpar serout Hard");
}

void loop()
{
  digitalWrite(LEDPIN, LOW);
  byte len = SERIAL.readBytesUntil('\n', instr, INLEN);
  instr[len] = 0;
  digitalWrite(LEDPIN, HIGH);

  char * tok = strtok(instr, " \r\n");
  int state = 0; int targx = 0, targy = 0;
  while (tok)
  {
    // State machine:
    // 0: start parsing
    // 1: T2 command, parse targx
    // 2: T2 command, parse targy
    // 3: T2 command complete
    // 4: T1 command, parse targx
    // 5: T1 command complete
    // 6: PANGAIN command, parse pangain
    // 7: PANGAIN command complete
    // 8: TILTGAIN command, parse tiltgain
    // 9: TILTGAIN command complete
    // 1000: unknown command
    switch (state)
    {
      case 0:
        if (strcmp(tok, "T2") == 0) state = 1;
        else if (strcmp(tok, "T1") == 0) state = 4;
        else if (strcmp(tok, "PANGAIN") == 0) state = 6;
        else if (strcmp(tok, "TILTGAIN") == 0) state = 8;
        else state = 1000;
        break;
        
      case 1: targx = atoi(tok); state = 2; break;
      case 2: targy = atoi(tok); state = 3; break;
      case 4: targx = atoi(tok); state = 5; break;
      case 6: pangain = atoi(tok); state = 7; break;
      case 8: tiltgain = atoi(tok); state = 9; break;

      default: break; // Skip any additional tokens
    }
    tok = strtok(0, " \r\n");
  }

  // Target coordinates are in range -1000 ... 1000. Servos want 0 ... 180.
  // We also need to negate as needed so that the servo turns to cancel any offset from center:
  if (state == 3 || state == 5)
  {
    panval -= (targx * pangain) / 1000;
    if (panval < 5 * SCALE) panval = 5 * SCALE; else if (panval > 175 * SCALE) panval = 175 * SCALE;
    panservo.write(panval / SCALE);
  }
  
  if (state == 3)
  {
    tiltval += (targy * tiltgain) / 1000;
    if (tiltval < 5 * SCALE) tiltval = 5 * SCALE; else if (tiltval > 175 * SCALE) tiltval = 175 * SCALE;
    tiltservo.write(tiltval / SCALE);
  }
}

\endcode


<h2>在 JeVois 平台上使用 script.cfg 文件</h2>

有时，在加载模块时设置一些参数或执行一些命令很有用。

JeVois 允许您将参数设置和命令存储在模块目录中名为 \c script.cfg 的文件中。文件 \c script.cfg 可能包含任何命令序列，就像您在 JeVois 命令行界面中以交互方式输入它们一样。

以下是 ObjectTracker 模块的一个示例。如下所示，此处的命令不仅会设置 JeVois 上的参数，还会设置 Arduino 控制的云台的平移和倾斜增益：

\code{.py}
# Demo configuration script for ObjectTracker module.

# Set camera to fixed color balance, gain, and exposure, so that we get more reliable colors than we would obtain under
# automatic mode:
setcam autowb 0
setcam autogain 0
setcam autoexp 0
setcam redbal 110
setcam bluebal 170
setcam gain 16
setcam absexp 500

# Detect a light blue flash drive:
setpar hrange 95...110
setpar srange 100...255
setpar vrange 60...253

# Send info log messages to None, send serial strings from module to Hard serial port:
setpar serlog None
setpar serout Hard

# Apply high gain to our pan/tilt servos, sending the commands below to our Arduino over the Hard serial port that we
# configured above to handle the serout messages. The Arduino controlling the pan/tilt servos will receive and parse
# these commands, and will set the servo gains:
serout PANGAIN 400
serout TILTGAIN 300
\endcode




*/

