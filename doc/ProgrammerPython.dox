namespace jevois
{
namespace rawimage
{
/*! \page ProgrammerPython 使用 Python 编程机器视觉模块

从 \jvversion{1.1} 开始，您可以使用 Python 3.x 为 JeVois 编写机器视觉模块。

概述 
========

基本框架如下：

- 核心 JeVois 软件提供的许多基本设施都经过了包装，以便可以通过 Python 访问。例如，这包括视频帧捕获、图像转换、通过 USB 输出视频帧、日志消息、向串行端口发送消息等。

- OpenCV 也被包装到 Python 中，并且可以在用 Python 编写的 JeVois 模块中使用。这允许人们使用 OpenCV 提供的机器视觉和图像处理功能。在这个框架中，图像表示为 Python numpy 数组。JeVois 核心公开了函数，允许将摄像机视频帧和输出视频帧转换为 Python numpy 数组或相反。

- 用 Python 编写的 JeVois 模块应由一个公开特定接口的 Python 类组成，包括一个 process() 函数，每次模块要处理新的视频帧时 JeVois 引擎都会调用该函数，并且应通过 USB 将输出图像发送到主机，以及一个 processNoUSB() 函数，在没有 USB 视频输出的情况下处理摄像头帧时会调用该函数（这两个函数的名称不同，因为 Python 不支持成员函数重载）。请注意，由于 [此线程](https://www.chiefdelphi.com/forums/showthread.php?t=159883&page=6) 上的用户讨论，此问题已在 \jvversion{1.6.2} 中得到修复。

- 因此，Python 集成以双向方式工作：
  + JeVois 核心提供了一个 \b libjevois Python 库，可供用 Python 编写的模块使用。
  + 用 Python 编写的模块公开一个具有特定成员函数的类，当模块加载时，JeVois 核心将实例化并调用该类。
  + JeVois 核心像调用 C++ 模块一样调用用 Python 编写的模块，使用 process() 函数，如 \ref Concepts 中所述。

- 用 Python 编写的 JeVois 模块在其他方面与用 C++ 编写的模块一样：当主机选择特定视频分辨率时，它们会被加载，这对应于 \b videomappings.cfg 中与感兴趣的模块匹配的条目。它们在 <b>JEVOIS:/modules</b> 下还有一个目录，并且它们可能具有与 C++ 模块相同的辅助文件。

例子 
========

jevoisbase 中的模块可以帮助您了解其工作原理：

- [PythonTest](/basedoc/jvpkg_2modules_2JeVois_2PythonTest_2PythonTest_8py_source.html) 使用 JeVois 导出的函数和类。

- [PythonOpenCV](/basedoc/jvpkg_2modules_2JeVois_2PythonOpenCV_2PythonOpenCV_8py_source.html) 也使用 OpenCV。

- [PythonSandbox](/basedoc/jvpkg_2modules_2JeVois_2PythonSandbox_2PythonSandbox_8py_source.html) 也使用 OpenCV。

JeVois 核心对用 Python 编写的模块的期望 
==========================================================

就像模块 C++ 抽象基类定义了 JeVois 引擎如何使用 C++ 模块的接口一样，Python 模块应该按如下方式组织：

- <b>JEVOIS:/modules/vendor/</b> 下目录中的单个 .py 文件声明一个 Python 类，其文件名主干（不带扩展名）、目录名和类名完全匹配。

- 模块可以声明和实现（所有都是可选的，但大多数模块至少应该实现一个 process() 函数才有用）：
  + 无参数的构造函数：`__init__(self)`
  + 带有 USB 输出的 Process 函数：`process(self, inframe, outframe)`
  + 无 USB 输出的 Process 函数：`processNoUSB(self, inframe)`
  + \jvpro 带有 GUI 输出的 Process 函数：`processGUI(self, inframe, guihelper)`
  + 用于解析 JeVois Engine 转发给模块的串行命令的函数，返回一个字符串：`parseSerial(self, str)`
  + 用于返回描述模块支持的自定义命令的字符串的函数，用于 JeVois 帮助消息：`supportedCommands(self)`
  + 用于在模块卸载之前进行清理的函数：`uninit()`（在 \jvversion{1.7.1} 及更高版本中）
  + 请注意，sendSerial() 由 C++ 模块基类提供允许派生模块通过串行端口发送消息不应定义，也不会被调用（因为它是由 JeVois 核心库而不是模块实现的）；相反，JeVois 核心库向 Python 模块公开了一个函数 `jevois.sendSerial()`，该函数可实现相同的结果。对于访问原始相机或 IMU 寄存器的函数也是如此：
- jevois.writeCamRegister()
- jevois.readCamRegister()
- jevois.writeIMUregister()
- jevois.readIMUregister()
- jevois.frameNum()

JeVois 核心提供的 Python 绑定 
=========================================

JeVois 核心软件的以下函数和类已包装以供 Python 使用。要使用给定类或函数的 Python 版本，只需检查 C++ 文档并假设将使用相同的类名、函数名以及参数的数量和类型（下面提到的几个例外情况除外）。

请参阅 \ref PythonSupport.C 中的 \a BOOST_PYTHON_MODULE() 中的源代码，了解最新的 Python 绑定列表。

可以通过以下方式将绑定导入 Python：

\code{.py}
import pyjevois
if pyjevois.pro: import libjevoispro as jevois
else: import libjevois as jevois
\endcode

每个用 Python 编写的 JeVois 模块都应以该导入开始。

由于所有 Python 绑定都在 \b jevois 模块下（实际上是 libjevois，我们将其导入为 jevois），因此您应该通过在 \b jevois 模块名称前面加上前缀来调用它们。

例如，考虑在 jevois C++ 命名空间中定义的 C++ 函数 fccstr()，其签名为：

\code
  // 将 V4L2 four-cc 代码（V4L2_PIX_FMT_...）转换为 4 个字符的字符串 
  std::string fccstr(unsigned int fcc); 
\endcode

从 Python 调用此函数的形式如下：

\code{.py}
s = jevois.fccstr(code)
\endcode

将调用 JeVois 的 C++ 函数 fccstr()，将变量 \b code 的内容传递给它（该变量应为 C++ 函数所期望的正整数，否则绑定引擎将抛出输入参数类型不正确的异常）。然后，C++ 函数返回的 C++ 字符串将被复制到 Python 字符串 \b s ，并且可以在 Python 中进一步使用，就像任何 Python 字符串一样。

绑定列表 
----------------

单击下面的任何类或函数即可查看其文档。虽然该文档适用于 C++ 版本，但此处列出的函数和类与 Python 具有精确绑定，但您可以忽略任何 C++ 限定符（\c const 和类似）和引用/指针规范（参数名称前的 \c & 或 \c *）。

\note 请参阅 \ref PythonSupport.C 中 \a BOOST_PYTHON_MODULE() 的源代码，了解最新的 Python 绑定列表。

- 在 \ref Utils.H 中声明的通用实用函数
  + fccstr()
  + cvtypestr()
  + strfcc()
  + v4l2BytesPerPix()
  + v4l2ImageSize()
  + blackColor()
  + whiteColor()
  + flushcache()
  + system()

- 在 \ref Coordinates.H 中声明的坐标助手
  + imgToStd()
  + stdToImg()
  + imgToStdX()
  + imgToStdY()
  + imgToStdSize()
  + stdToImgSize()

- 支持从相机和 USB 传输原始图像缓冲区，来自 \ref RawImage.H
  + 类 RawImage
  + 成员函数：invalidate()、valid()、clear()、require()、bytesperpix()、bytesize()、coordsOk()
  + 成员变量：width、height、fmt、fps

- 按名称表示原始格式的 YUYV 颜色，如 \ref RawImage.H
  + 这些颜色映射到 Python 枚举 <b>jevois.YUYV</b>，其值为 Black = 0x8000、DarkGrey = 0x8050、MedGrey = 0x8080、LightGrey = 0x80a0、White = 0x80ff、DarkGreen = 0x0000、MedGreen = 0x0040、LightGreen = 0x00ff、DarkTeal = 0x7070、MedTeal = 0x7090、LightTeal = 0x70b0、DarkPurple = 0xa030、MedPurple = 0xa050、LightPurple = 0xa080、DarkPink = 0xff00、MedPink = 0xff80、LightPink = 0xffff。

- 相机传感器和 USB 输出支持的 Video4Linux2 (V4L2) RawImage 像素格式：
  + 这些映射到常量 <b>jevois.V4L2_PIX_FMT_SRGGB8、jevois.V4L2_PIX_FMT_YUYV、jevois.V4L2_PIX_FMT_GREY、jevois.V4L2_PIX_FMT_RGB565、jevois.V4L2_PIX_FMT_MJPEG 和 jevois.V4L2_PIX_FMT_BGR24</b>。

- 输入帧包装器，包装 \ref Module.H 的 InputFrame 类
  + class InputFrame
  + 成员函数的 InputFrame 类的输入帧包装器：get()、done()、getCvGRAY()、getCvBGR()、getCvRGB()、getCvRGBA() 
- \ref Module.H 中 OutputFrame 类的输出帧包装器
  + class OutputFrame
  + 成员函数的 OutputFrame 类的输出帧包装器：get()、send()、sendCv()、sendCvGRAY()、sendCvBGR()、sendCvRGB()、sendCvRGBA()、sendScaledCvGRAY()、sendScaledCvBGR()、sendScaledCvRGB()、sendScaledCvRGBA()

- 对原始图像的操作，如 \ref RawImageOps.H 中声明的
  + cvImage()
  + convertToCvGray()
  + convertToCvBGR()
  + convertToCvRGB()
  + convertToCvRGBA()
  + byteSwap()
  + paste()
  + pasteGreyToYUYV()
  + roipaste()
  + drawDisk()
  + drawCircle()
  + drawLine()
  + drawRect()
  + writeText()，字体通过 Python 枚举 <b>jevois.Font</b> 选择，其值为 <b>Font5x7, Font6x10, Font7x13, Font8x13bold, Font9x15bold, Font10x20, Font11x22, Font12x22, Font14x26, Font15x28, Font16x29, Font20x38</b>。
  + convertCvGRAYtoRawImage()
  + convertCvBGRtoRawImage()
  + convertCvRGBtoRawImage()
  + convertCvRGBAtoRawImage()
  + unpackCvRGBAtoGrayRawImage()
  + hFlipYUYV()

- 在 \ref Timer.H 中声明的 Timer 类
  + Timer 类（请注意，构造函数接受参数；请参阅下文了解日志级别定义）
  + 成员函数：start()、stop()

- 在 \ref Profiler.H 中声明的 Profiler 类
  + Profiler 类（请注意，构造函数接受参数；请参阅下文了解日志级别定义）
  + 成员函数：start()、checkpoint()、stop()

- 在 SysInfo.H 中声明的系统实用程序
  + getSysInfoCPU()
  + getSysInfoMem()
  + getSysInfoVersion()

- 日志记录函数，\ref Log.H 中声明的宏的简化版本，采用单个字符串参数，而不是 C++ 端使用的流式接口（因此，Python 程序员应使用 Python 字符串 format() 函数将各种变量值放置在该字符串中）：
  + LDEBUG()、LINFO()、LERROR()、LFATAL()
  + 定义为常量的日志级别：<b>jevois.LOG_DEBUG、jevois.LOG_INFO、jevois.LOG_ERR、jevois.LOG_CRIT</b>。

- 在 \jvpro 上，GUIhelperPython 公开的函数，它是 GUIhelper 的代理。

代码文档和附件文件 
==========================================

遵循与 \ref ProgrammerSDK 中 "模块文档和元数据" 下的相同规则

请参阅 jevoisbase 中的示例 Python 模块，了解如何将其转换为 Python doxygen 指令的示例。

*/

} }

