/*! \page ModulePythonTutorial 关于如何用 Python 编写新的机器视觉模块的教程


\section pyoverview 概述

机器视觉 Python 模块被编程为单个类，该类公开了 JeVois Engine 所需的特定接口。请参阅 \ref ProgrammerPython 了解简介。

作为初步（略微过于简化）的想法，JeVois 视觉模块的整体工作流程是它们实现一个处理功能，该功能将接收由相机传感器捕获的图像，以及将通过 USB 发送到主机的预分配输出图像。处理功能的任务是使用处理输入图像的结果填充输出图像。

在本教程中，我们首先向您展示如何编写几个非常简单的模块，以引入必要的概念。在本教程的最后，我们将为您指出进一步的详细阅读内容。

\jvpro：以下教程创建在 JeVois-Pro 上以 "legacy mode" 运行的模块，即模块接收一个图像作为输入并输出包含处理结果的新图像。有关使用 /jvpro 的新 "Pro/GUI" 模式的模块的示例，请查看 jevoisbase 中许多示例的源代码：\ref UserDemos

在开始之前，您应该了解 \ref Concepts 。

\subsection pymappings 像素格式和视频映射

提醒一下，JeVois 智能相机可以捕捉以下相机像素格式的图像：YUYV、BAYER 或 RGB565。这些格式是相机传感器芯片支持的格式。

JeVois 可以向通过 USB 连接的主机发送更广泛的像素格式：YUYV、GREY、MJPG、BAYER、RGB565 和 BGR24。

有关这些格式的解释，请参阅 \ref UserModes 了解详情。

\subsection pyvideomappings 摄像头到 USB 视频映射

当主机通过 \jva33 上的 USB 或 \jvpro 上的用户选择特定图像分辨率和像素格式时，将调用模块。视频映射列表将给定的输出分辨率和像素类型与应使用的相应相机分辨率和像素类型以及应调用的机器视觉模块关联起来。再次参阅 \ref UserModes 了解详细信息。

由于输出视频格式由 \jva33 上的主机或 \jvpro 上的用户选择，因此不可协商。如果在 \b videomappings.cfg 中指定了调用特定机器视觉模块的视频映射，则该模块必须执行（或抛出异常）并处理从相机接收的图像以生成所需的输出图像。

\jvpro：对于 JeVois-Pro，将以下示例中的 `import libjevois as jevois` 替换为以下内容：

\code{.py}
import pyjevois
if pyjevois.pro: import libjevoispro as jevois
else: import libjevois as jevois
\endcode


// #################################################################################################### 
\section pygetstarted 入门：边缘检测模块

这里我们使用 OpenCV 的 Canny 边缘检测器在 Python 中编写了一个简单的边缘检测模块。我们将抓取一个彩色视频帧，将其转换为灰度，计算边缘图（也是灰度），然后通过 USB 将其发送到主机。

以下是完整、有效的代码。我们将逐步介绍它：

\includelineno PythonTutorial1.py

解释：

- 第 1 行：JeVois 核心向 Python 公开了一个名为 libjevois 的库。这允许 Python 模块使用 JeVois 中编写的一些核心功能。有关详细信息，请参阅 \ref ProgrammerPython 。在这里，我们将这个库以别名 \b jevois 导入到我们的模块中。

- 第 2 行：同样，OpenCV（用 C++ 编写）公开了绑定，允许 Python 程序调用 OpenCV 的图像处理函数。这里我们也导入了该库。

- 第 3 行：另一个库 numpy 可用于处理数组（包括图像）。实际上，OpenCV 使用 numpy ND 数组来表示图像。

- 第 5-24 行：我们使用 doxygen 和 JeVois 的自定义标签来记录代码，以便根据代码中的注释自动创建一个简单的文档页面。此模块的页面位于 [此处](/moddoc/PythonOpenCV/modinfo.html)，它是根据代码中的注释自动生成的。有关详细信息，请参阅 \ref ProgrammerSDK 。

- 第 25 行：我们声明一个类。其名称必须与文件名（不带 .py 扩展名）和存储此模块的目录名完全匹配。

- 第 28 行：JeVois 引擎需要一个名为 \c process() 的函数，它将在每个视频帧上调用该函数。引擎将为我们提供一个名为 \b inframe 的输入帧（C++ 类 jevois::InputFrame 的包装器，它是相机传感器帧的代理），以及一个名为 \b outframe 的输出帧（C++ 类 jevois::OutputFrame 的包装器，它是可以通过 USB 发送的视频缓冲区的代理）。我们在 \c process() 函数中的任务是从通过 \b inframe 包装器获取的输入图像创建一个输出图像，我们将使用 \b outframe 包装器通过 USB 链接发送该输出图像。

- 第 30 行：在本教程中，我们需要一张灰度输入图像。我们从内帧中提取它。此调用可能会阻塞，直到相机传感器完成下一帧的捕获。有关更多详细信息，请参阅 jevois::InputFrame 。

- 第 33 行：我们使用 OpenCV 检测灰度图像中的边缘，请参阅 http://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html 以获得关于其工作原理的非常详细的解释。

- 第 36 行：我们通过 USB 将输出图像发送到主机。请注意此处如何使用 \c sendCvGRAY() ，因为我们的边缘图是灰度图。sendCvGRAY() 会将灰度图转换为主机所期望的任何图像（这取决于调用我们模块的视频映射）。


// ####################################################################################################### 
\section pysandbox 自己尝试一下：沙盒模块

这里我们使用 OpenCV 的拉普拉斯检测器编写了一个简单的彩色图像过滤模块。我们将抓取一个彩色视频帧，对其应用过滤器，并将颜色结果通过 USB 发送到主机。

以下是完整、有效的代码。我们将逐步介绍它：

\includelineno PythonTutorial2.py

解释：

- 第 1-27 行：与上面的教程相同。

- 第 30 行：构造函数。在此模块中，我们将使用我们类的持久成员对象，即 JeVois 提供的 Timer（请参阅 jevois::Timer ）。它将测量处理每帧所需的时间，并每 100 帧报告一次平均帧速率。由于计时器将保留在许多帧中，因此我们将其声明为我们类的成员变量，并在我们模块的构造函数中对其进行初始化。

- 第 32 行：我们将计时器添加为我们类的新成员变量，并对其进行初始化。

- 第 36 行：JeVois 引擎需要一个名为 \c process() 的函数，它将在每个视频帧上调用该函数。与上面的上一个教程相同。

- 第 40 行：在本教程中，我们需要一个彩色输入图像。我们从内框中提取它，作为“BGR”颜色，因为出于历史原因，这是 OpenCV 的首选颜色格式（尽管 RGB 现在在其他机器视觉库中更受欢迎）。此调用可能会阻塞，直到相机传感器完成下一帧的捕获。有关更多详细信息，请参阅 jevois::InputFrame 。

- 第 43 行：通过 \c process() 开始测量当前运行的时间

- 第 60 行：我们使用 OpenCV 计算彩色图像中的拉普拉斯算子，请参阅 http://docs.opencv.org/trunk/d5/db5/tutorial_laplace_operator.html ，其中有关于其工作原理的非常详细的解释（请注意，他们在灰度图像上运行它，而我们在这里在彩色图像上运行它）。正如在推荐中所写，此模块邀请您尝试并尝试一些其他图像过滤器（选择那些接收彩色图像并输出相同大小的彩色图像的过滤器）。事实上，本教程也作为 \b jevoisbase 中的模块 [Python Sandbox](/moddoc/PythonSandbox/modinfo.html) 存在，并预装在最新的 microSD 图像上。请参阅 [JeVois 交互式教程](/tutorials) 以获取如何使用它的示例。

- 第 63-64 行：在输出图像顶部附近写一个标题。有关 \c putText() 的详细信息，请参阅 http://docs.opencv.org/3.2.0/d6/d6e/group__imgproc__draw.html

- 第 67 行：告诉我们的计时器停止测量此帧的时间。当我们停止它时，它还会返回一个字符串，其中包含平均帧数/秒、CPU 使用率、CPU 温度和 CPU 频率，并且每 100 帧更新一次。在这里，我们将该信息存储到字符串 \b fps 中，我们将在结果顶部显示该字符串。

- 第 68 行：获取图像宽度、高度和通道数。这里我们需要这些信息，以便计算框架底部的 Y 坐标，我们将使用该坐标在底部附近显示文本。

- 第 69 行：在帧底部附近写入 fps 信息。

- 第 73 行：我们通过 USB 将输出图像发送到主机。请注意此处如何使用 \c sendCvBGR()，因为我们的输出图像具有 BGR 颜色。sendCvBGR() 将从 BGR 转换为主机期望的任何颜色（这取决于调用我们模块的视频映射）。

// #################################################################################################### 
\section pylowlevel 使用 JeVois 原始图像进行更细粒度的控制

在上述两个教程中，我们使用了最简单的方法，即将输入图像转换为 OpenCV，然后处理 OpenCV 图像，并将输出图像从 OpenCV 转换为将通过 USB 发送的原始图像缓冲区。虽然这对于入门来说很棒，但我们确实需要花费一些成本（即时间）来转换图像。核心 JeVois 库还公开了对相机传感器原始图像数据和将通过 USB 发送的原始输出缓冲区的低级访问。

这里我们编写了一个完全不使用 OpenCV 的模块。它使用直接处理原始 YUYV 图像的 JeVois 绘图函数。这样就无需从 YUYV（相机传感器原始格式）转换为 BGR，然后再转换为 YUYV（通过 USB 链接本地发送的格式）。

以下是完整、有效的代码。我们将逐步介绍它：

\includelineno PythonTutorial3.py

解释：

- 第 1-24 行：与上文相同。

- 第 27-30 行：构造函数。我们使用 JeVois LINFO() 日志记录函数打印几条消息。这些消息将被发送到硬件串行端口（如果您在 JeVois 控制台中键入 `setpar serlog Hard`）、USB 串行端口（如果键入 `setpar serlog USB`）或两者（如果键入 `setpar serlog All`）。有关 \b serlog 的详细信息，请参阅 \ref UserCli 。

- 第 34-35 行：JeVois 还支持处理来自摄像头传感器的视频帧但不产生任何视频输出的模块。这些模块通常只会通过串行端口产生文本输出。请参阅 \ref Concepts 。在 C++ 中，我们有两个 process() 函数的重载，但这在 Python 中是不可能的，因此这两个函数采用不同的名称：process() 和 processNoUSB()。在这里，我们没有实现仅接受摄像头图像的 \c processNoUSB() 函数，但我们为其提供了一个框架。在几个 \b jevoisbase C++ 模块中提供了此函数实现的示例。在 \ref UserDemos 下查找声称<em>​​支持无 USB 输出映射</em>的模块以了解详细信息（例如，DemoArUco）。

- 第 39 行：这是我们的 \c process() 函数，将视频输出到 USB。

- 第 43 行：我们从相机传感器获取原始视频帧。根据我们推荐的视频映射（参见第 13 行的注释），我们预计这将是 YUYV。有关像素格式和视频映射的复习，请参阅 \ref UserModes。此处 \c get() 返回的对象是 Python 包装的 jevois::RawImage 对象。它包含指向 Linux 内核中分配的内存缓冲区的直接指针，相机传感器使用直接内存访问 (DMA) 将像素信息填充到该缓冲区中。因此，jevois::RawImage 是一个<em>轻量级</em>对象，它只保存指向像素数据的共享指针，并假定拥有该数据的副本。因此，与上面的教程不同，到目前为止，我们对来自相机传感器的原始像素数组没有进行任何复制或转换。这非常快。

- 第 47 行：我们还将输出视频缓冲区作为原始 YUYV jevois::RawImage 获取。这里，RawImage 再次直接指向 Linux 内核分配的原始像素缓冲区，该缓冲区将直接用于通过 DMA 通过 USB 链路传输数据。非常高效的零拷贝访问。

- 第 51 行：在本教程模块中，我们首先将相机传感器中的像素复制到输出原始缓冲区中，以便用户可以看到相机所看到的内容。在更复杂的场景中，输入缓冲区可以复制到输出缓冲区内的一个小窗口（例如，如 \jvmod{DemoSaliency} 中所示），或者可能根本不复制，只是以某种方式处理以产生将要发送的计算输出图像（例如，从输入图像计算边缘图）。因此，我们在这里只需将 \b inimg 粘贴到 \b outimg 中，从 \b outimg 中的左上角 (0,0) 位置开始。

- 第 54 行：从此点开始，我们将只处理输出图像，这样我们就可以释放输入图像，以便其缓冲区被回收到相机传感器内核驱动程序，以用于后续帧捕获。通常，最好尽早将输入帧标记为已完成，以便其缓冲区尽早可供相机传感器使用。

- 第 57 行：JeVois 核心提供了许多可直接在 YUYV 图像上进行的操作。例如，在这里，我们将输出图像水平翻转。有关更多操作，请参阅 \ref image 。

- 第 60-61 行：JeVois 核心还提供了可直接处理 YUYV 图像的简单绘图函数。同样，请参阅 \ref image 了解详情。在这里，我们只画一个圆圈并写入一条文本消息。

- 第 64 行：一旦我们完成并确定输出图像，我们就可以通过 USB 将其发送到主机。在输出帧上对 \c send() 的调用是可选的，当 \c process() 结束时，它无论如何都会被调用。

- 第 68 行：这是将文本字符串发送到 \b serout 串行端口的示例，例如用于连接到 JeVois 的 Arduino。引擎参数 \b serout 决定该字符串将去往何处（硬件串行端口、USB 串行、无或两者）。请注意，默认情况下它不会去往任何端口。您需要在 JeVois 控制台（或配置文件中）发出“setpar serout Hard”以将输出发送到硬件串行端口。有关 \b serout 的更多信息，请参阅 \ref UserCli。

- 第 69 行：我们增加内部帧计数器，此帧的处理已完成。JeVois 引擎将在下一帧再次调用 \c process()。

- 第 73-77 行：模块可以选择支持自定义命令，这些命令添加到 JeVois 引擎已经解释的命令中。这是通过在模块中实现 \c parseSerial() 函数来实现的。JeVois 引擎会将通过命令行界面收到的任何无法识别的命令转发给该函数。在这里，我们支持一个新命令 \c hello，它将调用我们模块的 \c hello() 成员函数（第 87-88 行）。\c parseSerial() 函数应返回一个字符串，形式为 "OK" 或 "ERR some error message"，或者它可能抛出一个异常（引擎将捕获该异常并以以 "ERR " 开头的消息报告）。引擎会将此处返回的任何字符串转发到适当的 \b serlog 串行端口（有关 \b serlog 的详细信息，请参阅 \ref UserCli ）。

- 第 81-83 行：如果我们支持自定义命令，则应通过在 \c help 中描述它们来让用户知道。这是通过在模块中实现成员函数 \c supportsCommands(self) 来实现的。当用户在命令行界面中键入 \c help 时，引擎将调用它。此函数应返回一个包含命令名称和简要说明的字符串。如果模块支持多个命令，则仅返回一个字符串，并使用换行符 \\n 分隔不同的命令。

- 第 87-88 行：这是当用户在命令行界面上输入 \c hello 时调用的模块成员函数。

// #################################################################################################### 
\section pymoremoduletutorial 更多模块教程和示例

更多信息请参见：

- [JeVoisBase 模块集合的文档](/basedoc/)，查找用 Python 编写的文档（每个模块文档页面顶部的语言字段）。
- [JeVois 教程](/tutorials/)

*/

