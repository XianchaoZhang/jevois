<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_Programmer">

<para>以下页面将帮助您使用 JeVois 进行编程。</para>

<para><itemizedlist>
<listitem>
<para><link linkend="_ProCompile">JeVois-Pro：在设备上克隆和编译 C++ 模块</link></para>
</listitem><listitem>
<para><link linkend="_ProgrammerSource">JeVois Ubuntu 软件包和源代码存储库</link></para>
</listitem><listitem>
<para><link linkend="_Virtualbox">使用 Virtualbox 在虚拟机中设置 jevois-sdk</link></para>
</listitem><listitem>
<para><link linkend="_ProgrammerOrganization">主机和平台上 JeVois 文件的组织</link></para>
</listitem><listitem>
<para><link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link></para>
</listitem><listitem>
<para><link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link></para>
</listitem><listitem>
<para><link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link></para>
</listitem><listitem>
<para><link linkend="_FlashingToSD">刷入 microSD 卡</link></para>
</listitem><listitem>
<para><link linkend="_ProgrammerSDK">程序员 SDK 和编写新模块</link></para>
</listitem><listitem>
<para><link linkend="_ModuleTutorial">关于如何为 JeVois 编写新的机器视觉模块的教程</link></para>
</listitem><listitem>
<para><link linkend="_ModuleTips">编写机器视觉模块的技巧</link></para>
</listitem><listitem>
<para><link linkend="_ProgrammerPython">使用 Python 编程机器视觉模块</link></para>
</listitem><listitem>
<para><link linkend="_ModulePythonTutorial">关于如何用 Python 编写新的机器视觉模块的教程</link></para>
</listitem><listitem>
<para><link linkend="_Debugging">调试 JeVois 软件</link></para>
</listitem><listitem>
<para><link linkend="_ProgrammingGuidelines">JeVois 核心框架贡献者的通用编程指南</link></para>
</listitem><listitem>
<para><link linkend="_DocumentationRules">文档规则和指南</link> </para>
</listitem></itemizedlist>
</para>
    <section xml:id="_ProCompile"><title>JeVois-Pro：在设备上克隆和编译 C++ 模块</title>    </section>
<para>：从 开始，您可以在正在运行的相机上编辑和编译 C++ 模块。虽然速度很慢，但效果很好。这主要用于启动模块和进行小型调试编辑。对于更广泛的 C++ 代码编写，我们建议在功能强大的 Linux 桌面上使用 JeVois-Pro SDK，首先在主机模式下测试模块，然后交叉编译以在相机上运行。有关更多信息，请参阅 程序员。</para>

<para>步骤 1：克隆现有模块以提供工作起点 =========================================================================</para>

<para>在 GUI 的 <emphasis>系统选项卡中，单击“创建新的机器视觉模块</emphasis>...”</para>

<para>  </para>

<para>第 2 步：选择要克隆的模块 ======================================</para>

<para>单击顶部的“...”菜单并选择要克隆的模块。</para>

<para>  </para>

<para>这里我们将克隆 <emphasis role="bold">PassThrough</emphasis> 模块，使用 1920x1080 视频进行显示，使用 512x288 灰度视频进行处理：</para>

<para>  </para>

<para>将创建一个新模块，其供应商名称为 <emphasis>Testing，模块名称为</emphasis> <emphasis>MyPassThrough（如果您多次克隆同一个模块，您将获得</emphasis> <emphasis>MyPassThrough2、<emphasis>MyPassThrough3</emphasis> 等）。源代码将保存在</emphasis> <emphasis role="bold">/jevoispro/modules/Testing/MyPassThrough/</emphasis> 中，您应该经常备份它，以防您的 microSD 卡以某种方式损坏。如果您不喜欢这些名称，请随意编辑它们。然后单击 <emphasis role="bold">创建按钮。</emphasis> </para>

<para>  </para>

<para>步骤3：克隆的初始编译========================================</para>

<para>复制完成后，会打开一个新窗口，我们会立即尝试编译克隆。请耐心等待，这需要一段时间（几分钟）。</para>

<para>  </para>

<para>编译完成后（这应该始终适用于新克隆），系统将询问您是否要运行该模块。单击 <emphasis role="bold">Yes</emphasis> 运行它。</para>

<para>  </para>

<para>步骤4：编辑代码=================</para>

<para>一旦克隆被加载并运行，您就可以在 GUI 的 <emphasis>Code</emphasis> 选项卡中访问其源代码。</para>

<para>  </para>

<para>请注意，C++ 源代码和相关的 CMakeLists.txt 均可在代码编辑器中使用。大多数用户无需修改 CMakeLists.txt，除非他们想要链接到额外的库或编译额外的源文件。</para>

<para>  </para>

<para>让我们尝试一下编辑。在 <emphasis role="bold">PassThrough</emphasis> 中，我们在某个点绘制一个绿色圆圈围绕鼠标指针。这是为了演示使用 ImGui 前景绘制列表在渲染窗口顶部绘制内容的能力。让我们将该绿色圆圈的半径从 20 像素更改为 120 像素。</para>

<para><note><title>Note</title>

<para>记得编辑正确的 <emphasis role="bold">process()</emphasis> 函数。如果您的模块在 JeVois-Pro GUI 模式下运行，则需要使用以下签名编辑该函数：<emphasis role="bold">virtual void process(jevois::InputFrame &amp;&amp; inframe, jevois::GUIhelper &amp; helper) override</emphasis></para>
</note>
  </para>

<para>单击 <emphasis role="bold">Save</emphasis> 保存修改后的代码（或按 CTRL-S）：</para>

<para>  </para>

<para>这将触发重新编译。</para>

<para>  </para>

<para>编译完成后，您可以运行该模块：</para>

<para>  </para>

<para>是的，鼠标指针周围的绿色圆圈现在更大了！</para>

<para>  </para>

<para>第 5 步：处理错误 ============================</para>

<para>如果构建过程中的任何步骤失败，您将看到一条错误消息。这里让我们添加一些有缺陷的 C++ 代码来看看会发生什么：</para>

<para>  </para>

<para>这将触发编译错误：</para>

<para>  </para>

<para>如果您向上滚动到编译窗口的顶部，您可以使用按钮来编辑有问题的源代码或 CMakeLists.txt：</para>

<para>  </para>

<para>第 6 步：处理硬崩溃 =============================</para>

<para>如果您以某种方式修改模块，导致整个 JeVois 框架严重崩溃（例如，通过访问数组末尾的内存而导致分段错误），那么您将无法再加载和运行该模块，这意味着您无法再轻松更改其源代码。</para>

<para>处理方法如下：加载任何其他工作模块。然后在代码编辑器中，选择标准文件末尾的“浏览/创建文件...”。然后导航到文件的 C++ 源代码，例如 /jevoispro/modules/Testing/MyX.C 并打开该文件。</para>

<para>修复代码并保存。这将重新编译模块。由于源文件是手动选择的，我们不知道您想在该代码上运行哪种视频映射（相机分辨率等）。因此，编译后，它将因内部错误而无法加载。没关系，只需忽略错误，然后从可用模块的下拉列表中，您现在可以手动选择模块。 </para>
    <section xml:id="_ProgrammerSource"><title>JeVois Ubuntu 软件包和源代码存储库</title>    </section>
<para>所有 JeVois 软件都是开源的。</para>

<para>它是根据 GNU 通用公共许可证授权的。请注意此许可证的病毒性质，即，如果您将任何 JeVois 源代码集成到您自己的项目中，那么您也必须发布派生的源代码。</para>

<para>请参阅 <link xlink:href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL 页面</link> 了解更多信息。</para>

<para>所有 JeVois 源代码均托管在 Github 上，网址为 <link xlink:href="https://github.com/jevois">https://github.com/jevois</link></para>

<para>提供了以下存储库：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">jevois：核心</emphasis> C++17 JeVois 软件。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisbase：JeVois</emphasis> 的超过 25 个机器视觉模块的基本集合。</para>
</listitem><listitem>
<para><emphasis role="bold">samplemodule：JeVois</emphasis> 的示例独立模块，用作新模块的模板。</para>
</listitem><listitem>
<para><emphasis role="bold">samplepythonmodule：JeVois</emphasis> 的示例 Python 独立模块，用作新模块的模板。</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-sdk：为</emphasis> 相机提供 Linux 内核和操作系统的框架，可刷入 microSD 卡。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-sdk：为</emphasis> 相机提供 Linux 内核和操作系统的框架，可刷入 microSD 卡。</para>
</listitem></itemizedlist>
</para>
<section xml:id="_ProgrammerSource_1autotoc_md96">
<title>从 jevois.usc.edu 安装预编译代码</title>

<para>请参阅 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 了解最新说明。</para>

<para>我们为上面列出的 GitHub 存储库提供预编译的 Ubuntu deb 包。</para>
<section xml:id="_ProgrammerSource_1autotoc_md97">
<title>设置 jevois.usc.edu apt 源</title>

<para>截至撰写本文时，对于运行 Ubuntu 20.04 amd64 的桌面：</para>

<para><literallayout><computeroutput>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys DD24C027
sudo add-apt-repository &quot;deb https://jevois.usc.edu/apt focal main&quot;
sudo apt update
sudo apt upgrade # see note below
sudo apt autoremove
sudo apt purge modemmanager
sudo usermod -aG dialout $USER # need to reboot to take effect
sudo usermod -aG video $USER # need to reboot to take effect
</computeroutput></literallayout></para>

<para><note><title>Note</title>

<para>从 开始，jevois.usc.edu 现在还托管 Google Coral EdgeTPU 和 Hailo deb 包的镜像副本，因此您不需要从各自的供应商处获取这些包。</para>
</note>
</para>
</section>
</section>
<section xml:id="_ProgrammerSource_1autotoc_md98">
<title>为 JeVois-A33 开发安装 Ubuntu 软件包</title>

<para>因为在 上运行的操作系统尽可能小，并且没有包管理系统、编译器等，所以 的总体策略是我们在桌面计算机上交叉编译所有代码，并将编译结果放入暂存区，然后将其刷入 microSD。</para>

<para>因此， 的所有软件包均适用于 Intel amd64 架构，并将安装在桌面上，但有些软件包确实包含 JeVois-A33 的 ARM 处理器的交叉编译代码。此交叉编译代码将从暂存复制到 microSD。</para>

<para> 的以下软件包可在 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 上获取：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">jevois-opencv：OpenCV</emphasis> 4.x 为主机编译，其设置与 JeVois 平台硬件使用的设置相匹配。我们将此包安装到 /usr/share/jevois-opencv-4.x，这样它就不会干扰您主机系统上可能安装的任何其他 OpenCV，而这些 OpenCV 可能是其他软件所需要的。</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-host：为在主机上执行而编译的</emphasis> JeVois 核心软件</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-platform：JeVois</emphasis> 核心软件交叉编译，用于在 JeVois 平台硬件上执行</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisbase-host：为在主机上执行而编译的</emphasis> JeVois 基础模块</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisbase-platform：JeVois</emphasis> 基础模块交叉编译，用于在 JeVois 平台硬件上执行</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-sdk：编译的引导加载程序、根文件系统和其他配置文件。</emphasis> </para>
</listitem><listitem>
<para><emphasis role="bold">jevois-sdk-dev：为</emphasis> JeVois 平台架构编译的交叉编译器和交叉编译库。</para>
</listitem></itemizedlist>
</para>

<para>由于 jevois-sdk-dev 将所有其他依赖项都带入，因此启动和运行 JeVois 开发现在只需一个 apt-get install 命令。</para>

<para>有关这些不同软件包中文件组织的详细信息，请参阅 <link linkend="_ProgrammerOrganization">主机和平台上 JeVois 文件的组织</link></para>
<section xml:id="_ProgrammerSource_1autotoc_md99">
<title>为 JeVois-A33 安装哪些软件包？</title>

<para><itemizedlist>
<listitem>
<para>如果您只想在桌面上安装并运行 <link linkend="_JeVoisInventor">JeVois-A33：JeVois Inventor 图形用户界面</link> <literallayout><computeroutput>  sudo apt install jevois-inventor</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您只想在带有标准网络摄像头的主机上运行 JeVois 软件 (jevois-daemon)： <literallayout><computeroutput>  sudo apt install jevois-host jevoisbase-host</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望 jevois 和 jevoisbase 针对平台硬件进行交叉编译： <literallayout><computeroutput>  sudo apt install jevois-platform jevoisbase-platform</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望能够使用 jevois-flash-card 刷新 microSD 卡：<literallayout><computeroutput>sudo apt install jevois-sdk </computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望能够为 JeVois 平台硬件交叉编译新模块： <literallayout><computeroutput>  sudo apt install jevois-sdk</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望能够重新编译平台 Linux 内核或更改平台操作系统或向平台添加新的 buildroot 包：</para>

<para>您需要从源代码重建 jevois-sdk。按照 <link xlink:href="https://github.com/jevois">https://github.com/jevois</link> 上的 jevois 存储库的 INSTALL 文件中的说明进行操作。</para>
</listitem></itemizedlist>
</para>
</section>
</section>
<section xml:id="_ProgrammerSource_1autotoc_md100">
<title>为 JeVois-Pro 开发安装 Ubuntu 软件包</title>

<para>因为 运行完整的 Ubuntu 操作系统，所以在相机上安装软件包就像在普通计算机上安装一样。</para>

<para>以下软件包可在 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 上获取，适用于 <emphasis>amd64（安装在桌面上）：</emphasis> </para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">jevoispro-opencv：为主机编译的</emphasis> OpenCV 4.x，其设置与 JeVois-Pro 平台硬件使用的设置相匹配。我们将此包安装到 /usr/share/jevois-opencv-4.x，这样它就不会干扰您主机系统上可能安装的任何其他 OpenCV，而这些 OpenCV 可能是其他软件所需要的。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-openvino：英特尔神经网络框架</emphasis> OpenVino 为主机编译，其设置与 JeVois 平台硬件使用的设置相匹配。我们将此包安装到 /usr/share/jevoispro-openvino-x 中，这样它就不会干扰您主机系统上可能安装的任何其他 OpenVino，而其他软件可能需要这些安装。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-host：编译用于主机执行的</emphasis> JeVois 核心软件。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisprobase-host：编译用于主机上执行的</emphasis> JeVois 基础模块。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-platform：JeVois</emphasis> 核心软件为 arm64 处理器交叉编译为 <emphasis>支持包，它将提供必要的</emphasis> ARM 库，以便您以后交叉编译自己的机器视觉模块。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisprobase-platform：JeVois</emphasis> 基础模块为 arm64 处理器交叉编译为 <emphasis>支持包，它将提供必要的</emphasis> ARM 库，以便您以后交叉编译自己的机器视觉模块。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-sdk-dev：交叉编译的操作系统和库，安装在主机上以支持</emphasis> JeVois 软件在该平台的交叉编译。也就是说，在桌面上安装 jevoispro-sdk-dev 将允许您为平台交叉编译 jevois 和 jevoisbase，找到可能需要的必要交叉编译库。</para>
</listitem></itemizedlist>
</para>

<para>以下软件包可在 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 上获取，适用于 <emphasis>arm64（安装在</emphasis> JeVois-Pro 上）：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">jevoispro-opencv：为</emphasis> JeVois-Pro 编译的 OpenCV 4.x。我们将此包安装到相机上的 /usr/share/jevois-opencv-4.x 中。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-openvino：为</emphasis> JeVois-Pro 编译的英特尔神经网络框架 OpenVino。我们将此包安装到相机上的 /usr/share/jevoispro-openvino-x 中。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-platform：JeVois</emphasis> 核心软件交叉编译，用于在 JeVois-Pro 平台硬件上执行，作为 arm64 的本机包。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoisprobase-platform：JeVois</emphasis> 基础模块已编译，可在 JeVois-Pro 平台硬件上执行，作为 arm64 的 <emphasis>本机包。</emphasis> </para>
</listitem></itemizedlist>
</para>

<para><note><title>Note</title>

<para>安装 jevoispro-sdk-dev 将自动将所有其他包作为依赖项拉取。</para>
</note>
以下是您将看到的内容的演练：</para>

<para></para>
<section xml:id="_ProgrammerSource_1autotoc_md101">
<title>在桌面主机上为 JeVois-Pro 安装哪些软件包？</title>

<para><itemizedlist>
<listitem>
<para>如果您只想在带有标准网络摄像头的主机上运行 JeVois 软件 (jevois-daemon)： <literallayout><computeroutput>  sudo apt install jevoispro-host jevoisprobase-host</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>

<para><note><title>Note</title>

<para>是的，这将拉取超过 500 个依赖包，这是正常的，只需选择 Yes 即可全部安装。它们包括 JeVois 使用的许多库、Coral 库、Boost、OpenCV 和 OpenVino 等。</para>
</note>
<itemizedlist>
<listitem>
<para>如果您希望将 jevois 和 jevoisbase 交叉编译为平台硬件，作为 <emphasis>support</emphasis> 包安装在您的主机上（稍后需要从源代码交叉编译您自己的模块）： <literallayout><computeroutput>  sudo apt install jevoispro-platform jevoisprobase-platform</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望能够交叉编译 jevois、jevoisbase 或 JeVois 平台硬件的新模块： <literallayout><computeroutput>  sudo apt install jevoispro-sdk-dev</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您希望能够重新编译平台 Linux 内核或者更改平台操作系统：</para>

<para>您需要使用 <computeroutput>rebuild-os.sh</computeroutput> 从源代码重建 jevoispro-sdk，如下所述。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerSource_1autotoc_md102">
<title>在 JeVois-Pro 智能相机上安装哪些软件包？</title>

<para><note><title>Note</title>

<para>apt 源 jevois.usc.edu 和 Google Coral 的源已经在 microSD 上配置，因此您不需要使用上面详述的 <computeroutput>add-apt-repository</computeroutput> 命令将它们添加到您的相机。</para>
</note>
在运行以下命令之前，你需要将相机连接到网络，如 <link linkend="_ProNetwork">JeVois-Pro：连接到有线或 WiFi 网络</link> 中所述</para>

<para><note><title>Note</title>

<para>jevoispro-opencv、jevoispro-openvino、jevoispro-platform 和 jevoisprobase-platform 已预装在 microSD 上。</para>
</note>
运行以下命令最简单的方法是将 JeVois-Pro 切换到控制台启动，如 <link linkend="_ProUserQuick">JeVois-Pro 快速入门用户指南</link> 中所述，然后以用户 <emphasis>root</emphasis> 身份使用密码 <emphasis>jevois</emphasis> 登录</para>

<para><itemizedlist>
<listitem>
<para>如果您想将 jevoispro-platform 和 jevoisprobase-platform 更新到 jevois.usc.edu 发布的最新官方版本： <literallayout><computeroutput>  sudo apt update
  sudo apt upgrade</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您不小心弄乱了 microSD 上的 jevois 或 jevoisbase（例如，删除了一些关键文件）并想要重新安装在 jevois.usc.edu 上发布的最新官方版本： <literallayout><computeroutput>  sudo apt purge jevoispro-platform jevoisprobase-platform
  sudo apt update
  sudo apt install jevoispro-platform jevoisprobase-platform</computeroutput></literallayout> 如果这不能解决您的问题，您可能需要重新刷新您的 microSD。</para>
</listitem><listitem>
<para>如果您修改了 jevois 和 jevoisbase，然后从源代码对其进行了交叉编译（请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> 和 <link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link> ），并且想要在相机上安装这些软件包： <literallayout><computeroutput>  sudo apt purge jevoispro-platform jevoisprobase-platform
  # 将您创建的 debs 放到 microSD 上
  dpkg -i jevoispro-platform-XXX_arm64.deb
  dpkg -i jevoisprobase-platform-XXX_arm64.deb</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>
</section>
</section>
<section xml:id="_ProgrammerSource_1autotoc_md103">
<title>JeVois-A33 操作系统源代码下载并从头开始构建</title>

<para>这仅推荐给想要修改 Linux 内核或 JeVois 操作系统的高级程序员。</para>

<para>下载和安装说明位于 <link xlink:href="https://github.com/jevois/jevois/blob/master/INSTALL">jevois 存储库的 INSTALL 文件</link>。</para>
</section>
<section xml:id="_ProgrammerSource_1autotoc_md104">
<title>JeVois-Pro 操作系统源代码下载并从头开始构建</title>

<para>这仅推荐给想要修改 JeVois-Pro 的 Linux 内核或操作系统的高级程序员。如果您只需要交叉编译的操作系统以便编译和链接自定义代码，请安装 <emphasis role="bold">jevoispro-sdk-dev</emphasis> deb 包。</para>

<para><literallayout><computeroutput>git clone https://github.com/jevois/jevoispro-sdk.git
cd jevoispro-sdk
./rebuild-os.sh
</computeroutput></literallayout></para>

<para>这将需要很长时间，可能超过 12 小时，具体取决于您的计算机和网络速度。</para>

<para><note><title>Note</title>

<para>如果您还想重新创建 <emphasis role="bold">jevoispro-sdk-dev</emphasis> deb 包，以便以后可以将其安装在另一台台式计算机上，请使用 <computeroutput>./rebuild-os -deb</computeroutput></para>
</note>
以下是运行“rebuild-os.sh”时应该看到的内容的演练：</para>

<para> </para>
</section>
    <section xml:id="_Virtualbox"><title>使用 Virtualbox 在虚拟机中设置 jevois-sdk</title>    </section>
<para>强烈建议您使用虚拟机软件来全新安装 Ubuntu，并将 JeVois 开发环境安装到其中。这样，您就不会遇到 JeVois 所需的软件包版本不同以及您在台式机和笔记本电脑上运行的其他应用程序所需的软件包版本不同导致的问题。</para>

<para>以下是使用免费 Virtualbox 软件执行此操作的简要说明：</para>

<para><itemizedlist>
<listitem>
<para>从 <link xlink:href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</link> 下载并安装 Virtualbox（获取适合您当前计算机的版本，称为 <emphasis>host</emphasis> computer，例如，如果使用 Mac，请获取适用于 OS X 主机的版本）。</para>
</listitem><listitem>
<para>下载并安装相应的 VirtualBox Oracle VM VirtualBox 扩展包，确保扩展包的版本与您安装的 Virtualbox 版本完全匹配。</para>
</listitem><listitem>
<para><emphasis>IMPORTANT：您必须重启计算机，安装才能在稍后正常运行。特别是对于</emphasis> Mac 用户来说，重启 Mac 的情况并不常见，但您需要在此处重启，否则视频捕获稍后可能无法正常工作。</para>
</listitem><listitem>
<para>创建一个新的虚拟机：选择 Linux 64 位操作系统，分配尽可能多的 RAM 和 CPU（通常将滑块移动到变为红色的位置），然后创建一个新的虚拟硬盘，使用 VDI 方法并选择至少 50GB 大小。</para>
</listitem></itemizedlist>
</para>

<para></para>

<para></para>

<para></para>

<para></para>

<para></para>

<para><itemizedlist>
<listitem>
<para>从 <link xlink:href="https://www.ubuntu.com/download/desktop">https://www.ubuntu.com/download/desktop</link> 获取 Ubuntu 20.04 Desttop amd64 iso 文件</para>
</listitem><listitem>
<para>启动虚拟机。由于虚拟机尚未安装操作系统，因此系统会要求您提供 iso 文件，请选择刚刚下载的 Ubuntu iso。</para>
</listitem><listitem>
<para>安装 Ubuntu。确保将整个虚拟磁盘分配给单个根分区（当询问如何格式化磁盘时，这是默认设置），以便根分区中有足够的空间。</para>
</listitem><listitem>
<para>安装 Ubuntu 后，您可以启动它，打开终端，然后按照 <link linkend="_ProgrammerSource">JeVois Ubuntu 软件包和源代码存储库</link> 和 <link xlink:href="http://jevois.org/tutorials/ProgrammerSetup.html">程序员安装教程</link> 中的详细说明安装 JeVois SDK。</para>
</listitem><listitem>
<para>为了能够抓取视频，请转到虚拟机的设置（Virtualbox 主面板中的黄色齿轮），并确保在“端口”、“USB”下启用 USB 2.0 或 USB 3.0。然后插入 USB 摄像头，并为其添加设备过滤器（单击 USB 连接器顶部带有 + 号的图标）。我们建议您重新启动虚拟机和主机。</para>
</listitem></itemizedlist>
</para>

<para></para>

<para></para>

<para><itemizedlist>
<listitem>
<para>返回虚拟机，通过输入：<literallayout><computeroutput>sudo apt install guvcview </computeroutput></literallayout> 安装“guvcview”，您应该能够从 USB 摄像头中获取视频。</para>
</listitem></itemizedlist>
</para>

<para></para>
<section xml:id="_Virtualbox_1autotoc_md146">
<title>无头 VirtualBox</title>

<para>使用 Linux 主机时，在终端中运行 JeVois SDK 虚拟机通常更方便，而无需整个图形界面。这样您就可以简单地将命令从另一个终端复制/粘贴到运行虚拟机的终端。您无法在那台无头机器上运行 jevois-inventor，因此这更适合 C++ 开发和编译。</para>

<para>要启用无头模式，您需要在虚拟机上启用 SSH 端口转发规则，如下所示：</para>

<para><itemizedlist>
<listitem>
<para>在主机上的终端中，如果您还没有密钥，请创建一个带有空密码的密钥： <literallayout><computeroutput>  ssh-keygen -t rsa</computeroutput></literallayout> 当提示输入密码时，只需按 ENTER 键。</para>
</listitem><listitem>
<para>在虚拟机上，安装 openssh-server： <literallayout><computeroutput>  sudo apt install openssh-server</computeroutput></literallayout></para>
</listitem><listitem>
<para>在 VirtualBox 中，选择虚拟机的 <emphasis>Settings，然后选择</emphasis> <emphasis>Network，点击</emphasis> <emphasis>Advanced，然后点击</emphasis> <emphasis>Port Forwarding</emphasis>。点击带有绿色加号的小图标添加规则，如下所示：<itemizedlist>
<listitem>
<para>name: ssh</para>
</listitem><listitem>
<para>protocol: TCP</para>
</listitem><listitem>
<para>Host IP: leave blank</para>
</listitem><listitem>
<para>Host port: 3000 (or any unused port over 1000)</para>
</listitem><listitem>
<para>Guest IP: leave blank</para>
</listitem><listitem>
<para>Guest port: 22</para>
</listitem></itemizedlist>
</para>

<para>然后单击确定。这会将与主机端口 3000 建立的连接转发到虚拟机端口 22（ssh）。</para>
</listitem><listitem>
<para>将密钥从主机复制到虚拟机： <literallayout><computeroutput>  ssh-copy-id -p 3000 jevois@localhost</computeroutput></literallayout> 当系统询问时，输入密码 <emphasis>jevois</emphasis> </para>
</listitem><listitem>
<para>您现在可以关闭虚拟机并关闭 VirtualBox。</para>
</listitem><listitem>
<para>要以无头方式启动虚拟机并登录：<literallayout><computeroutput>VBoxManage startvm UbuSdk2004 --type headless sleep 20 ssh -p 3000 jevois@localhost </computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>

<para>将上面的 <emphasis>UbuSdk2004</emphasis> 替换为您在创建虚拟机时选择的名称（这是在 VirtualBox 图形界面中机器列表侧栏上显示的名称）。</para>

<para>一切完成，您现在应该登录到虚拟机了。完成后记得使用“sudo shutdown -h now”关闭它。 </para>
</section>
    <section xml:id="_ProgrammerOrganization"><title>主机和平台上 JeVois 文件的组织</title>    </section>
<para>如 <link linkend="_Concepts">本文档中使用的概念</link> 中所述，JeVois 软件可以同时为台式计算机（主机模式，通常使用英特尔计算机快速开发和测试新的机器视觉算法）和 JeVois 平台硬件（平台模式，其中所有内容都为 JeVois 内部的 ARM 处理器进行交叉编译）编译和安装。</para>

<para>另一个因素是，在编译各种元素（Linux 内核、Linux 操作系统和实用程序、OpenCV 和其他库、JeVois 核心、JeVois 模块等）时，JeVois 的 microSD 可能不可用。因此，在平台模式下编译和安装将利用一些所谓的暂存区，即主机上的一些目录，各种零碎将组装到这些目录中，以便稍后将它们刷入 microSD。</para>
<section xml:id="_ProgrammerOrganization_1autotoc_md80">
<title>组织概况</title>

<para><itemizedlist>
<listitem>
<para>在平台上，所有模块和配置文件都安装到专用的 VFAT 分区中：<itemizedlist>
<listitem>
<para>:<emphasis role="bold">/jevois</emphasis> （JeVois 可以将其导出为虚拟 USB 驱动器）。</para>
</listitem><listitem>
<para>:<emphasis role="bold">/jevoispro</emphasis> </para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>可执行文件、核心库和包含文件照常安装到 <emphasis role="bold">/usr/bin</emphasis> 、<emphasis role="bold">/usr/lib</emphasis> 、<emphasis role="bold">/usr/include</emphasis> 等中。</para>
</listitem><listitem>
<para>因此，在主机上，我们还将所有模块和配置文件安装到 <emphasis role="bold">/jevois</emphasis> 或 <emphasis role="bold">/jevoispro</emphasis> 中（这主要是为了避免主机和平台上的路径不同而出现意外，并排除故障为什么在主机模式下运行良好的模块在平台上运行时找不到其数据文件）。</para>
</listitem><listitem>
<para>同样，我们还像往常一样将为主机本地编译的可执行文件、库和包含文件安装到 <emphasis role="bold">/usr/bin</emphasis> 、<emphasis role="bold">/usr/lib</emphasis> 、<emphasis role="bold">/usr/include</emphasis> 等位置。</para>
</listitem><listitem>
<para>：此外，JeVois 平台的引导加载程序、引导配置文件和编译的操作系统被放置在第一个暂存目录 <emphasis role="bold">/var/lib/jevois-build</emphasis> 中，该目录专用于最终进入 microSD 上的 <emphasis role="bold">LINUX</emphasis> 和 <emphasis role="bold">BOOT</emphasis> 分区的所有文件。</para>
</listitem><listitem>
<para>：平台的交叉编译机器视觉模块、库和配置文件被放置在第二个暂存目录 <emphasis role="bold">/var/lib/jevois-microsd</emphasis> 中，该目录专用于最终进入 microSD 上的 <emphasis role="bold">JEVOIS</emphasis> 分区的所有文件。</para>
</listitem><listitem>
<para>：最终的 microSD 闪存脚本 <emphasis role="bold">jevois-flash-card</emphasis> 将 <emphasis role="bold">/var/lib/jevois-build</emphasis> 和 <emphasis role="bold">/var/lib/jevois-microsd</emphasis> 的内容合并到最终的 microSD 卡中。</para>
</listitem><listitem>
<para>：相机的操作系统、交叉编译库等位于 <emphasis role="bold">/usr/share/jevoispro-sdk</emphasis> </para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerOrganization.dox_1autotoc_md81">
<title>JeVois-A33 组织详情</title>

<para><itemizedlist>
<listitem>
<para>为 <emphasis role="bold">host</emphasis> 编译和安装 <emphasis role="bold">jevois</emphasis> 时（在 <emphasis role="bold">jevois</emphasis> 中使用 <computeroutput>./rebuild-host.sh</computeroutput>；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件安装到 <emphasis role="bold">/jevois/config/</emphasis></para>
</listitem><listitem>
<para>包括 <computeroutput>jevois-daemon</computeroutput> 的可执行文件安装到 <emphasis role="bold">/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件（为 host 编译模块时需要）安装到 <emphasis role="bold">/usr/include/jevois/</emphasis></para>
</listitem><listitem>
<para>核心 JeVois 库（<emphasis role="bold">libjevois.so</emphasis> ）安装到 <emphasis role="bold">/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件安装到 <emphasis role="bold">/usr/share/doc/jevois-host/</emphasis></para>
</listitem><listitem>
<para>在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上尝试执行 <computeroutput>dpkg -c jevois-host-VERSION.deb</computeroutput> 确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>交叉编译并安装 <emphasis role="bold">platform</emphasis> 的 <emphasis role="bold">jevois</emphasis> 时（在 <emphasis role="bold">jevois</emphasis> 中使用 <computeroutput>./rebuild-platform.sh</computeroutput>；参见 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件暂存到 <emphasis role="bold">/var/lib/jevois-microsd/config/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/jevois/config/</emphasis> 中。</para>
</listitem><listitem>
<para>包括 <computeroutput>jevois-daemon</computeroutput> 在内的可执行文件暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/bin/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/bin/</emphasis> 中。</para>
</listitem><listitem>
<para>包含文件暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/include/jevois/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/include/jevois/</emphasis> 中。</para>
</listitem><listitem>
<para>核心 JeVois 库 (<emphasis role="bold">libjevois.so</emphasis> ) 暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/lib/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/lib/</emphasis> 中。</para>
</listitem><listitem>
<para>文档文件暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/share/doc/jevois-platform/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/share/doc/jevois-platform/</emphasis> 中。</para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevois-platform-VERSION.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>为 <emphasis role="bold">host</emphasis> 编译和安装 <emphasis role="bold">jevoisbase</emphasis> （或者类似地，<emphasis role="bold">samplemodule</emphasis> 或您自己的模块）时（在 <emphasis role="bold">jevoisbase</emphasis> 内使用 <computeroutput>./rebuild-host.sh</computeroutput>（或您的模块的源代码树）；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件安装到 <emphasis role="bold">/jevois/config/</emphasis></para>
</listitem><listitem>
<para>机器视觉模块安装到 <emphasis role="bold">/jevois/modules/</emphasis></para>
</listitem><listitem>
<para>可执行文件（如果有）安装到 <emphasis role="bold">/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件（在为主机编译其他模块时可能需要）安装到 <emphasis role="bold">/usr/include/jevoisbase/</emphasis></para>
</listitem><listitem>
<para>库（如果有）安装到 <emphasis role="bold">/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件安装到 <emphasis role="bold">/usr/share/doc/jevoisbase-host/</emphasis> +尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoisbase-host-VERSION.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在为 <emphasis role="bold">platform</emphasis> 交叉编译和安装 <emphasis role="bold">jevoisbase（或类似地，<emphasis role="bold">samplemodule</emphasis> 或您自己的模块）时（使用</emphasis> <emphasis role="bold">jevoisbase</emphasis> 中的 <computeroutput>./rebuild-platform.sh</computeroutput>（或您的模块的源代码树）；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件暂存到 <emphasis role="bold">/var/lib/jevois-microsd/config/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/jevois/config/</emphasis> 中。</para>
</listitem><listitem>
<para>机器视觉模块暂存到 <emphasis role="bold">/var/lib/jevois-microsd/modules/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/jevois/modules/</emphasis> 中。</para>
</listitem><listitem>
<para>可执行文件（如果有）暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/bin/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/bin/</emphasis> 中。</para>
</listitem><listitem>
<para>包含文件暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/include/jevoisbase/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/include/jevoisbase/</emphasis> 中。</para>
</listitem><listitem>
<para>库（如果有）（例如，<emphasis role="bold">libjevoisbase.so</emphasis> ）暂存到 <emphasis role="bold">/var/lib/jevois-microsd/lib/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/jevois/lib/</emphasis> 中。请注意此处与主机相比的偏差；这样，在主机上，可以轻松加载库，而无需特别摆弄库路径，而在平台上，最好将它们放在 <emphasis role="bold">/jevois/</emphasis> 中，以便在 JeVois 运行时通过 USB 导出 <emphasis role="bold">JEVOIS</emphasis> 分区来升级它们。</para>
</listitem><listitem>
<para>文档文件暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/share/doc/jevoisbase-platform/</emphasis> 中，并将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/share/doc/jevoisbase-platform/</emphasis> 中。</para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoisbase-platform-VERSION.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><emphasis role="bold">OpenCV</emphasis> 安装在主机上的 <emphasis role="bold">/usr/share/jevois-opencv-VERSION/</emphasis> 中，安装在平台上的 <emphasis role="bold">/usr/bin/</emphasis>、<emphasis role="bold">/usr/lib/</emphasis>、<emphasis role="bold">/usr/include/</emphasis> 等中。这里主机和平台之间再次存在差异，这是因为不希望在主机上过于突兀，因为越来越多的其他软件包倾向于依赖 Ubuntu 提供的标准 OpenCV 软件包，即使这些软件包可能不适合 JeVois（例如，较旧的 OpenCV 版本，可能没有贡献，可能没有 Python 或不同的 Python 版本等）</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-sdk</emphasis> Ubuntu 软件包提供了创建 JeVois microSD 卡所需的以下文件，这些文件是运行 <emphasis role="bold">jevois-sdk</emphasis> 中从源代码进行复杂完整重建的部分结果：<itemizedlist>
<listitem>
<para><computeroutput>/usr/bin/jevois-flash-card</computeroutput> 脚本，用于为 JeVois 刷写 microSD 卡。</para>
</listitem><listitem>
<para>引导加载程序文件、平台的 Linux 操作系统等位于 <emphasis role="bold">/var/lib/jevois-build/boot/</emphasis></para>
</listitem><listitem>
<para>尝试对从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 执行 <computeroutput>dpkg -c jevois-sdk-VERSION.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><emphasis role="bold">jevois-sdk-dev</emphasis> Ubuntu 软件包提供了进一步开发所需的以下附加文件（例如，交叉编译的 OpenCV 库、交叉编译的 boost、交叉编译器等），这些文件是在 <emphasis role="bold">jevois-sdk</emphasis> 中从源代码运行复杂的完整重建的一些结果：<itemizedlist>
<listitem>
<para>在 <emphasis role="bold">/usr/share/jevois-sdk/out/</emphasis> 中预编译的整个 buildroot 树</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerOrganization.dox_1autotoc_md82">
<title>JeVois-Pro 组织详情</title>

<para>由于我们有三种不同的构建，所以事情可能会有点令人困惑：</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>rebuild-pro-host.sh</computeroutput>：为主机（Intel/AMD amd64 处理器）编译并创建一个要安装在主机（amd64）上的包。使用它来编译您将在主机上运行的 JeVois 软件，这在开发新的机器视觉模块时非常有用（无需将文件复制到相机进行测试，只需使用您的桌面即可）。</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform.sh</computeroutput>：针对平台 (ARM arm64) 进行交叉编译，并创建一个 <emphasis>support</emphasis> 包以安装在主机 (amd64) 上。此包包含放置在暂存目录中的 arm64 文件，以便我们可以从主机访问它们，这就是我们将其称为 <emphasis>support</emphasis> 包的原因：它支持为 JeVois 平台交叉编译依赖软件。这是必需的，以便您以后可以为平台交叉编译自己的机器视觉模块，因为这些模块将链接到为平台交叉编译的核心 JeVois 库。</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform-pdeb.sh</computeroutput>：针对平台 (ARM arm64) 进行交叉编译，并创建一个要安装在平台 (arm64) 上的本机包。这是我们用来将 JeVois 软件部署到相机的。我们创建 arm64 包，然后将它们安装在相机上。</para>
</listitem></itemizedlist>
</para>

<para>考虑到这一点：</para>

<para><itemizedlist>
<listitem>
<para>为 <emphasis role="bold">host</emphasis> 编译和安装 <emphasis role="bold">jevois</emphasis> 时（在 <emphasis role="bold">jevois</emphasis> 中使用 <computeroutput>./rebuild-pro-host.sh</computeroutput>；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件安装到 <emphasis role="bold">/jevoispro/config/</emphasis></para>
</listitem><listitem>
<para>包括 <computeroutput>jevoispro-daemon</computeroutput> 的可执行文件安装到 <emphasis role="bold">/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件（编译主机模块时需要）安装到 <emphasis role="bold">/usr/include/jevois/</emphasis></para>
</listitem><listitem>
<para>核心 JeVois 库（<emphasis role="bold">libjevoispro.so</emphasis> ）安装到 <emphasis role="bold">/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件安装到 <emphasis role="bold">/usr/share/doc/jevoispro-host/</emphasis></para>
</listitem><listitem>
<para>在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上尝试执行 <computeroutput>dpkg -c jevoispro-host-VERSION.deb</computeroutput>确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在交叉编译和安装 <emphasis role="bold">platform</emphasis> 的 <emphasis role="bold">jevois</emphasis> 作为 <emphasis>support</emphasis> 包时，将其安装在主机上（在 <emphasis role="bold">jevois</emphasis> 中使用 <computeroutput>./rebuild-pro-platform.sh</computeroutput>；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/config/</emphasis></para>
</listitem><listitem>
<para>包括 <computeroutput>jevoispro-daemon</computeroutput> 的可执行文件暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/include/jevois/</emphasis>，并将在您交叉编译自己的机器视觉模块时使用。</para>
</listitem><listitem>
<para>核心 JeVois 库 (<emphasis role="bold">libjevoispro.so</emphasis> ) 暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/lib/</emphasis> 中，并将在您交叉编译自己的机器视觉模块时使用。</para>
</listitem><listitem>
<para>文档文件暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/share/doc/jevois-platform/</emphasis></para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoispro-platform-VERSION_amd64.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>当将 <emphasis role="bold">jevois</emphasis> 交叉编译为 <emphasis role="bold">platform</emphasis> 的 <emphasis>native</emphasis> 平台 (arm64) 包时（在 <emphasis role="bold">jevois</emphasis> 中使用 <computeroutput>./rebuild-pro-platform-pdeb.sh</computeroutput>；参见 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>您将为 arm64（64 位 ARM）创建一个 deb 包，其文件位置与主机上使用的相同。</para>
</listitem><listitem>
<para>应在登录平台时使用 dpkg 将此包安装在 JeVois-Pro 平台上。</para>
</listitem><listitem>
<para>在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上尝试 <computeroutput>dpkg -c jevoispro-platform-VERSION_arm64.deb</computeroutput> 以确认所有文件位置。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>为 <emphasis role="bold">host</emphasis> 编译和安装 <emphasis role="bold">jevoisbase（或者类似地，<emphasis role="bold">samplemodule</emphasis> 或您自己的模块）时（使用</emphasis> <emphasis role="bold">jevoisbase</emphasis> 中的 <computeroutput>./rebuild-pro-host.sh</computeroutput>（或您的模块的源代码树）；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件安装到 <emphasis role="bold">/jevoispro/config/</emphasis></para>
</listitem><listitem>
<para>机器视觉模块安装到 <emphasis role="bold">/jevoispro/modules/</emphasis></para>
</listitem><listitem>
<para>可执行文件（如果有）安装到 <emphasis role="bold">/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件（在为主机编译其他模块时可能需要）安装到 <emphasis role="bold">/usr/include/jevoisbase/</emphasis></para>
</listitem><listitem>
<para>库（如果有）安装到 <emphasis role="bold">/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件安装到<emphasis role="bold">/usr/share/doc/jevoisprobase-host/</emphasis></para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoisprobase-host-VERSION.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在交叉编译和安装 <emphasis role="bold">platform</emphasis> 的 <emphasis role="bold">jevoisbase（或者类似地，<emphasis role="bold">samplemodule</emphasis> 或您自己的模块）作为</emphasis> <emphasis>support</emphasis> 包安装在主机上时（使用 <emphasis role="bold">jevoisbase</emphasis> 中的 <computeroutput>./rebuild-pro-platform.sh</computeroutput>（或您的模块的源代码树）；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>JeVois 在运行时使用的配置文件暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/config/</emphasis></para>
</listitem><listitem>
<para>机器视觉模块暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/modules/</emphasis></para>
</listitem><listitem>
<para>可执行文件（如果有）暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/include/jevoisbase/</emphasis></para>
</listitem><listitem>
<para>库（如果有）（例如，<emphasis role="bold">libjevoisprobase.so</emphasis> ）暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/lib/</emphasis> 中，并将在交叉编译您自己的模块时使用。</para>
</listitem><listitem>
<para>文档文件暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/share/doc/jevoisbase-platform/</emphasis></para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoisprobase-platform-VERSION_amd64.deb</computeroutput> 进行确认。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>当将 <emphasis role="bold">jevoisbase</emphasis> 交叉编译为 <emphasis>native</emphasis> 平台 (arm64) 包（或者类似地，<emphasis role="bold">samplemodule</emphasis> 或您自己的模块）用于 <emphasis role="bold">platform</emphasis> 时（使用 <emphasis role="bold">jevoisbase</emphasis> 中的 <computeroutput>./rebuild-pro-platform-pdeb.sh</computeroutput>（或您的模块的源代码树）；请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）：<itemizedlist>
<listitem>
<para>您将为 arm64（64 位 ARM）创建一个 deb 包，其文件位置与主机相同。</para>
</listitem><listitem>
<para>应在登录平台时使用 dpkg 将此包安装在 JeVois-Pro 平台上。</para>
</listitem><listitem>
<para>在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上尝试 <computeroutput>dpkg -c jevoisprobase-platform-VERSION_arm64.deb</computeroutput> 以确认所有文件位置。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><emphasis role="bold">OpenCV</emphasis> 和 <emphasis role="bold">OpenVino</emphasis> 安装到主机和平台上的 <emphasis role="bold">/usr/share/jevoispro-opencv-VERSION/</emphasis> 和 <emphasis role="bold">/usr/share/jevoispro-openvino-VERSION/</emphasis>，以避免与您可能已经拥有的其他 OpenCV 和 OpenVino 安装发生冲突。</para>
</listitem><listitem>
<para><emphasis role="bold">jevoispro-sdk-dev</emphasis> Ubuntu 主机包提供了交叉编译 JeVois 软件所需的以下文件：<itemizedlist>
<listitem>
<para><emphasis role="bold">/usr/share/jevoispro-sdk/jevoispro-sysroot</emphasis> 包含在 JeVois-Pro 上运行的整个操作系统的净化版本。净化方式是将所有符号链接转换为 jevoispro-sysroot 目录中的相对位置，而不是在标准 Linux 操作系统中拥有一些绝对符号链接（这些绝对链接最终会指向根文件系统中的库和其他文件，适用于 Intel AMD64，而不是所需的 ARM64 库和文件）。</para>
</listitem><listitem>
<para>尝试在从 <link xlink:href="https://jevois.usc.edu">https://jevois.usc.edu</link> 下载的 deb 上运行 <computeroutput>dpkg -c jevoispro-sdk-dev-VERSION.deb</computeroutput> 进行确认。 </para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</section>
    <section xml:id="_CompilingJeVois"><title>从源代码编译 JeVois 核心软件</title>    </section>
<para>JeVois 核心软件位于名为 <emphasis role="bold">jevois</emphasis> 的存储库中，位于 <link xlink:href="https://github.com/jevois">https://github.com/jevois</link></para>

<para>仅 Ubuntu Linux（建议使用 20.04（1.20.0）/24.04（1.21.0） amd64 版本）支持从源代码编译 JeVois 核心软件。</para>

<para>在尝试编译 JeVois 之前，您应该至少阅读一次 <link xlink:href="https://github.com/jevois/jevois/blob/master/INSTALL">INSTALL 说明</link>。作为此过程的一部分，您将下载所有 JeVois 核心软件和所有必要的 Ubuntu 软件包。</para>
<section xml:id="_CompilingJeVois_1autotoc_md4">
<title>理论</title>

<para>JeVois 核心软件是用 C++-17 编写的。它提供从摄像头传感器捕获视频、将视频输出到 USB 链路、串行通信、基本低级图像处理功能的代码，支持从具有运行时可调参数的组件集合创建更高级的机器视觉算法，以及支持在运行时加载/卸载机器视觉模块。</para>

<para>JeVois 核心软件使用 <link xlink:href="https://cmake.org">CMake</link> 配置和编译。</para>

<para>它可以在您的 Linux 计算机上本地编译（<emphasis role="bold">host</emphasis> 模式），在这种情况下，视频将从任何连接的摄像头捕获，视频输出将发送到您的计算机显示器。它还可以为 JeVois 智能摄像头内的 CPU 进行交叉编译（<emphasis role="bold">platform</emphasis> 模式），在这种情况下，视频将从 JeVois 摄像头内的视频传感器捕获，视频输出将通过 USB 链路进行流式传输。</para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md5">
<title>从 GitHub 获取源代码</title>

<para><literallayout><computeroutput>cd
git clone https://github.com/jevois/jevois.git
</computeroutput></literallayout></para>

<para>我们还强烈建议您从 GitHub 获取其他 JeVois 源代码存储库：</para>

<para><literallayout><computeroutput>git clone https://github.com/jevois/jevoisbase.git
git clone https://github.com/jevois/samplemodule.git
git clone https://github.com/jevois/samplepythonmodule.git
git clone https://github.com/jevois/jevois-tutorials.git
</computeroutput></literallayout></para>

<para>对于： <literallayout><computeroutput>git clone https://github.com/jevois/jevois-sdk.git
</computeroutput></literallayout></para>

<para>or, for: <literallayout><computeroutput>git clone https://github.com/jevois/jevoispro-sdk.git
</computeroutput></literallayout></para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md6">
<title>交叉编译代码所需的 SDK</title>

<para>要为主机编译 jevois、jevoisbase、samplemodule 等，您只需继续下一部分即可。</para>

<para>要为平台交叉编译这些，首先需要安装 JeVois SDK，因为它将提供交叉编译所需的 ARM 库。最简单的方法是安装 <emphasis role="bold">jevois-sdk-dev</emphasis> 或 <emphasis role="bold">jevoispro-sdk-dev</emphasis> debian 文件，详情请参阅 <link linkend="_ProgrammerSource">JeVois Ubuntu 软件包和源代码存储库</link></para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md7">
<title>JeVois-A33：完全重新配置和编译</title>

<para>有两种方法可以为 编译软件：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">host：</emphasis> 在您的 amd64 桌面上本地编译，以便在该 amd64 桌面上执行。在开发期间使用此功能，因为它允许您在桌面上编译代码，然后立即使用常规网络摄像头对其进行测试。当然，某些模块在桌面上不起作用，例如如果它们使用 ARM 特定的 NEON 指令。但总的来说，这是开发和调试新机器视觉模块的最快方法。</para>
</listitem><listitem>
<para><emphasis role="bold">platform：</emphasis> 在您的桌面上交叉编译适用于 ARM 目标处理器的代码，这是 中使用的架构。交叉编译的文件将存储在暂存区（<emphasis role="bold">/var/lib/jevois-build</emphasis> 和 <emphasis role="bold">/var/lib/jevois-microsd</emphasis> ）中，然后可以将其刷入 microSD。</para>
</listitem></itemizedlist>
</para>

<para>提供了脚本来重新编译所有内容：</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>rebuild-host.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为您计算机的 CPU 进行本地编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">hbuild/</emphasis> 中</para>
</listitem><listitem>
<para>可执行文件将安装到 <emphasis role="bold">/usr/bin</emphasis> </para>
</listitem><listitem>
<para>模块开发人员使用的包含文件将安装在 <emphasis role="bold">/usr/include/jevois</emphasis> 中</para>
</listitem><listitem>
<para>JeVois 配置文件将安装在 <emphasis role="bold">/jevois</emphasis> 中（以匹配其在平台硬件上的位置）。这也是您应该为 JeVois 安装机器视觉模块的地方。</para>
</listitem><listitem>
<para>因此，所有文件和可执行文件都可以立即在您的计算机上使用。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-platform.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois 智能相机内的 ARM CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">pbuild/</emphasis> 中</para>
</listitem><listitem>
<para>JeVois 在运行时使用的配置文件将暂存到 <emphasis role="bold">/var/lib/jevois-microsd/config/</emphasis> 中，稍后将安装到实际 microSD 卡上的 <emphasis role="bold">/jevois/config/</emphasis> 中。</para>
</listitem><listitem>
<para>包括 <computeroutput>jevois-daemon</computeroutput> 在内的可执行文件将暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/bin/</emphasis> 中，稍后将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/bin/</emphasis> 中。</para>
</listitem><listitem>
<para>包含文件将暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/include/jevois/</emphasis> 中，稍后将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/include/jevois/</emphasis> 中。</para>
</listitem><listitem>
<para>核心 JeVois 库 (<emphasis role="bold">libjevois.so</emphasis>) 将暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/lib/</emphasis> 中，稍后将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/lib/</emphasis> 中。</para>
</listitem><listitem>
<para>文档文件将暂存到 <emphasis role="bold">/var/lib/jevois-build/usr/share/doc/jevois-platform/</emphasis> 中，稍后将安装到实际 microSD 卡上的 <emphasis role="bold">/usr/share/doc/jevois-platform/</emphasis> 中。</para>
</listitem><listitem>
<para>因此，由于所有目标文件都存储在暂存区中，它们将准备好被闪存到 microSD，然后可以将其插入到您的 JeVois 智能相机中。</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>创建的主要可执行文件是 <computeroutput>jevois-daemon，它基本上实现了</computeroutput> JeVois 引擎，它将协调从相机传感器到机器视觉处理再到 USB 视频流的数据流。有关更多信息，请参阅 JeVoisDaemon。</para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md8">
<title>JeVois-Pro：完全重新配置和编译</title>

<para>有三种方法可以为 编译软件：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">host：在您的</emphasis> amd64 桌面上本地编译，以便在该 amd64 桌面上执行。在开发期间使用此功能，因为它允许您在桌面上编译代码，然后立即使用常规网络摄像头对其进行测试。当然，某些模块在桌面上不起作用，例如如果它们使用 NPU。但总的来说，这是开发和调试新机器视觉模块的最快方法。</para>
</listitem><listitem>
<para><emphasis role="bold">platform：在您的桌面上交叉编译</emphasis> arm64 目标处理器的代码，这是 中使用的架构。通常，如果您想要将 <emphasis>支持文件放置在暂存区（<emphasis role="bold">/var/lib/jevoispro-build</emphasis> 和</emphasis> <emphasis role="bold">/var/lib/jevoispro-microsd），则只需运行此操作，然后在编译需要链接或以其他方式使用这些文件的其他模块时可以引用这些文件。</emphasis> </para>
</listitem><listitem>
<para><emphasis role="bold">platform-pdeb：在您的桌面上交叉编译</emphasis> 的 arm64 目标处理器代码，并创建一个 <emphasis>原生</emphasis> arm64 deb 包，您稍后可以将其复制到 microSD 并安装在 上。通常，您会在主机模式下测试和调试新的机器视觉模块后执行此操作，现在您已准备好在 相机上试用它。</para>
</listitem></itemizedlist>
</para>

<para>提供了脚本来重新编译所有内容：</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>rebuild-pro-host.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为您计算机的 CPU 进行本地编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">phbuild/</emphasis> 中</para>
</listitem><listitem>
<para>可执行文件将安装到 <emphasis role="bold">/usr/bin</emphasis> </para>
</listitem><listitem>
<para>模块开发人员要使用的包含文件将安装在 <emphasis role="bold">/usr/include/jevois</emphasis> 中</para>
</listitem><listitem>
<para>JeVois 配置文件将安装在 <emphasis role="bold">/jevoispro</emphasis> 中，这也是稍后安装机器视觉模块和 JeVois-Pro 共享数据的地方。</para>
</listitem><listitem>
<para>因此，所有文件和可执行文件都可以立即在您的计算机上使用。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois-Pro 智能相机内的 ARM CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">ppbuild/</emphasis> 中</para>
</listitem><listitem>
<para>JeVois 在运行时使用的配置文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/config/</emphasis></para>
</listitem><listitem>
<para>包括 <computeroutput>jevois-daemon</computeroutput> 的可执行文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/include/jevois/</emphasis></para>
</listitem><listitem>
<para>核心 JeVois 库 (<emphasis role="bold">libjevoispro.so</emphasis>) 将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件将暂存到<emphasis role="bold">/var/lib/jevoispro-build/usr/share/doc/jevoispro-platform/</emphasis></para>
</listitem><listitem>
<para>因此，由于所有目标文件都存储在暂存区中，因此当您尝试编译 jevoisbase 或新的自定义机器视觉模块时，它们将可以用作依赖项。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform-pdeb.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois-Pro 智能相机内的 ARM CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">ppdbuild/</emphasis> 中</para>
</listitem><listitem>
<para>将创建一个 deb 包，该包应在登录相机时安装在相机上。</para>
</listitem><listitem>
<para>文件位置与上述主机相同。</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>创建的主要可执行文件是 <computeroutput>jevoispro-daemon，它基本上实现了</computeroutput> JeVois 引擎，该引擎将协调从相机传感器到机器视觉处理再到 HDMI 视频显示的数据流。有关更多信息，请参阅 JeVoisDaemon。</para>

<para>下面是从 源代码编译 jevois 和 jevoisbase 时应该看到的内容的演示：</para>

<para></para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md9">
<title>部分重新编译</title>

<para>脚本 <computeroutput>rebuild-host.sh、<computeroutput>rebuild-platform.sh</computeroutput> 等会清除并重新编译所有内容。这需要一段时间。</computeroutput> </para>

<para>您应该至少运行它们一次。</para>

<para>然后，如果您只是更改几个文件，那么您只需重新编译所需的文件即可，如下所示：</para>

<para><itemizedlist>
<listitem>
<para>: for host <literallayout><computeroutput>cd hbuild
make -j
sudo make install
make doc     # optional; if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <literallayout><computeroutput>cd pbuild
make -j
sudo make install
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for host <literallayout><computeroutput>cd phbuild
make -j
sudo make install
make doc     # optional; if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <emphasis>support</emphasis> files <literallayout><computeroutput>cd ppbuild
make -j
sudo make install
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <emphasis>native</emphasis> deb <literallayout><computeroutput>cd ppdbuild
make -j
sudo make install
sudo cpack # 将使用 arm64 arch 将 deb 包重新生成为 ppdbuild/jevoispro-platform_XXX_arm64.deb。
# 然后，您可以将此文件复制到 microSD，将 JeVois-Pro 切换到控制台启动，然后
# `apt remove jevoispro-platform` 删除现有版本，然后 `dpkg -i &lt;your_new_deb&gt;`。
</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>

<para><note><title>Note</title>

<para>当您 <computeroutput>apt remove jevoispro-platform</computeroutput> 时，它也会删除 jevoisprobase-platform。因此，请确保您已编译它并将其打包为可安装的 deb，使用 <link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link> 中的说明</para>
</note>
</para>
</section>
<section xml:id="_CompilingJeVois_1autotoc_md10">
<title>高级配置标志</title>

<para>脚本 <computeroutput>rebuild-host.sh</computeroutput>, <computeroutput>rebuild-platform.sh</computeroutput> 等将所有命令行参数传递给 cmake。可用标志包括（请参阅 jevois/ 中的 CMakeLists.txt 了解最新信息）：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">-DJEVOIS_LDEBUG_ENABLE=ON</emphasis> 启用调试级别消息。默认情况下，这些消息处于关闭状态，因此它们不会使用任何 CPU 并且不会减慢操作速度。打开它们对于低级调试很有用。请注意，USB 流式传输代码的某些部分对时间至关重要，并且在启用 LDEBUG 时可能会失败（即给出 USB 错误）。请注意，这只会启用 LDEBUG 语句进行编译。要在运行时查看它们，您还需要将 <computeroutput>loglevel</computeroutput> 参数设置为调试级别，有关 <computeroutput>loglevel</computeroutput> 参数的信息，请参阅 UserCli。</para>
</listitem><listitem>
<para><emphasis role="bold">-DJEVOIS_TRACE_ENABLE=ON</emphasis> 启用函数跟踪，每次进入特定函数时都会发出一条消息（在 LDEBUG 级别），退出时会发出另一条消息。要跟踪的函数需要在其中包含 <link linkend="_group__debugging_1ga9061a9b1a920652dd863efb219c0d9d4">JEVOIS_TRACE(level)</link> 语句。由于跟踪消息处于 LDEBUG 级别，因此如果未启用 LDEBUG（参见上文），则不会看到跟踪消息。</para>
</listitem><listitem>
<para><emphasis role="bold">-DJEVOIS_USE_SYNC_LOG=ON</emphasis> 使用同步日志记录，即，我们等到每条日志消息都打印出来后再继续执行。这会干扰时间关键的代码部分，例如与 USB 流相关的任何内容。因此，默认情况下，JeVois 中的日志记录是异步的，消息只是被推送到队列中而不等待它们被打印出来，然后由单独的线程将它们打印出来。这种异步日志记录消除了由于日志记录而导致的大部分减速，但在调试与 Linux 系统或内核交互的东西时可能会造成混淆，因为 JeVois 消息与 syslog 消息出现的顺序可能无法反映发生事件的真实顺序。</para>
</listitem><listitem>
<para><emphasis role="bold">-DJEVOIS_LOG_TO_FILE=ON</emphasis> 启用将所有日志消息发送到文件 jevois.log 而不是控制台。仅适用于异步日志记录。 </para>
</listitem></itemizedlist>
</para>
</section>
    <section xml:id="_CompilingJeVoisBase"><title>从源代码编译 JeVoisBase 软件</title>    </section>
<para>JeVoisBase 视觉软件位于名为 <computeroutput>jevoisbase</computeroutput> 的存储库中，位于 <link xlink:href="https://github.com/jevois">https://github.com/jevois</link></para>

<para>它提供了超过 25 个机器视觉模块的基本集合。这些模块默认与 JeVois 智能相机捆绑在一起。它们提供了广泛的机器视觉算法，包括视觉注意（visual attention）和场景要点（gist of a scene）、目标识别、QRcode 解码、目标跟踪、道路跟踪（road following）等。</para>

<para>仅 Ubuntu Linux 20.04 amd64 支持从源代码编译 JeVoisBase 软件。</para>

<para>在尝试编译 JeVoisBase 之前，您应该为主机和平台编译 jevois，如 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> 中所述</para>
<section xml:id="_CompilingJeVoisBase_1autotoc_md11">
<title>Theory</title>

<para>JeVoisBase 核心软件采用 C++-17 编写。它使用 JeVois 核心软件提供的功能，并实现可在 JeVois 智能相机上运行的机器视觉模块。</para>

<para>JeVoisBase 软件使用 <link xlink:href="https://cmake.org">CMake</link> 进行配置和编译，与 JeVois 软件一样。</para>

<para>与核心 JeVois 软件一样，它可以在您的 Linux 计算机上本地编译（<emphasis role="bold">host</emphasis> 模式），在这种情况下，视频将从任何连接的摄像头捕获，视频输出将发送到您的计算机显示器。它还可以为 JeVois 智能摄像头内的 CPU 进行交叉编译（<emphasis role="bold">platform</emphasis> 模式），在这种情况下，视频将从 JeVois 摄像头内的视频传感器捕获，视频输出将通过 USB 链路进行流式传输。</para>

<para>由于 JeVoisBase 中的多个机器视觉模块使用相同的组件，例如视觉注意（visual attention）组件，因此 JeVoisBase 的架构如下：</para>

<para><itemizedlist>
<listitem>
<para> 上的 <computeroutput>libjevoisbase.so</computeroutput> 或 上的 <computeroutput>libjevoisprobase.so</computeroutput> 包含所有组件，即基本的机器视觉算法。</para>
</listitem><listitem>
<para>然后，模块只需将这些组件的集合连接在一起，连接到摄像头输入，并通过 USB 或 HDMI 连接到视频流输出。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_CompilingJeVoisBase_1autotoc_md12">
<title>从 GitHub 获取源代码</title>

<para><literallayout><computeroutput>cd
git clone https://github.com/jevois/jevoisbase.git
</computeroutput></literallayout></para>
</section>
<section xml:id="_CompilingJeVoisBase_1autotoc_md13">
<title>首次编译之前：获取贡献的软件包</title>

<para><note><title>Note</title>

<para>编译脚本现在会自动执行此操作。</para>
</note>
目录 <emphasis role="bold">jevoisbase/Contrib</emphasis> 用于收集贡献的源代码包。</para>

<para>在您第一次尝试编译 jevoisbase 之前，您应该下载并修补那些贡献的软件包，如下所示：</para>

<para><literallayout><computeroutput>cd jevoisbase/Contrib
./reinstall.sh
</computeroutput></literallayout></para>
</section>
<section xml:id="_CompilingJeVoisBase_1autotoc_md14">
<title>JeVois-A33：完全重新配置和编译</title>

<para>提供了脚本来重新编译所有内容：</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>rebuild-host.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为您计算机的 CPU 进行本机编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <computeroutput>hbuild/</computeroutput> 中</para>
</listitem><listitem>
<para>模块和库将安装在 <computeroutput>/jevois</computeroutput> 中（以匹配它们在平台硬件上的位置）</para>
</listitem><listitem>
<para>因此，模块可立即在您的计算机上使用。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-platform.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois 智能相机 (arm-gnueabi-hf) 内的 CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <computeroutput>pbuild/</computeroutput> 中</para>
</listitem><listitem>
<para>模块、配置文件等将安装到暂存目录 <emphasis role="bold">/var/lib/jevois-microsd/</emphasis>（参见 ProgrammerOrganization），稍后可将其刷入 microSD。</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>一旦为主机编译并安装 jevoisbase，您就可以使用 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> 进行尝试。</para>
</section>
<section xml:id="_CompilingJeVoisBase_1autotoc_md15">
<title>JeVois-Pro：完全重新配置和编译</title>

<para>提供了脚本来重新编译所有内容：</para>

<para><itemizedlist>
<listitem>
<para><computeroutput>rebuild-pro-host.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为您计算机的 CPU 进行本地编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <computeroutput>phbuild/</computeroutput> 中</para>
</listitem><listitem>
<para>模块和库将安装在 <computeroutput>/jevoispro</computeroutput> 中（以匹配它们在平台硬件上的位置）</para>
</listitem><listitem>
<para>因此，模块可立即在您的计算机上使用。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois-Pro 智能相机内的 ARM CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">ppbuild/</emphasis> 中</para>
</listitem><listitem>
<para>JeVois 在运行时使用的配置文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-microsd/config/</emphasis></para>
</listitem><listitem>
<para>包括 <computeroutput>jevois-daemon</computeroutput> 的可执行文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/bin/</emphasis></para>
</listitem><listitem>
<para>包含文件将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/include/jevois/</emphasis></para>
</listitem><listitem>
<para>核心 JeVois Base 库 (<emphasis role="bold">libjevoisprobase.so</emphasis>) 将暂存到 <emphasis role="bold">/var/lib/jevoispro-build/usr/lib/</emphasis></para>
</listitem><listitem>
<para>文档文件将暂存到<emphasis role="bold">/var/lib/jevoispro-build/usr/share/doc/jevoispro-platform/</emphasis></para>
</listitem><listitem>
<para>因此，由于所有目标文件都存储在暂存区中，因此当您尝试编译新的自定义机器视觉模块时，它们将可以用作依赖项。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><computeroutput>rebuild-pro-platform-pdeb.sh</computeroutput> 将<itemizedlist>
<listitem>
<para>为 JeVois-Pro 智能相机内的 ARM CPU 进行交叉编译</para>
</listitem><listitem>
<para>目标文件将位于脚本创建的 <emphasis role="bold">ppdbuild/</emphasis> 中</para>
</listitem><listitem>
<para>将创建一个 deb 包，该包应在登录相机时安装在相机上。</para>
</listitem><listitem>
<para>文件位置与上述主机相同。</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>

<para>一旦为主机编译并安装 jevoisbase，您就可以使用 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> 进行尝试。</para>

<para>下面是从 源代码编译 jevois 和 jevoisbase 时应该看到的内容的演示：</para>

<para></para>
</section>
<section xml:id="_CompilingJeVoisBase_1autotoc_md16">
<title>部分重新编译</title>

<para>脚本 <computeroutput>rebuild-host.sh</computeroutput> 和 <computeroutput>rebuild-platform.sh</computeroutput> 清除并重新编译所有内容。</para>

<para>您应该至少运行它们一次。</para>

<para>然后，如果您只是更改几个文件，那么您只需重新编译所需的文件即可，如下所示：</para>

<para><itemizedlist>
<listitem>
<para>: for host <literallayout><computeroutput>cd hbuild
make -j
sudo make install
make doc     # optional; if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <literallayout><computeroutput>cd pbuild
make -j
sudo make install
make jvpkg   # if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for host <literallayout><computeroutput>cd phbuild
make -j
sudo make install
make doc     # optional; if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <emphasis>support</emphasis> files <literallayout><computeroutput>cd ppbuild
make -j
sudo make install
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform deb <literallayout><computeroutput>cd ppdbuild
make -j
sudo make install
sudo cpack # 将重新生成 deb 包到 ppdbuild/jevoisprobase-platform_XXX_arm64.deb
# 然后您可以将此文件复制到 microSD，将 JeVois-Pro 切换到控制台启动，然后
# `apt remove jevoisprobase-platform` 删除现有版本，然后 `dpkg -i &lt;your_new_deb&gt;`。
</computeroutput></literallayout> </para>
</listitem></itemizedlist>
</para>
</section>
    <section xml:id="_JeVoisDaemon"><title>jevois-daemon 可执行文件</title>    </section>
<para><note><title>Note</title>

<para>为了便于阅读，我们下面只使用 <emphasis role="bold">jevois-daemon</emphasis> ，但在使用 时，应将其替换为 <emphasis role="bold">jevoispro-daemon</emphasis> </para>
</note>
编译 JeVois 框架时创建的主要可执行文件是 上的 <emphasis role="bold">jevois-daemon</emphasis> 或 上的 <emphasis role="bold">jevoispro-daemon</emphasis> ，它基本上实现了 jevois::Engine，它将协调从摄像头传感器到机器视觉处理再到 USB 上的视频流的数据流。</para>

<para><note><title>Note</title>

<para><computeroutput>jevois-deamon</computeroutput> 可以在主机上运行（当为主机编译 jevois 时），在这种情况下，所有机器视觉算法都将在主机上运行。在此模式下，您通常会使用常规 USB 摄像头，或者您可能希望使用仅配置了直通视频映射的 JeVois 智能摄像头（这样 JeVois 摄像头就不会自行进行任何处理）。请参阅 <link linkend="_UserModes">视频模式和映射用户指南</link> 和 <link xlink:href="http://jevois.org/moddoc/PassThrough/modinfo.html">PassThrough 模块</link>。在 JeVois 摄像头处于直通模式的情况下在主机上运行 jevois-daemon 通常有助于收集 JeVois 摄像头看到的训练数据（例如，稍后要识别的物体图片）。</para>

<para><computeroutput>jevois-daemon</computeroutput> 还可在 JeVois 智能相机硬件上运行，只要插入并启动即可。在这种情况下，智能相机硬件将执行所有机器视觉处理。在此模式下操作时，通常您不会希望在主机上再次运行 jevois-daemon，因为这相当于连续运行 jevois-daemon 两次。一个例外是如上所述的训练数据收集。相反，您通常希望在主机上运行普通的视频查看器，例如 guvcview，或者您开发的一些自定义机器视觉代码，它将从 JeVois 相机抓取视频帧，然后在主机上进一步处理它们。</para>
</note>
</para>
<section xml:id="_JeVoisDaemon_1autotoc_md39">
<title>在主机上运行 jevois-daemon</title>

<para>要在主机上运行它，请为主机安装 jevois 和 jevoisbase deb 包（请参阅 <link linkend="_ProgrammerSource">JeVois Ubuntu 软件包和源代码存储库</link> ）。或者从 GitHub 获取源代码并重新编译（请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> 和 <link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link> ），然后在 jevois 和 jevoisbase 中运行 <computeroutput>rebuild-host.sh</computeroutput> 。</para>

<para>然后插入任意 USB 摄像头，并输入</para>

<para><literallayout><computeroutput>jevois-daemon
</computeroutput></literallayout></para>

<para>您应该会在窗口中看到桌面上处理过的来自网络摄像头的视频。请注意，JeVois 核心软件不提供任何模块，因此请确保在尝试使用 jevois-daemon 之前继续编译和安装 jevoisbase。</para>

<para><emphasis role="bold">jevois-daemon</emphasis> 接受许多命令行参数，请尝试</para>

<para><literallayout><computeroutput>jevois-daemon --help
</computeroutput></literallayout></para>

<para>才能看到它们。请注意，jevois-daemon 启动后，其中一些将会消失，例如 <computeroutput>cameradev</computeroutput> 指定要使用的相机（或视频输入文件）。一旦 jevois-daemon 运行，该参数就无法再更改。</para>

<para>一旦 <computeroutput>jevois-daemon</computeroutput> 运行，您就可以通过在启动 jevois-daemon 的终端中键入命令来与 JeVois 系统交互。例如，尝试：</para>

<para><literallayout><computeroutput>info
help
listmappings
</computeroutput></literallayout></para>

<para>要以特定模式启动 jevois-daemon，请在 listmapping 列表中找到其编号，然后键入 &apos;quit&apos; 退出 jevois-daemon，最后</para>

<para><literallayout><computeroutput>jevois-daemon --videomapping=19
</computeroutput></literallayout></para>

<para>使用新的视频映射重新启动它（此处，根据列表映射，映射 19 用于演示二维码）。有关命令的更多信息，请参阅 <link linkend="_UserCli">命令行界面用户指南</link> ，有关与 jevoisbase 中的默认模块集合相对应的视频映射列表，请参阅 <link xlink:href="http://jevois.org/start/start.html">http://jevois.org/start/start.html</link>。</para>

<para><note><title>Note</title>

<para>如果您的 USB 网络摄像头无法支持给定视频映射所需的摄像头分辨率，那么您将收到错误，并且该映射无法在主机上运行。</para>
</note>
</para>
</section>
<section xml:id="_JeVoisDaemon_1autotoc_md40">
<title>jevois-daemon 选项</title>

<para>在撰写本文时， <computeroutput>jevois-daemon</computeroutput> <computeroutput>&#8211;help</computeroutput> 返回（在此重现主要是为了帮助人们通过关键字搜索此文档）：</para>

<para><literallayout><computeroutput>General Options:  
  --tracelevel (unsigned int) default=[0]
    Set the minimum trace level to display

  --loglevel (jevois::manager::LogLevel) default=[info] List:[fatal|error|info]
    Set the minimum log level to display

  --help (bool) default=[false]
    Print this help message


Engine Options:  
  --usbserialdev (string) default=[]
    Over-the-USB serial device name, or empty

  --cameradev (string) default=[/dev/video0]
    Camera device name (if starting with /dev/v...), or movie file name (e.g., movie.mpg) or image sequence (e.g., im%02d.jpg, to read frames im00.jpg, im01.jpg, etc).

  --cameranbuf (unsigned int) default=[0]
    Number of video input (camera) buffers, or 0 for automatic.

  --serout (jevois::engine::SerPort) default=[None] List:[None|All|Hard|USB]
    Send module serial messages to selected serial port(s)

  --cpumax (unsigned int) default=[1344] List:[120|240|312|408|480|504|600|648|720|816|912|1008|1044|1056|1080|1104|1116|1152|1200|1224|1248|1296|1344]
    CPU maximum frequency in MHz

  --videomapping (int) default=[-1]
    Index of Video Mapping to use, or -1 to use the default mapping

  --camreg (bool) default=[false]
    Enable raw access to camera registers through setcamreg and getcamreg

  --cpumode (jevois::engine::CPUmode) default=[Performance] List:[PowerSave|Conservative|OnDemand|Interactive|Performance]
    CPU frequency modulation mode

  --gadgetdev (string) default=[]
    Gadget device name. This is used on platform hardware only. On host hardware, a display window will be used unless gadgetdev is None (useful for benchmarking) or is a file stem for a movie file that does not start with /dev/ (and which should contain a printf-style directive for a single int argument, the movie number).

  --camturbo (bool) default=[false]
    Enable camera turbo mode by relaxing the need for DMA-coherent video buffer memory. This can accelerate severalfolds access to the captured image data, but it may also yield stripe artifacts with some modules, such as PassThrough. The stripes are pieces of incorrect data in the cache. You should experiment with each particular module. Turbo mode is not recommended for any production-grade application.

  --gadgetnbuf (unsigned int) default=[0]
    Number of video output (USB video) buffers, or 0 for auto

  --serlog (jevois::engine::SerPort) default=[None] List:[None|All|Hard|USB]
    Show log and debug messages on selected serial port(s)

  --serialdev (string) default=[stdio]
    Hardware (4-pin connector) serial device name, or &apos;stdio&apos; to use the console, or empty for no hardware serial port</computeroutput></literallayout></para>
</section>
<section xml:id="_JeVoisDaemon_1autotoc_md41">
<title>jevois-daemon 配置文件</title>

<para><note><title>Note</title>

<para>对于，将下面的 <emphasis role="bold">/jevois/</emphasis> 替换为 <emphasis role="bold">/jevoispro/</emphasis> </para>
</note>
jevois-daemon 使用多个配置文件，源位于 <emphasis role="bold">jevois/Config/</emphasis> 并且它们安装到主机上的 <emphasis role="bold">/jevois/config/</emphasis> 和平台 microSD 上的 <emphasis role="bold">JEVOIS:/jevois/config/</emphasis> 中。</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">videomappings.cfg</emphasis> 可用视频映射列表，请参阅 <link linkend="_UserModes">视频模式和映射用户指南</link></para>
</listitem><listitem>
<para><emphasis role="bold">params.cfg</emphasis> 启动时设置的参数，这相当于从命令行指定这些参数</para>
</listitem><listitem>
<para><emphasis role="bold">initscript.cfg</emphasis> 在启动时运行的脚本，您可以在此文件中放入任何有效的命令，就像您以交互方式输入它们一样，有关更多信息，请参阅 <link linkend="_UserCli">命令行界面用户指南</link> 。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_JeVoisDaemon.dox_1autotoc_md42">
<title>在 JeVois-A33 平台上运行 jevois-daemon</title>

<para><computeroutput>jevois-daemon</computeroutput> 在平台上自动启动。启动它的脚本安装在 microSD 上的 <emphasis role="bold">LINUX:/usr/bin/jevois.sh</emphasis> 中。它的源代码位于 <emphasis role="bold">jevois/bin/jevois.sh</emphasis> 中，并作为 rebuild-platform.sh 过程的一部分安装到 microSD 暂存区。</para>

<para>您可以编辑此脚本，例如，如果您希望在 <computeroutput>gdb</computeroutput> 调试器中运行 jevois-daemon，只需替换该行</para>

<para><literallayout><computeroutput>/usr/bin/jevois-daemon ${opts}
</computeroutput></literallayout></para>

<para>by</para>

<para><literallayout><computeroutput>gdb --args /usr/bin/jevois-daemon ${opts}
</computeroutput></literallayout></para>

<para>请注意，自从 添加了 Python 支持后，<computeroutput>jevois-daemon</computeroutput> 启动时会引入 libcrypto，这会导致平台上的 gdb 出现问题。因此，当 gdb 在平台上启动时，发出</para>

<para><literallayout><computeroutput>handle SIGILL nostop noprint
</computeroutput></literallayout></para>

<para>在向 gdb 发出 <computeroutput>run</computeroutput> 命令之前。请参阅 <link xlink:href="https://www.raspberrypi.org/forums/viewtopic.php?p=155085">https://www.raspberrypi.org/forums/viewtopic.php?p=155085</link> 以了解 Raspberry Pi 上报告的相同问题。</para>

<para>您可以启用核心转储，正常运行 jevois-daemon 直到它崩溃，然后使用 gdb 在核心文件中查找错误，而不是在 gdb 中运行（有时它会在处理许多线程等时遇到困难）：</para>

<para><literallayout><computeroutput>ulimit -c unlimited # enable core dumps
jevois.sh # get to the part that crashes and it will quit, dumping a file named &apos;core&apos;
gdb /usr/bin/jevois-daemon core
# press return a few times until you get a prompt
bt # to show the backtrace leading to the crash
quit
</computeroutput></literallayout></para>
</section>
<section xml:id="_JeVoisDaemon_1autotoc_md43">
<title>在 JeVois-Pro 平台上运行 jevois-daemon</title>

<para><computeroutput>jevoispro-daemon</computeroutput> 在平台上自动启动。启动它的脚本安装在 microSD 上的 <emphasis role="bold">LINUX:/usr/bin/jevoispro.sh</emphasis> 中。它的源代码位于 <emphasis role="bold">jevois/bin/jevoispro.sh</emphasis> 中，并作为 <emphasis role="bold">jevois</emphasis> 包的 rebuild-platform-pdeb.sh 过程的一部分安装到 microSD 中。</para>

<para>要调试硬崩溃，请按以下步骤操作：启动控制台，启用核心转储，正常运行 jevoispro-daemon 直到它崩溃，然后使用 gdb 在核心文件中查找错误：</para>

<para>首先，按照 <link linkend="_ProUserQuick">JeVois-Pro 快速入门用户指南</link> 中的说明切换到控制台启动</para>

<para>然后重新启动并以 root / jevois 身份登录，然后：</para>

<para><literallayout><computeroutput>ulimit -c unlimited # enable core dumps
jevoispro.sh # get to the part that crashes and it will quit, dumping a file named &apos;core&apos;
gdb /usr/bin/jevoispro-daemon core
# press return a few times until you get a prompt
bt # to show the backtrace leading to the crash
quit
</computeroutput></literallayout> </para>
</section>
    <section xml:id="_FlashingToSD"><title>刷入 microSD 卡</title>    </section>
<para>因为 运行完整的 Ubuntu 操作系统，并带有 Debian 包管理器，所以重新刷新 microSD 应该非常容易，并且只有在它严重损坏时才需要这样做。</para>

<para>在 上，重新刷新更为常见，因为这是更新核心软件的唯一方法，因为 操作系统是准系统并且没有包管理器。</para>
<section xml:id="_FlashingToSD_1autotoc_md32">
<title>JeVois-Pro 流程</title>

<para><itemizedlist>
<listitem>
<para>如果您只需要安装软件包，例如 <emphasis role="bold">jevois</emphasis> 和 <emphasis role="bold">jevoisbase</emphasis> 的定制版本，请按照 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> 和 <link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link> 末尾的说明进行操作</para>
</listitem><listitem>
<para>如果您的 microSD 严重损坏，请从 <link xlink:href="http://jevois.org/start/software.html">http://jevois.org/start/software.html</link> 下载 microSD 映像或按照 ProgrammerSource（上一节）中的说明从源代码构建一个。</para>
</listitem><listitem>
<para>然后按照 <link linkend="_NewMicroSD">如何为 JeVois 格式化新的 MicroSD 卡</link> 中的说明进行操作</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_FlashingToSD_1autotoc_md33">
<title>JeVois-A33 流程</title>

<para>当您在 <emphasis role="bold">jevois</emphasis> 和 <emphasis role="bold">jevoisbase</emphasis> 中运行 <computeroutput>./rebuild-platform.sh</computeroutput> 时，编译后的文件将安装到暂存区（参见 ProgrammerOrganization）。</para>

<para>在 JeVois 智能相机上运行它们的最后一步是将整个 Linux 操作系统、内核、JeVois 框架（包括 <computeroutput>jevois-daemon）和</computeroutput> jevoisbase 模块刷入 microSD。</para>

<para>为此，运行</para>

<para><literallayout><computeroutput>jevois-flash-card
</computeroutput></literallayout></para>

<para>并以交互方式回答问题。</para>

<para>当您安装 JeVois Ubuntu 软件包或运行 <computeroutput>jevois-build.sh</computeroutput> 从源代码重建整个 buildroot 时，<computeroutput>jevois-flash-card</computeroutput> 会安装在 <emphasis role="bold">/usr/bin/</emphasis> 中。其源代码位于 <emphasis role="bold">jevois-sdk/jevois-build/jevois-flash-card</emphasis> 中。</para>

<para>一旦你这样做了几次，并且确信自己知道自己在做什么，你可以指示 <computeroutput>jevois-flash-card</computeroutput> 不要询问任何问题。只要绝对确定你为你的 SD 卡使用了正确的设备，这样你就不会因为一个小打字错误而毁掉你的主硬盘：</para>

<para><literallayout><computeroutput>jevois-flash-card -y /dev/sdX
</computeroutput></literallayout></para>

<para>其中，您将 <emphasis role="bold">/dev/sdX</emphasis> 替换为分配给 microSD 卡的设备。在某些笔记本电脑上，该设备被称为 <emphasis role="bold">/dev/mmcblkX。</emphasis> </para>

<para><note><title>Note</title>

<para>如果您进行大量需要重新刷新的开发（例如，为 JeVois 开发内核代码），那么投资购买超快 microSD 卡可能是值得的。虽然使用普通的 10 级 microSD 卡运行 jevois-flash-card 可能需要大约 5 分钟，但我们已经能够使用 1800x、1900x 或 V30、V60 或 V90 UHS-II microSD 卡将此时间缩短到 40 秒以内。</para>
</note>
</para>
<section xml:id="_FlashingToSD_1autotoc_md34">
<title>更新一些代码后重新刷新-完全重新编译</title>

<para><literallayout><computeroutput>cd ~/jevois &amp;&amp; ./rebuild-platform.sh
cd ~/jevoisbase &amp;&amp; ./rebuild-platform.sh
cd ~/mymodule &amp;&amp; ./rebuild-platform.sh     # optional: for your own modules
jevois-flash-card -y /dev/sdX
</computeroutput></literallayout></para>
</section>
<section xml:id="_FlashingToSD_1autotoc_md35">
<title>部分代码更新后重新刷新</title>

<para><literallayout><computeroutput>cd ~/jevois/pbuild &amp;&amp; make -j
cd ~/jevoisbase/pbuild &amp;&amp; make -j
cd ~/mymodule &amp;&amp; make -j     # optional: for your own modules
jevois-flash-card -y /dev/sdX
</computeroutput></literallayout></para>
</section>
<section xml:id="_FlashingToSD_1autotoc_md36">
<title>从 github 提取最新版本并重新刷新 - 完全重新编译</title>

<para><literallayout><computeroutput>cd ~/jevois &amp;&amp; git pull &amp;&amp; ./rebuild-platform.sh
cd ~/jevoisbase &amp;&amp; git pull &amp;&amp; ./rebuild-platform.sh
cd ~/mymodule &amp;&amp; ./rebuild-platform.sh     # optional: for your own modules
jevois-flash-card -y /dev/sdX
</computeroutput></literallayout></para>
</section>
<section xml:id="_FlashingToSD_1autotoc_md37">
<title>从 github 拉取最新版本并重新刷新 - 部分重新编译</title>

<para><literallayout><computeroutput>cd ~/jevois &amp;&amp; git pull &amp;&amp; cd pbuild &amp;&amp; make -j
cd ~/jevoisbase &amp;&amp; git pull &amp;&amp; cd pbuild &amp;&amp; make -j
cd ~/mymodule/pbuild &amp;&amp; make -j     # optional: for your own modules
jevois-flash-card -y /dev/sdX
</computeroutput></literallayout> </para>
</section>
</section>
    <section xml:id="_ProgrammerSDK"><title>程序员 SDK 和编写新模块</title>    </section>
<para>JeVois 程序员软件开发工具包 (SDK) 允许您为 JeVois 创建自己的机器视觉模块。SDK 非常复杂，因为它不仅包含 JeVois 核心软件，还包含 JeVois 相机的自定义 Linux 内核，以及 JeVois 相机内运行的完整 Linux 操作系统和实用程序集。</para>
<section xml:id="_ProgrammerSDK_1autotoc_md89">
<title>开始使用 JeVois 程序员 SDK</title>

<para>要开始使用程序员 SDK，可以安装预编译的 deb 包，也可以从源代码构建，详情请参阅 <link linkend="_ProgrammerSource">JeVois Ubuntu 软件包和源代码存储库</link></para>
</section>
<section xml:id="_ProgrammerSDK_1autotoc_md90">
<title>编写新模块：单个独立模块</title>

<para>已在 <emphasis role="bold">/usr/bin</emphasis> 中创建脚本 <computeroutput>jevois-create-module</computeroutput> （源位于 <emphasis role="bold">~/jevois/scripts/</emphasis> ）以自动执行创建新模块的过程。它基本上克隆了 <link xlink:href="https://github.com/jevois/samplemodule">https://github.com/jevois/samplemodule</link> 并将其中的一些名称更改为您提供的新名称：</para>

<para><literallayout><computeroutput># USAGE: jevois-create-module &lt;VendorName&gt; &lt;ModuleName&gt;
# 创建一个名为 tolower（ModuleName）的项目目录并填充它：

jevois-create-module MyVendor MyAlgo

# Module is setup in myalgo/
</computeroutput></literallayout></para>

<para>现在编辑您的模块以实际做一些有趣的事情，并更新模块内联文档中的所有自定义 doxygen 标签，例如 @videomapping 等等（有关自定义 doxygen 标签的更多信息请参阅下文）。</para>

<para>还请检查 <emphasis role="bold">icon.png</emphasis> 和源代码所在目录中的其他文件，并根据需要更新它们。</para>

<para>然后你可以使用</para>

<para><literallayout><computeroutput>./rebuild-host.sh
./rebuild-platform.sh
./rebuild-pro-host.sh
./rebuild-pro-platform-pdeb.sh
</computeroutput></literallayout></para>

<para>就像你对 jevois 和 jevoisbase 所做的那样。</para>

<para><note><title>Note</title>

<para>如果您收到错误 <emphasis role="bold">cc1plus: fatal error: jevois/Config/Config.H: No such file or directory</emphasis>，只需在您的 <emphasis role="bold">jevois</emphasis> 存储库中运行 <computeroutput>rebuild-platform.sh</computeroutput> 。请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link></para>
</note>
</para>
<section xml:id="_ProgrammerSDK_1autotoc_md91">
<title>JeVois-Pro：在相机上安装模块</title>

<para>运行 <computeroutput>./rebuild-pro-platform-pdeb.sh</computeroutput> 后，将在 ppdbuild/ 中创建一个 .deb 文件</para>

<para><itemizedlist>
<listitem>
<para>将其复制到您的 microSD。</para>
</listitem><listitem>
<para>使用其中的 microSD 启动相机。</para>
</listitem><listitem>
<para>在 JeVois-Pro 控制台中，输入 <computeroutput>shell dpkg -i /path/to/your-module-package.deb</computeroutput>。如果您已经安装了以前的版本，请先运行 <computeroutput>shell dpkg -r your-module-package</computeroutput> 以将其删除。</para>
</listitem><listitem>
<para>在 Config 选项卡中，编辑 videomappings.cfg 以添加模块的新映射。保存文件。</para>
</listitem><listitem>
<para>您的模块现在应该出现在可用模块菜单下，您可以选择它并运行它。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerSDK_1autotoc_md92">
<title>JeVois-A33：将您的模块添加到 microSD 卡：jvpkg</title>

<para><computeroutput>rebuild-platform.sh</computeroutput> 创建了一个 JeVois 包文件（它只是一个 zip）：</para>

<para><literallayout><computeroutput>myalgo/MyVendor_MyAlgo.jvpkg
</computeroutput></literallayout></para>

<para>将正确安装的 JeVois MicroSD（按照 <link xlink:href="http://jevois.org/start">JeVois Start</link> 中的步骤从磁盘映像制作一个）插入您的计算机，然后将 .jvpkg 文件复制到您的 microSD 的 JEVOIS:/packages/ 目录中。</para>

<para>您的智能相机将在下次启动时解压、配置并删除.jvpkg 文件。</para>

<para>确保留出足够的时间来完成这项工作。这可能需要几分钟（取决于模块的文件大小、microSD 卡速度等）。</para>

<para>还要记住编辑 microSD 的 JEVOIS 分区中的 config/videomappings.cfg，以添加将使用您的模块的新映射。</para>

<para>了解更多信息：</para>

<para><itemizedlist>
<listitem>
<para>jvpkg 软件包由 <computeroutput>/usr/bin/jevois-jvpkg</computeroutput>（源在 <computeroutput>~/jevois/scripts/jevois-jvpkg</computeroutput>）创建，由 <computeroutput>make jvpkg</computeroutput> 调用</para>
</listitem><listitem>
<para>并在平台启动时由运行的 <computeroutput>/usr/bin/jevois.sh</computeroutput>（源在 <computeroutput>~/jevois/bin/jevois.sh</computeroutput>）解压。</para>
</listitem></itemizedlist>
</para>
</section>
</section>
<section xml:id="_ProgrammerSDK_1autotoc_md93">
<title>模块文档和元数据</title>

<para>一个非常讨厌的 perl 脚本 <computeroutput>/usr/bin/jevois-modinfo</computeroutput> （源代码位于 <computeroutput>~/jevois/scripts/jevois-modinfo</computeroutput> ）将解析您的模块并为其生成单页文档。这个脚本很乱，而且操作相当脆弱。它会在您编译模块时自动调用（请参阅 <emphasis role="bold">~/jevois/CMakeModules/JeVois</emphasis>.cmake 中的规则）。</para>

<para>该脚本通过解析其目录中的模块和其他文件来创建 modinfo.html（和 modinfo.yaml，当前未使用）。</para>

<para>模块文档中的特殊 doxygen 标签将被解析，以下是一些示例：</para>

<para><itemizedlist>
<listitem>
<para>@author 示例作者</para>
</listitem><listitem>
<para>@displayname My Algo（仅当您想显示与类名不同的名称时才需要）</para>
</listitem><listitem>
<para>@videomapping YUYV 640 480 28.5 YUYV 640 480 28.5 SampleVendor SampleModule</para>
</listitem><listitem>
<para>@modulecommand mycommand - 模块特定命令的描述</para>
</listitem><listitem>
<para>@youtubevideo AbcDe567 - 指向 YouTube 视频的链接，将与屏幕截图一起显示在文档中</para>
</listitem><listitem>
<para>@email sampleemail@samplecompany.com</para>
</listitem><listitem>
<para>@address 123 First Street, Los Angeles, CA 90012</para>
</listitem><listitem>
<para>@copyright 版权所有 (C) 2017 by Sample Author</para>
</listitem><listitem>
<para>@mainurl <link xlink:href="http://samplecompany.com">http://samplecompany.com</link></para>
</listitem><listitem>
<para>@supporturl <link xlink:href="http://samplecompany.com/support">http://samplecompany.com/support</link></para>
</listitem><listitem>
<para>@otherurl <link xlink:href="http://samplecompany.com/about">http://samplecompany.com/about</link></para>
</listitem><listitem>
<para>@license GPL v3</para>
</listitem><listitem>
<para>@distribution 不受限制</para>
</listitem><listitem>
<para>@restrictions 无</para>
</listitem></itemizedlist>
</para>

<para>如果存在特殊命名的文件，也将使用它：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">icon.png</emphasis> （或任何其他扩展名，如 .jpg 等）：模块的图标。</para>
</listitem><listitem>
<para><emphasis role="bold">screenshot*</emphasis>.* ：屏幕截图，将按照 <computeroutput>ls</computeroutput> 列出的顺序出现在文档中。</para>
</listitem><listitem>
<para><emphasis role="bold">video*</emphasis>.* ：演示视频，将按照 <computeroutput>ls</computeroutput> 列出的顺序出现在文档中。</para>
</listitem><listitem>
<para><emphasis role="bold">postinstall</emphasis> ：模块解压后将执行的脚本。您可以在此脚本中使用该命令<computeroutput>jevois-add-videomapping</computeroutput> （安装在 <emphasis role="bold">/usr/bin/</emphasis> 中，源位于 <emphasis role="bold">~/jevois/src/Apps/</emphasis> 中）将模块安装时应安装的任何视频映射添加到 <emphasis role="bold">videomappings.cfg</emphasis> 文件中。这通常是使用 doxygen 标签在文档中列出的所有映射的子集。</para>
</listitem><listitem>
<para><emphasis role="bold">params.cfg</emphasis> ：模块加载时应设置的参数值。这些是在模块初始化之前设置的。</para>
</listitem><listitem>
<para><emphasis role="bold">script.cfg</emphasis> ：jevois 命令行界面命令脚本，应在模块加载时运行。此脚本在模块初始化后运行。</para>
</listitem><listitem>
<para><emphasis role="bold">jvpkg-exclude.cfg</emphasis> ：不应包含在 jvpkg 包中的文件列表。格式与 <computeroutput>tar --exclude-from</computeroutput> 相同</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerSDK_1autotoc_md94">
<title>部分编译</title>

<para>脚本 <computeroutput>rebuild-host.sh</computeroutput> 和 <computeroutput>rebuild-platform.sh</computeroutput> 清除并重新编译所有内容。</para>

<para>您应该至少运行它们一次。</para>

<para>然后，如果您只是更改几个文件，那么您只需重新编译所需的文件即可，如下所示：</para>

<para><itemizedlist>
<listitem>
<para>: for host <literallayout><computeroutput>cd hbuild
make -j
sudo make install
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <literallayout><computeroutput>cd pbuild
make -j
sudo make install
make jvpkg
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for host <literallayout><computeroutput>cd phbuild
make -j
sudo make install
make doc     # optional; if desired
</computeroutput></literallayout></para>
</listitem><listitem>
<para>: for platform <literallayout><computeroutput>cd ppdbuild
make -j
sudo make install
sudo cpack # will re-generate the deb package into ppdbuild/
</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerSDK_1autotoc_md95">
<title>编写新模块：具有共享组件的集合</title>

<para>在这种更复杂的场景中，您希望创建一个模块集合，并且一些组件算法将由几个模块共享。</para>

<para>然后，首选方法是将共享算法编写为 jevois 组件对象，并将它们全部编译成共享库 (.so)。然后，使用某些组件的每个模块都会自动触发共享库的加载。这是 <emphasis role="bold">jevoisbase</emphasis> 中采用的方法</para>

<para>有关这方面的指导，请检查 <emphasis role="bold">jevoisbase</emphasis> 中的 <emphasis role="bold">CMakeLists.txt。</emphasis> </para>

<para>请注意，已定义了几个 CMake 宏来帮助您；它们位于 <emphasis role="bold">jevois/CMakeModules/JeVois.cmake</emphasis> 中</para>

<para>在 jevoisbase 中，我们将 <emphasis role="bold">src/Components</emphasis> 下的所有内容编译为 <emphasis role="bold">libjevoisbase.so</emphasis> </para>

<para>然后，我们将 <emphasis role="bold">src/Modules</emphasis> 下的每个模块编译成一个 <emphasis role="bold"></emphasis>.so 文件，该文件被标记为依赖于 <emphasis role="bold">libjevoisbase.so</emphasis> </para>

<para>要创建自己的 <emphasis role="bold">jevoisbase</emphasis> <emphasis role="bold">CMakeLists.txt</emphasis> ，大约需要保留并修改 <emphasis role="bold">jevoisbase</emphasis> <emphasis role="bold">CMakeLists.txt</emphasis> 的前 50 行以适应您的项目。<emphasis role="bold">jevoisbase</emphasis> <emphasis role="bold">CMakeLists.txt</emphasis> 的其余部分基本上是添加所需的依赖项，例如 ZBar 库、OpenCV 库等，这些将因您的特定项目而异。 </para>
</section>
    <section xml:id="_ModuleTutorial"><title>关于如何为 JeVois 编写新的机器视觉模块的教程</title>    </section><section xml:id="_ModuleTutorial_1overview">
<title>概述</title>

<para>机器视觉 C++ 模块被编程为从 <link linkend="_classjevois_1_1Module">jevois::Module</link> 派生的单个类，它指定了基本接口。</para>

<para>作为初步（略微过于简化）的想法，JeVois 视觉模块的整体工作流程是它们实现一个处理功能，该功能将接收由相机传感器捕获的图像，以及将通过 USB 发送到主机的预分配输出图像。处理功能的任务是使用处理输入图像的结果填充输出图像。</para>

<para>在本教程中，我们首先向您展示如何编写几个非常简单的模块，以引入必要的概念。在本教程的最后，我们将为您指出进一步的详细阅读内容。</para>

<para>：以下教程创建在 JeVois-Pro 上以 &quot;legacy mode&quot; 运行的模块，即模块接收一个图像作为输入并输出包含处理结果的新图像。有关使用 /jvpro 的新 &quot;Pro/GUI&quot; 模式的模块的示例，请查看 jevoisbase 中许多示例的源代码：<link linkend="_UserDemos">捆绑视觉模块和演示的用户指南</link></para>

<para>在开始之前，您应该了解 <link linkend="_Concepts">本文档中使用的概念</link> 。</para>
<section xml:id="_ModuleTutorial.dox_1映射像素格式和视频映射">
<title>映射像素格式和视频映射</title>

<para>提醒一下，JeVois 智能相机可以捕捉以下相机像素格式的图像：YUYV、BAYER 或 RGB565。这些格式是相机传感器芯片支持的格式。</para>

<para>JeVois 可以向通过 USB 连接的主机发送更广泛的像素格式：YUYV、GREY、MJPG、BAYER、RGB565 和 BGR24。</para>

<para>有关这些格式的解释，请参阅 <link linkend="_UserModes">视频模式和映射用户指南</link> 了解详情。</para>
</section>
<section xml:id="_ModuleTutorial.dox_1videomappings">
<title>摄像头到 USB 视频映射</title>

<para>当主机通过 上的 USB 或 上的用户选择特定图像分辨率和像素格式时，将调用模块。视频映射列表将给定的输出分辨率和像素类型与应使用的相应相机分辨率和像素类型以及应调用的机器视觉模块关联起来。有关详细信息，请参见 <link linkend="_UserModes">视频模式和映射用户指南</link> 。</para>

<para>由于输出视频格式由 上的主机或 上的用户选择，因此不可协商。如果在 <emphasis role="bold">videomappings.cfg</emphasis> 中指定了调用特定机器视觉模块的视频映射，则该模块必须执行（或抛出异常）并处理从相机接收的图像以生成所需的输出图像。</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
</section>
<section xml:id="_ModuleTutorial_1getstarted">
<title>入门：pass-through 模块</title>

<para>让我们编写一个 pass-through 模块：该模块只是将从相机接收的图像中的像素数据复制到将通过 USB 发送的图像中。因此，直通模块使您的 JeVois 智能相机表现得像普通的 USB 相机。</para>

<para>以下是完整、有效的代码。我们将逐步介绍它：</para>

<para><literallayout><computeroutput>1 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_Module_8H">jevois/Core/Module.H</link>&gt;</emphasis>
2 
3 <emphasis role="comment">//&#32;Simple&#32;module&#32;that&#32;just&#32;passes&#32;the&#32;captured&#32;camera&#32;frames&#32;through&#32;to&#32;USB&#32;host</emphasis>
4 <emphasis role="keyword">class&#32;</emphasis>TutorialPassThrough&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_classjevois_1_1Module">jevois::Module</link>
5 {
6 &#32;&#32;<emphasis role="keyword">public</emphasis>:
7 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Default&#32;base&#32;class&#32;constructor&#32;ok</emphasis>
8 &#32;&#32;&#32;&#32;<emphasis role="keyword">using</emphasis>&#32;<link linkend="_classjevois_1_1Component_1a21f639900c480510650969df9c74d17d">jevois::Module::Module</link>;
9 
10 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Virtual&#32;destructor&#32;for&#32;safe&#32;inheritance</emphasis>
11 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;~TutorialPassThrough()&#32;{&#32;}
12 
13 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Processing&#32;function</emphasis>
14 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_classjevois_1_1Module_1aeee04cc9f45ee39774e7f2ce6116059a">process</link>(<link linkend="_classjevois_1_1InputFrame">jevois::InputFrame</link>&#32;&amp;&amp;&#32;inframe,&#32;<link linkend="_classjevois_1_1OutputFrame">jevois::OutputFrame</link>&#32;&amp;&amp;&#32;outframe)<emphasis role="keyword">&#32;override</emphasis>
15 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
16 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;next&#32;available&#32;camera&#32;image:</emphasis>
17 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;<emphasis role="keyword">const</emphasis>&#32;inimg&#32;=&#32;inframe.get(<emphasis role="keyword">true</emphasis>);
18 &#32;&#32;&#32;&#32;&#32;&#32;
19 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;an&#32;image&#32;from&#32;our&#32;gadget&#32;driver&#32;into&#32;which&#32;we&#32;will&#32;put&#32;our&#32;results:</emphasis>
20 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;outimg&#32;=&#32;outframe.get();
21 
22 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Enforce&#32;that&#32;the&#32;input&#32;and&#32;output&#32;formats&#32;and&#32;image&#32;sizes&#32;match:</emphasis>
23 &#32;&#32;&#32;&#32;&#32;&#32;outimg.<link linkend="_classjevois_1_1RawImage_1aacde26c84586c08d1e913694670d2d8e">require</link>(<emphasis role="stringliteral">&quot;output&quot;</emphasis>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a8b04939022b754b9e375772d3f3ee85f">width</link>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1aaa1eeb6405c5c5fceea6d772b52474b5">height</link>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a0f74c21f145dd4ff5e3140b5632d67a2">fmt</link>);
24 &#32;&#32;&#32;&#32;&#32;&#32;
25 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Just&#32;copy&#32;the&#32;pixel&#32;data&#32;over:</emphasis>
26 &#32;&#32;&#32;&#32;&#32;&#32;memcpy(outimg.<link linkend="_classjevois_1_1RawImage_1ac2202ecd3324959d17c06a191624d2a6">pixelsw</link>&lt;<emphasis role="keywordtype">void</emphasis>&gt;(),&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a0afe5d7d00f4048ecbf6d5c908d98638">pixels</link>&lt;<emphasis role="keywordtype">void</emphasis>&gt;(),&#32;outimg.<link linkend="_classjevois_1_1RawImage_1a454ebfb26b63a7601ff66bf0ec96497e">bytesize</link>());
27 
28 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Let&#32;camera&#32;know&#32;we&#32;are&#32;done&#32;processing&#32;the&#32;input&#32;image:</emphasis>
29 &#32;&#32;&#32;&#32;&#32;&#32;inframe.done();&#32;<emphasis role="comment">//&#32;NOTE:&#32;optional&#32;here,&#32;inframe&#32;destructor&#32;would&#32;call&#32;it&#32;anyway</emphasis>
30 
31 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Send&#32;the&#32;output&#32;image&#32;with&#32;our&#32;processing&#32;results&#32;to&#32;the&#32;host&#32;over&#32;USB:</emphasis>
32 &#32;&#32;&#32;&#32;&#32;&#32;outframe.send();&#32;<emphasis role="comment">//&#32;NOTE:&#32;optional&#32;here,&#32;outframe&#32;destructor&#32;would&#32;call&#32;it&#32;anyway</emphasis>
33 &#32;&#32;&#32;&#32;}
34 };
35 
36 <emphasis role="comment">//&#32;Allow&#32;the&#32;module&#32;to&#32;be&#32;loaded&#32;as&#32;a&#32;shared&#32;object&#32;(.so)&#32;file:</emphasis>
37 <link linkend="_Module_8H_1a19a74668397740a2cd4813240e547179">JEVOIS_REGISTER_MODULE</link>(TutorialPassThrough);
</computeroutput></literallayout></para>

<para>解释：</para>

<para><itemizedlist>
<listitem>
<para>第 1 至 4 行：所有机器视觉模块都应源自 jevois::Module，它建立了 JeVois Engine 与您的模块协同工作的接口。</para>
</listitem><listitem>
<para>第 8 行：我们的模块在构造时不需要做任何事情，因此我们只需使用从基础 Module 类继承的构造函数，也就是说，我们在构造时所做的只是基类需要做的事情。有关继承构造函数的更多信息，请参阅 <link xlink:href="http://en.cppreference.com/w/cpp/language/using_declaration">http://en.cppreference.com/w/cpp/language/using_declaration</link>。</para>
</listitem><listitem>
<para>第 11 行：在派生类（如本模块）中声明并实现标记为 <computeroutput>virtual</computeroutput> 的析构函数是一种很好的做法。有关更多信息，请参阅 <link xlink:href="http://www.geeksforgeeks.org/g-fact-37/">http://www.geeksforgeeks.org/g-fact-37/</link>。</para>
</listitem><listitem>
<para>第 14 行，process() 的语法：当 JeVois Engine 加载为当前机器视觉模块时，它将在您的模块上调用 process() 函数。process() 的语法在 Module 基类中定义。我们建议使用 <computeroutput>override</computeroutput> 关键字，以便编译器为您检查您是否确实实现了 Engine 将使用的这个确切函数，而不是，如果您在第 14 行的 process 声明中输入了拼写错误，则只需声明一个语法略有不同的新函数（在这种情况下，Engine 不会调用此函数，您的模块也不会执行任何操作）。</para>
</listitem><listitem>
<para>第 14 行，InputFrame 和 OutputFrame：这两个类是辅助类，允许您的 process() 函数在需要时访问输入和输出图像。为了优化吞吐量和 JeVois 中的 CPU 使用率，我们在此采用与 std::future 类似的设计用于 InputFrame 和 OutputFrame：您可以将它们视为图像的句柄，这些图像可能可用也可能不可用，但肯定会在未来某个时间可用。在调用 process() 时，只会向您提供这些未来图像的句柄。如果您暂时不需要图像，并且首先想在 process() 函数中做一些初步设置，那么只需将这些句柄准备好以备将来使用。当您准备好使用其中一个图像时，只需在其句柄上调用 get()，这将返回实际图像。如果图像尚未准备好，例如，它仍在被相机传感器捕获，那么 get() 将阻塞，直到图像准备好供您使用。有关更多信息，请阅读并理解 C++11 中 Future 和 Promise 的概念。您可能想查看这个不错的教程： <link xlink:href="http://thispointer.com/c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/">http://thispointer.com/c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/</link> 或网络上的其他内容。</para>
</listitem><listitem>
<para>第 14 行，参数使用移动语义：您可能注意到了 InputFrame 和 OutputFrame 后面的 &amp;&amp; 符号。这意味着传递给 process() 的参数使用移动语义传递。这在这里并不重要，只是源于以下事实：由于 InputFrame 和 OutputFrame 直接连接到相机传感器和 USB 接口，因此我们禁止 Engine 以外的任何人创建它们。因此您无法构造 InputFrame，只有 Engine 可以。Engine 使用其对相机和 USB 接口的私有访问权限为您构造 InputFrame 和 OutputFrame。然后，它只需将构造的对象交给您的 process() 函数并忘记它们。有关移动语义的更多信息，您可以查看 <link xlink:href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</link> 或网络上的其他常规 C++11 教程。</para>
</listitem><listitem>
<para>第 17 行：在 pass-through 模块中，在获得输入和输出图像之前，我们无需执行任何操作。因此，我们只需在 inimg 上调用 get() 即可首先从相机获取图像。图像可能立即可用，或者 get() 可能会阻塞，直到可用为止。返回的 RawImage 是一种简约的数据结构，它基本上会告诉您图像的宽度、高度、像素类型，并允许您访问像素数组。它是一种轻量级结构，复制 RawImage 对象只会共享底层像素数组，而不是复制它。这与 OpenCV 的 cv::Mat 中的行为相同。</para>
</listitem><listitem>
<para>第 20 行：同样，在获得输出图像之前，我们无法在 pass-through 中执行任何操作，因此我们在这里只获取它，这可能会阻塞直到它可用。在更复杂的模块中，可以在一个线程中开始处理输入图像，同时在另一个线程中等待输出图像。我们稍后会研究这方面的例子。</para>
</listitem><listitem>
<para>第 23 行：视觉模块可以对输入和输出图像大小和像素格式强制执行一些要求。这是通过使用 RawImage 的 require() 函数实现的。对于直通，我们将支持任何输入图像尺寸和像素，但是，由于我们不会对像素数据进行任何处理，而只是将其复制到输出，因此我们必须强制输出图像尺寸和像素类型与输入的完全匹配。如果不满足要求，require() 函数只会抛出异常。引擎将捕获该异常，发出一些错误消息，安全地取消分配任何内存缓冲区，然后转到下一个视频帧。</para>
</listitem><listitem>
<para>第 26 行：现在我们准备使用输入图像中的像素数据填充输出图像的像素数组。请注意，输出图像的像素数组已由引擎（和 USB 驱动程序）分配。它是不可协商的，因为它是由连接到 JeVois 相机的主机设置的，并且由主机上的用户选择他们希望接收的视频分辨率和模式。不要尝试更改图像大小或格式，或重新分配 outimg 持有的像素数组。只需接受 outimg 的尺寸、像素类型和像素数组地址，然后将像素数据写入像素数组。请注意此处有关 RawImage 的一些详细信息：<itemizedlist>
<listitem>
<para>pixels&lt;type&gt;() 返回指向像素数组的只读指针，转换为所需类型</para>
</listitem><listitem>
<para>pixelsw&lt;type&gt;() 返回指向像素数组的读写指针，转换为所需类型</para>
</listitem><listitem>
<para>bytesize() 返回 pixel 数组的大小（以字节为单位）。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>第 29 行：现在我们已经处理完输入图像，我们可以通知相机了。相机使用一组固定的预分配（在 Linux 内核中）内存映射缓冲区，连接到相机传感器的 CPU 芯片中的硬件可以使用直接内存访问 (DMA) 直接写入其中。因此，一旦不再需要缓冲区，就立即释放它，这样相机就可以使用它来捕获未来的视频帧。</para>
</listitem><listitem>
<para>第 32 行：相同的缓冲逻辑适用于 USB 驱动程序。</para>
</listitem><listitem>
<para>第 37 行：此宏添加了一些普通的 C 语言钩子，允许模块在运行时从编译此模块获得的共享库 (.so) 文件中加载并实例化为 C++ 类。这是每个 JeVois 模块的必需语句。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
<section xml:id="_ModuleTutorial_1addopencv">
<title>添加一些图像处理：图像格式转换模块</title>

<para>现在让我们看看如何轻松使用 OpenCV 来实际处理从相机接收到的图像。我们在这里开发了一个简单的图像格式转换模块：它可以从相机传感器上可用的任何像素格式（YUYV、BAYER、RGB565）转换为 JeVois 向通过 USB 连接的主机公开的任何像素格式（YUYV、GREY、MJPG、BAYER、RGB565、BGR24）。</para>

<para>为了使此示例模块简单，我们将分两步使用图像转换函数：</para>

<para><itemizedlist>
<listitem>
<para>从相机图像格式转换为 BGR24，这是 OpenCV 中彩色图像的默认格式（每个像素的蓝色、绿色和红色通道各为 8 位）。事实上，JeVois 中使用的许多像素格式转换函数都是使用 OpenCV 实现的。</para>
</listitem><listitem>
<para>通过 USB 从 BGR24 转换为主机请求的格式。</para>
</listitem></itemizedlist>
</para>

<para>这并不总是进行这种转换的最有效方法（需要两次传递），但它避免了需要编写的格式转换函数数量的组合爆炸式增长，并且它在 JeVois 处理器上的运行速度足够快。</para>

<para><literallayout><computeroutput>1 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_Module_8H">jevois/Core/Module.H</link>&gt;</emphasis>
2 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_RawImageOps_8H">jevois/Image/RawImageOps.H</link>&gt;</emphasis>
3 <emphasis role="preprocessor">#include&#32;&lt;opencv2/core/core.hpp&gt;</emphasis>
4 <emphasis role="preprocessor">#include&#32;&lt;opencv2/imgproc/imgproc.hpp&gt;</emphasis>
5 
6 <emphasis role="comment">//&#32;Simple&#32;module&#32;to&#32;convert&#32;between&#32;any&#32;supported&#32;camera&#32;grab&#32;formats&#32;and&#32;USB&#32;output&#32;formats</emphasis>
7 <emphasis role="keyword">class&#32;</emphasis>TutorialConvert&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_classjevois_1_1Module">jevois::Module</link>
8 {
9 &#32;&#32;<emphasis role="keyword">public</emphasis>:
10 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Default&#32;base&#32;class&#32;constructor&#32;ok</emphasis>
11 &#32;&#32;&#32;&#32;<emphasis role="keyword">using</emphasis>&#32;<link linkend="_classjevois_1_1Component_1a21f639900c480510650969df9c74d17d">jevois::Module::Module</link>;
12 
13 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Virtual&#32;destructor&#32;for&#32;safe&#32;inheritance</emphasis>
14 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;~TutorialConvert()&#32;{&#32;}
15 
16 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Processing&#32;function</emphasis>
17 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_classjevois_1_1Module_1aeee04cc9f45ee39774e7f2ce6116059a">process</link>(<link linkend="_classjevois_1_1InputFrame">jevois::InputFrame</link>&#32;&amp;&amp;&#32;inframe,&#32;<link linkend="_classjevois_1_1OutputFrame">jevois::OutputFrame</link>&#32;&amp;&amp;&#32;outframe)<emphasis role="keyword">&#32;override</emphasis>
18 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
19 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;next&#32;available&#32;camera&#32;image:</emphasis>
20 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;inimg&#32;=&#32;inframe.get();
21 
22 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Convert&#32;it&#32;to&#32;BGR24:</emphasis>
23 &#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;imgbgr&#32;=&#32;<link linkend="_group__image_1ga6f005034f93fc03530498eae898f9b22">jevois::rawimage::convertToCvBGR</link>(inimg);
24 &#32;&#32;
25 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Let&#32;camera&#32;know&#32;we&#32;are&#32;done&#32;processing&#32;the&#32;input&#32;image:</emphasis>
26 &#32;&#32;&#32;&#32;&#32;&#32;inframe.done();
27 &#32;&#32;&#32;&#32;&#32;&#32;
28 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;an&#32;image&#32;from&#32;our&#32;gadget&#32;driver&#32;into&#32;which&#32;we&#32;will&#32;put&#32;our&#32;results:</emphasis>
29 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;outimg&#32;=&#32;outframe.get();
30 
31 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Require&#32;that&#32;output&#32;has&#32;same&#32;dims&#32;as&#32;input,&#32;allow&#32;any&#32;output&#32;format:</emphasis>
32 &#32;&#32;&#32;&#32;&#32;&#32;outimg.<link linkend="_classjevois_1_1RawImage_1aacde26c84586c08d1e913694670d2d8e">require</link>(<emphasis role="stringliteral">&quot;output&quot;</emphasis>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a8b04939022b754b9e375772d3f3ee85f">width</link>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1aaa1eeb6405c5c5fceea6d772b52474b5">height</link>,&#32;outimg.<link linkend="_classjevois_1_1RawImage_1a0f74c21f145dd4ff5e3140b5632d67a2">fmt</link>);
33 
34 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;TutorialConvert&#32;from&#32;BGR&#32;to&#32;desired&#32;output&#32;format:</emphasis>
35 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_group__image_1ga748b79664f7d9c00f2706e726276a09f">jevois::rawimage::convertCvBGRtoRawImage</link>(imgbgr,&#32;outimg);
36 &#32;&#32;&#32;&#32;&#32;&#32;
37 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Send&#32;the&#32;output&#32;image&#32;with&#32;our&#32;processing&#32;results&#32;to&#32;the&#32;host&#32;over&#32;USB:</emphasis>
38 &#32;&#32;&#32;&#32;&#32;&#32;outframe.send();
39 &#32;&#32;&#32;&#32;}
40 };
41 
42 <emphasis role="comment">//&#32;Allow&#32;the&#32;module&#32;to&#32;be&#32;loaded&#32;as&#32;a&#32;shared&#32;object&#32;(.so)&#32;file:</emphasis>
43 <link linkend="_Module_8H_1a19a74668397740a2cd4813240e547179">JEVOIS_REGISTER_MODULE</link>(TutorialConvert);
</computeroutput></literallayout></para>

<para>让我们关注一下新事物：</para>

<para><itemizedlist>
<listitem>
<para>第 23 行：JeVois 提供的 RawImage 类主要用作已在 Linux 内核中分配的像素缓冲区数据的智能指针。它不用于处理，但我们编写了一些函数来将简单的绘图（圆形、矩形、一些文本等）直接转换为将通过 USB 发送的原始图像。因此，当想要处理图像时，通常我们首先将其转换为 OpenCV 或其他图像格式，具体取决于我们想要实现的视觉算法。这种转换可以通过两种方式进行：<itemizedlist>
<listitem>
<para>零拷贝：如果可以直接使用相机的像素格式，那么 JeVois 提供的函数可以通过在两者之间共享像素数据，将 RawImage 重新解释为 OpenCV cv::Mat 图像。这里没有显示这种方法，但如果您可以直接使用相机的像素类型，则这是首选方法。</para>
</listitem><listitem>
<para>转换为不同的像素格式：如果还想要相机传感器芯片本身未提供的不同像素格式，则可以创建一个新的 OpenCV cv::Mat 图像，其像素阵列内存与源 RawImage 不同。然后，​​JeVois 提供了可以从任何相机像素格式转换为几种不同 OpenCV 像素格式的函数。在这里我们使用其中之一，convertToCvBGR()。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>第 26 行：一旦输入图像被转换为​​ OpenCV 中新分配的像素阵列（该阵列与原始输入图像的阵列分开），我们就不再需要原始输入图像，我们将继续仅使用 OpenCV 图像。因此，我们可以将与原始输入图像关联的内存缓冲区返回给相机，以便它可以使用它来捕获未来的视频帧。</para>
</listitem><listitem>
<para>第 29 行：我们已经完成了一半的工作（从相机格式到 BGR），但现在要继续进行第二部分（从 BGR 到 USB 主机请求的格式），我们需要准备好输出图像。因此我们在这里请求它，并且可能会等待它。</para>
</listitem><listitem>
<para>第 32 行：在这个简单的教程中，我们不允许对图像大小进行任何缩放。因此，我们要求输出分辨率应与输入分辨率相同。我们对输出像素类型没有要求，因此我们在这里只指定 <emphasis role="bold">outimg.fmt</emphasis> 作为所需的输出像素类型（也就是说，我们只是说，无论 USB 主机选择了哪种像素格式并且已经在输出图像中，我们都可以接受）。</para>
</listitem><listitem>
<para>第 35 行：现在我们使用 JeVois 框架中的一些辅助转换函数将 OpenCV BGR 图像转换为 USB 主机请求的格式。</para>
</listitem><listitem>
<para>第 38 行：我们已完成并准备通过 USB 将转换后的图像发送到主机。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
<section xml:id="_ModuleTutorial_1addparams">
<title>添加模块参数并使用 OpenCV：边缘检测模块</title>

<para>大多数机器视觉模块都提供参数，允许调整其操作。这些参数包括阈值、算法模式、精度设置等。</para>

<para>因此，许多框架（例如 OpenCV）大体上依赖于具有许多参数的函数。例如，在 OpenCV 中调用 Canny 边缘检测器的方式是调用以下函数：</para>

<para><literallayout><computeroutput>void&#32;Canny(InputArray&#32;image,&#32;OutputArray&#32;edges,&#32;double&#32;threshold1,&#32;double&#32;threshold2,&#32;int&#32;apertureSize&#32;=&#32;3,&#32;bool&#32;L2gradient&#32;=&#32;false)
</computeroutput></literallayout></para>

<para>除了可能对长列表中哪个值属于哪个参数产生混淆（Python 等语言通过允许按名称访问参数来解决）之外，这种方法的一个主要问题是，每个使用 Canny 的函数都必须为用户提供一种设置参数的机制（threshold1、threshold2 等），或者在大多数情况下，这些参数最终将被硬连线，从而限制最终应用程序对不同图像大小、环境类型等的适用性。</para>

<para>相比之下，在 JeVois 框架中，人们将创建一个 Canny Module，并使用 Parameter 设置阈值，其中 Parameter 是实际参数值的丰富包装器。JeVois 框架中的参数概念体现了对任何类型的单个值的包装器，以及相关文档（描述）、默认值、有效值的可能规范、用于获取或更改值的访问器函数以及在值更改时触发的可选回调函数。参数旨在用于从组件继承的对象（ Module 继承自 Component ，稍后将详细介绍 Component - 现在只需将 Component 等同于 Module ）。参数的目标是以某种方式公开给定视觉算法的参数，以便使用该算法的任何代码都会自动继承和公开这些参数。</para>

<para>参数设置可以通过使用具有参数的视觉算法的代码来完成，但更多时候，它留给用户。在特定的视觉管道中，可以在开始时为参数提供合理的默认值，然后将这些参数留给想要修改它们的最终用户访问。JeVois 中的参数修改是在应用程序启动时通过解析命令行参数来处理的，当实例化新的处理模块时，或者在运行时，通过与通过其串行端口管理系统的引擎交互来处理。</para>

<para>我们在 JeVois 框架中实现参数的方式乍一看似乎有些不合常规，但就编写具有大量参数的新算法时尽量减少负担而言，这是我们迄今为止发现的最佳方式。在我们早期的框架中，iLab 神经形态视觉工具包 (iNVT) 于 1995 年开始使用，参数作为成员变量包含在算法组件中。程序员的负担太重了，以至于他们通常不包含参数，而是硬连线值，只是为了避免这种负担。负担来自以下要求：</para>

<para><itemizedlist>
<listitem>
<para>我们希望能够支持任何类型的参数</para>
</listitem><listitem>
<para>我们希望每个参数都有名称、描述、默认值、有效值的规范</para>
</listitem><listitem>
<para>我们希望参数出现在帮助消息中的相关组中</para>
</listitem><listitem>
<para>我们希望支持回调，即在尝试更改参数值时调用的函数</para>
</listitem><listitem>
<para>我们希望回调是拥有给定参数的模块的成员函数，因为更改该参数值通常会触发该模块中的某种重新组织（否则可能不需要回调）。</para>
</listitem></itemizedlist>
</para>

<para>可以使用类数据成员作为参数的可能实现（类似于我们在 iNVT 中使用的），这里显示一个示例 <emphasis role="bold">int</emphasis> 参数来指定从 Module 派生的 MyModule 类中保存的队列的大小：</para>

<para><literallayout><computeroutput>ParamDef&lt;int&gt;&#32;sizeparamdef(&quot;size&quot;,&#32;&quot;Queue&#32;size&quot;,&#32;5,&#32;Range&lt;int&gt;(1,&#32;100));

class&#32;MyModule&#32;:&#32;public&#32;jevois::Module
{
&#32;&#32;public:
&#32;&#32;&#32;&#32;&#32;&#32;Param&lt;int&gt;&#32;sizeparam;&#32;//&#32;ouch

&#32;&#32;&#32;&#32;&#32;&#32;void&#32;sizeParamCallback(int&#32;newval)&#32;{&#32;myqueue.resize(newval);&#32;}

&#32;&#32;&#32;&#32;&#32;&#32;MyModule(std::string&#32;const&#32;&amp;&#32;instance)&#32;:&#32;jevois::Module(instance),
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sizeparam(sizeparamdef)&#32;&#32;//&#32;ouch
&#32;&#32;&#32;&#32;&#32;&#32;{
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sizeparam.setCallback(&amp;MyModule::sizeParamCallback);&#32;//&#32;ouch
&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;//&#32;我们无法在构造函数初始化列表中设置回调，因为&#32;MyModule&#32;当时尚未构造
&#32;&#32;&#32;&#32;&#32;&#32;}
};
</computeroutput></literallayout></para>

<para>因此，我们最终得到了 3 个名称，人们不知道该如何处理它们，只会使用令人困惑的名称（sizeparamdef、sizeparam、sizeParamCallback），并且我们必须 1) 使用某个任意名称（此处为 sizeparamdef）在某处指定名称、描述等的定义，然后使用其他名称（此处为 sizeparam）将 param 的成员变量添加到模块，然后构造 param，这通常需要将其链接到其定义，以便我们可以获得默认值等，最后挂接回调（请注意，当我们构造 sizeparam 时，MyComp 尚未完全构造，因此当时引用 sizeParamCallback() 充其量是可疑的）。实际上，情况甚至更糟，因为通常 paramdef、模块类声明和模块实现可能位于 3 个不同的文件中。</para>

<para>我们为神经形态机器人工具包 (NRT) 开发并针对 JeVois 改进的方法的工作原理如下：</para>

<para><itemizedlist>
<listitem>
<para>每个参数都是一个独特的新类类型。我们用一个名称创建该类型一次，它保存参数值和定义数据。JEVOIS_DECLARE_PARAMETER(ParamName, ParamType, ...) 可变宏进一步促进了这一点。</para>
</listitem><listitem>
<para>对于带有回调的参数，它们的类类型包括一个纯虚 onParamChange(param, value) 函数，该函数需要由 host 模块实现。JEVOIS_DECLARE_PARAMETER_WITH_CALLBACK(ParamName, ParamType, ...) 可变宏促进了这一点。onParamChange() 的第一个参数是参数类类型，因此具有许多参数的 host 模块将具有许多不同的 onParamChange() 函数，每参数个有一个回调。</para>
</listitem><listitem>
<para>模块使用可变参数模板从其参数继承，使得从多个参数继承变得简短而容易。</para>
</listitem><listitem>
<para>每个参数都公开简单函数 get()、set() 等（参见 ParameterCore 和 ParameterBase）。在具有许多参数的模块中，访问参数是通过消除想要在哪个基类（即哪个参数）上访问 get()、set() 等函数的歧义来实现的，这可以通过调用 param_x::get() 与 param_y::get() 等来实现</para>
</listitem><listitem>
<para>无需声明参数成员变量（而是从它们继承）。</para>
</listitem><listitem>
<para>无需在组件构造时执行任何操作。</para>
</listitem><listitem>
<para>无需手动将组件宿主类中的回调函数挂接到参数。</para>
</listitem><listitem>
<para>强大的编译时检查，确保程序员没有忘记为每个声明为具有回调的参数编写回调函数。</para>
</listitem><listitem>
<para>始终只使用一个名称来表示该参数及其所有相关机制（定义、回调）。</para>
</listitem><listitem>
<para>编写脚本以搜索源树以获取有关组件所有参数的信息非常容易，因为这些参数始终都在 Parameter&lt; ... &gt; 继承语句中指定。</para>
</listitem></itemizedlist>
</para>

<para>让我们深入研究并实现一个边缘检测模块，该模块使用 OpenCV 中的 Canny 函数并公开其参数，以便用户可以通过串行命令行界面使用它们：</para>

<para><literallayout><computeroutput>1 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_Module_8H">jevois/Core/Module.H</link>&gt;</emphasis>
2 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_RawImageOps_8H">jevois/Image/RawImageOps.H</link>&gt;</emphasis>
3 <emphasis role="preprocessor">#include&#32;&lt;opencv2/core/core.hpp&gt;</emphasis>
4 <emphasis role="preprocessor">#include&#32;&lt;opencv2/imgproc/imgproc.hpp&gt;</emphasis>
5 
6 <emphasis role="comment">//&#32;Parameters&#32;for&#32;our&#32;module:</emphasis>
7 <emphasis role="keyword">static</emphasis>&#32;<link linkend="_structjevois_1_1ParameterCategory">jevois::ParameterCategory</link>&#32;<emphasis role="keyword">const</emphasis>&#32;ParamCateg(<emphasis role="stringliteral">&quot;Edge&#32;Detection&#32;Options&quot;</emphasis>);
8 
9 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh1,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;First&#32;threshold&#32;for&#32;hysteresis&quot;</emphasis>,&#32;50.0,&#32;ParamCateg);
10 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh2,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;Second&#32;threshold&#32;for&#32;hysteresis&quot;</emphasis>,&#32;150.0,&#32;ParamCateg);
11 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(aperture,&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="stringliteral">&quot;Aperture&#32;size&#32;for&#32;the&#32;Sobel&#32;operator&quot;</emphasis>,&#32;3,&#32;<link linkend="_classjevois_1_1Range">jevois::Range&lt;int&gt;</link>(3,&#32;53),&#32;ParamCateg);
12 <link linkend="_classjevois_1_1Manager_1ac2decd6e1f0a9a1366b783e59b440d7f">JEVOIS_DECLARE_PARAMETER_WITH_CALLBACK</link>(l2grad,&#32;<emphasis role="keywordtype">bool</emphasis>,&#32;<emphasis role="stringliteral">&quot;Use&#32;more&#32;accurate&#32;L2&#32;gradient&#32;norm&#32;if&#32;true,&#32;L1&#32;if&#32;false&quot;</emphasis>,&#32;<emphasis role="keyword">false</emphasis>,&#32;ParamCateg);
13 
14 <emphasis role="comment">//&#32;Simple&#32;module&#32;to&#32;detect&#32;edges&#32;using&#32;the&#32;Canny&#32;algorithm&#32;from&#32;OpenCV</emphasis>
15 <emphasis role="keyword">class&#32;</emphasis>TutorialEdgeDetection&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_classjevois_1_1Module">jevois::Module</link>,
16 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;jevois::Parameter&lt;thresh1,&#32;thresh2,&#32;aperture,&#32;l2grad&gt;
17 {
18 &#32;&#32;<emphasis role="keyword">public</emphasis>:
19 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Default&#32;base&#32;class&#32;constructor&#32;ok</emphasis>
20 &#32;&#32;&#32;&#32;<emphasis role="keyword">using</emphasis>&#32;<link linkend="_classjevois_1_1Component_1a21f639900c480510650969df9c74d17d">jevois::Module::Module</link>;
21 
22 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Virtual&#32;destructor&#32;for&#32;safe&#32;inheritance</emphasis>
23 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;~TutorialEdgeDetection()&#32;{&#32;}
24 
25 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Processing&#32;function</emphasis>
26 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_classjevois_1_1Module_1aeee04cc9f45ee39774e7f2ce6116059a">process</link>(<link linkend="_classjevois_1_1InputFrame">jevois::InputFrame</link>&#32;&amp;&amp;&#32;inframe,&#32;<link linkend="_classjevois_1_1OutputFrame">jevois::OutputFrame</link>&#32;&amp;&amp;&#32;outframe)<emphasis role="keyword">&#32;override</emphasis>
27 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
28 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;next&#32;available&#32;camera&#32;image:</emphasis>
29 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;inimg&#32;=&#32;inframe.get();
30 
31 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Convert&#32;to&#32;OpenCV&#32;grayscale:</emphasis>
32 &#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;grayimg&#32;=&#32;<link linkend="_namespacejevois_1_1rawimage_1a28053035013862dd0dd48c4601216655">jevois::rawimage::convertToCvGray</link>(inimg);
33 &#32;&#32;
34 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Let&#32;camera&#32;know&#32;we&#32;are&#32;done&#32;processing&#32;the&#32;input&#32;image:</emphasis>
35 &#32;&#32;&#32;&#32;&#32;&#32;inframe.done();
36 
37 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;an&#32;image&#32;from&#32;our&#32;gadget&#32;driver&#32;into&#32;which&#32;we&#32;will&#32;put&#32;our&#32;results.&#32;Require&#32;that&#32;it&#32;must&#32;have&#32;same</emphasis>
38 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;image&#32;size&#32;as&#32;the&#32;input&#32;image,&#32;and&#32;greyscale&#32;pixels:</emphasis>
39 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;outimg&#32;=&#32;outframe.get();
40 &#32;&#32;&#32;&#32;&#32;&#32;outimg.<link linkend="_classjevois_1_1RawImage_1aacde26c84586c08d1e913694670d2d8e">require</link>(<emphasis role="stringliteral">&quot;output&quot;</emphasis>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a8b04939022b754b9e375772d3f3ee85f">width</link>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1aaa1eeb6405c5c5fceea6d772b52474b5">height</link>,&#32;V4L2_PIX_FMT_GREY);
41 
42 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Compute&#32;Canny&#32;edges&#32;directly&#32;into&#32;the&#32;output&#32;image:</emphasis>
43 &#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;edges&#32;=&#32;<link linkend="_group__image_1ga20c3651602d9b2d003988b9bcd674f03">jevois::rawimage::cvImage</link>(outimg);&#32;<emphasis role="comment">//&#32;Pixel&#32;data&#32;of&#32;&quot;edges&quot;&#32;shared&#32;with&#32;&quot;outimg&quot;,&#32;no&#32;copy</emphasis>
44 &#32;&#32;&#32;&#32;&#32;&#32;cv::Canny(grayimg,&#32;edges,&#32;thresh1::get(),&#32;thresh2::get(),&#32;aperture::get(),&#32;l2grad::get());
45 &#32;&#32;&#32;&#32;&#32;&#32;
46 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Send&#32;the&#32;output&#32;image&#32;with&#32;our&#32;processing&#32;results&#32;to&#32;the&#32;host&#32;over&#32;USB:</emphasis>
47 &#32;&#32;&#32;&#32;&#32;&#32;outframe.send();
48 &#32;&#32;&#32;&#32;}
49 
50 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Callback&#32;function&#32;for&#32;parameter&#32;l2grad</emphasis>
51 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;onParamChange(l2grad&#32;<emphasis role="keyword">const</emphasis>&#32;&amp;&#32;param,&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<emphasis role="keyword">const</emphasis>&#32;&amp;&#32;newval)<emphasis role="keyword">&#32;override</emphasis>
52 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
53 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_group__debugging_1gadf127ca2262cc160830da49c37d04e85">LINFO</link>(<emphasis role="stringliteral">&quot;you&#32;changed&#32;l2grad&#32;to&#32;be&#32;&quot;</emphasis>&#32;+&#32;<link linkend="_group__utils_1gae142fbf87f70b758581c1845c2fa58e7">std::to_string</link>(newval));
54 &#32;&#32;&#32;&#32;}
55 };
56 
57 <emphasis role="comment">//&#32;Allow&#32;the&#32;module&#32;to&#32;be&#32;loaded&#32;as&#32;a&#32;shared&#32;object&#32;(.so)&#32;file:</emphasis>
58 <link linkend="_Module_8H_1a19a74668397740a2cd4813240e547179">JEVOIS_REGISTER_MODULE</link>(TutorialEdgeDetection);
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>第 7 行：将所有一起工作的参数归入某个类别是一个好主意。为了实现这一点，我们在这里创建一个参数类别。当在命令行界面中键入 <computeroutput>help</computeroutput> 时，属于给定类别的参数将一起出现。</para>
</listitem><listitem>
<para>第 9 - 12 行：我们声明了 4 个参数。对于每个参数，我们指定<itemizedlist>
<listitem>
<para>参数的名称（需要符合语法要求才能用作 C++ 类名）。</para>
</listitem><listitem>
<para>参数值的类型（可以是任何有效的 C++ 类型，包括您创建的任何自定义类）。</para>
</listitem><listitem>
<para>参数的描述，将出现在模块的帮助消息和文档中。</para>
</listitem><listitem>
<para>参数的默认值。</para>
</listitem><listitem>
<para>可选：从可接受值列表、范围、带步长的范围或正则表达式中指定有效值。这里我们仅为 <computeroutput>aperture</computeroutput> 参数指定此项，该参数被限制为取值范围从 3 到 53。</para>
</listitem><listitem>
<para>用于在帮助消息中将相关参数分组在一起的参数类别。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>第 16 行：我们的模块继承自 <link xlink:href="http://jevois.org/doc/classjevois_1_1Parameter_3_01Param_00_01Tail_8_8_8_4.html">jevois::Parameter</link>，并将我们所需的所有参数作为模板参数传递。事实上，<link xlink:href="http://jevois.org/doc/classjevois_1_1Parameter_3_01Param_00_01Tail_8_8_8_4.html">jevois::Parameter</link> 是一个可变参数类模板，可以接受任意数量的模板参数；它将简单地将每个参数作为基础逐一添加到我们的模块类中。因为我们最终从每个参数继承，这意味着我们的模块“是”一个 <computeroutput>thresh1</computeroutput> 参数，也是“是”一个 <computeroutput>thresh2</computeroutput> 参数，等等。虽然模块“是”它的每个参数（而不是像使用数据成员作为参数那样“拥有”它们）乍一看可能不合常规，但正如上面所解释的那样，这大大减轻了程序员的负担。</para>
</listitem><listitem>
<para>第 32 行：我们将输入图像转换为灰度，因为我们将在灰度模式下应用边缘检测算法。</para>
</listitem><listitem>
<para>第 40 行：请注意，这里我们需要 V4L2_PIX_FMT_GREY 作为输出格式，因为边缘检测算法的结果将是灰度图像。</para>
</listitem><listitem>
<para>第 43 行：这是零拷贝的示例，将 RawImage 重新解释为具有预分配共享像素阵列的 cv::Mat 图像。得益于此，cv::Canny 函数的结果（将计算到 <computeroutput>edge</computeroutput> cv::Mat 图像中）可以通过 USB 直接发送到主机，因为 <computeroutput>edge</computeroutput> 图像与我们的输出原始图像共享其像素数据。</para>
</listitem><listitem>
<para>第 44 行：从 OpenCV 调用 Canny 边缘检测函数，将参数值传递给它。由于我们的模块“是”<computeroutput>thresh1</computeroutput> ，也是“是”<computeroutput>thresh2</computeroutput> ，等等，并且每个参数都提供了一个 get() 函数来访问其值，因此我们需要消除要调用哪个 get() 的歧义，这可以通过明确指定要调用哪个基类（即哪个参数）来实现。因此，我们使用语法 <computeroutput>thresh1::get()</computeroutput> 来调用 <computeroutput>thresh1</computeroutput> 基类的 get() 函数，其他参数也是如此。其他参数函数以相同的方式消除歧义，例如 <computeroutput>thresh1::set(value)</computeroutput> 将在运行时设置参数 <computeroutput>thresh1</computeroutput> 的值。</para>
</listitem><listitem>
<para>第 51 - 54 行：参数 <computeroutput>l2grad</computeroutput> 在第 12 行被声明为具有回调。因此，这里是该回调的实现。这里我们只显示一条信息消息（它将显示在命令行界面中）。如果您已使用回调声明该参数（如我们在第 12 行所做的那样），除非您在此处提供 onParamChange() 的实现，否则您的代码将无法编译，也就是说，我们在编译时检查已请求的每个回调是否正确实现参数。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
<section xml:id="_ModuleTutorial_1multithreaded">
<title>多线程：并行运行 4 个边缘检测算法</title>

<para>JeVois 智能相机配备四核处理器，可让您并行运行多个操作。</para>

<para>C++11 提供了许多便利，使得编写并行代码变得非常容易，即：</para>

<para><itemizedlist>
<listitem>
<para>lambda 函数：这些函数是在需要时“即时”声明和定义的，通常目的是只在那个地方使用一次。重要的是，它们可以访问创建 lambda 函数的范围内存在的所有变量。这使得编写简单的函数变得容易，这些函数将在执行线程中运行，并使用在创建 lambda 时可用的变量。</para>
</listitem><listitem>
<para>std::async 函数在新的操作线程中启动函数。std::async 返回 std::future，它是函数完成后可能的未来结果的句柄。如果对该未来调用 get()，则调用者将阻塞，直到执行我们函数的线程完成为止。</para>
</listitem></itemizedlist>
</para>

<para>让我们通过实现一个增强的边缘检测模块来看一下，该模块使用 4 组不同的参数（例如，从非常精细到非常粗糙的边缘检测）运行 4 种 Canny 算法。我们将 4 个得到的边缘图像一个接一个地放在另一个上面，从而得到一个高度是输入图像 4 倍的输出图像。</para>

<para><literallayout><computeroutput>1 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_Module_8H">jevois/Core/Module.H</link>&gt;</emphasis>
2 <emphasis role="preprocessor">#include&#32;&lt;<link linkend="_RawImageOps_8H">jevois/Image/RawImageOps.H</link>&gt;</emphasis>
3 <emphasis role="preprocessor">#include&#32;&lt;opencv2/core/core.hpp&gt;</emphasis>
4 <emphasis role="preprocessor">#include&#32;&lt;opencv2/imgproc/imgproc.hpp&gt;</emphasis>
5 <emphasis role="preprocessor">#include&#32;&lt;future&gt;</emphasis>
6 
7 <emphasis role="comment">//&#32;Parameters&#32;for&#32;our&#32;module:</emphasis>
8 <emphasis role="keyword">static</emphasis>&#32;<link linkend="_structjevois_1_1ParameterCategory">jevois::ParameterCategory</link>&#32;<emphasis role="keyword">const</emphasis>&#32;ParamCateg(<emphasis role="stringliteral">&quot;Edge&#32;Detection&#32;Options&quot;</emphasis>);
9 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh1,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;First&#32;threshold&#32;for&#32;hysteresis&quot;</emphasis>,&#32;20.0,&#32;ParamCateg);
10 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh2,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;Second&#32;threshold&#32;for&#32;hysteresis&quot;</emphasis>,&#32;60.0,&#32;ParamCateg);
11 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(aperture,&#32;<emphasis role="keywordtype">int</emphasis>,&#32;<emphasis role="stringliteral">&quot;Aperture&#32;size&#32;for&#32;the&#32;Sobel&#32;operator&quot;</emphasis>,&#32;3,&#32;ParamCateg);
12 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(l2grad,&#32;<emphasis role="keywordtype">bool</emphasis>,&#32;<emphasis role="stringliteral">&quot;Use&#32;more&#32;accurate&#32;L2&#32;gradient&#32;norm&#32;if&#32;true,&#32;L1&#32;if&#32;false&quot;</emphasis>,&#32;<emphasis role="keyword">false</emphasis>,&#32;ParamCateg);
13 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh1delta,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;First&#32;threshold&#32;delta&#32;over&#32;threads&quot;</emphasis>,&#32;50.0,&#32;ParamCateg);
14 <link linkend="_classjevois_1_1Manager_1a9f8a184d5e5e3d41fe75b702607e7cf0">JEVOIS_DECLARE_PARAMETER</link>(thresh2delta,&#32;<emphasis role="keywordtype">double</emphasis>,&#32;<emphasis role="stringliteral">&quot;Second&#32;threshold&#32;delta&#32;over&#32;threads&quot;</emphasis>,&#32;50.0,&#32;ParamCateg);
15 
16 <emphasis role="comment">//&#32;Simple&#32;module&#32;to&#32;detect&#32;edges,&#32;running&#32;4&#32;filters&#32;in&#32;parallel&#32;with&#32;4&#32;different&#32;settings</emphasis>
17 <emphasis role="keyword">class&#32;</emphasis>TutorialEdgeDetectionX4&#32;:&#32;<emphasis role="keyword">public</emphasis>&#32;<link linkend="_classjevois_1_1Module">jevois::Module</link>,
18 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>&#32;jevois::Parameter&lt;thresh1,&#32;thresh2,&#32;aperture,&#32;l2grad,&#32;thresh1delta,&#32;thresh2delta&gt;
19 {
20 &#32;&#32;<emphasis role="keyword">public</emphasis>:
21 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Default&#32;base&#32;class&#32;constructor&#32;ok</emphasis>
22 &#32;&#32;&#32;&#32;<emphasis role="keyword">using</emphasis>&#32;<link linkend="_classjevois_1_1Component_1a21f639900c480510650969df9c74d17d">jevois::Module::Module</link>;
23 
24 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Virtual&#32;destructor&#32;for&#32;safe&#32;inheritance</emphasis>
25 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;~TutorialEdgeDetectionX4()&#32;{&#32;}
26 
27 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Processing&#32;function</emphasis>
28 &#32;&#32;&#32;&#32;<emphasis role="keyword">virtual</emphasis>&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_classjevois_1_1Module_1aeee04cc9f45ee39774e7f2ce6116059a">process</link>(<link linkend="_classjevois_1_1InputFrame">jevois::InputFrame</link>&#32;&amp;&amp;&#32;inframe,&#32;<link linkend="_classjevois_1_1OutputFrame">jevois::OutputFrame</link>&#32;&amp;&amp;&#32;outframe)<emphasis role="keyword">&#32;override</emphasis>
29 <emphasis role="keyword">&#32;&#32;&#32;&#32;</emphasis>{
30 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;next&#32;available&#32;camera&#32;image:</emphasis>
31 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;inimg&#32;=&#32;inframe.get();
32 
33 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Convert&#32;to&#32;grayscale:</emphasis>
34 &#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;grayimg&#32;=&#32;<link linkend="_namespacejevois_1_1rawimage_1a28053035013862dd0dd48c4601216655">jevois::rawimage::convertToCvGray</link>(inimg);
35 &#32;&#32;
36 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Let&#32;camera&#32;know&#32;we&#32;are&#32;done&#32;processing&#32;the&#32;input&#32;image:</emphasis>
37 &#32;&#32;&#32;&#32;&#32;&#32;inframe.done();
38 
39 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Wait&#32;for&#32;an&#32;image&#32;from&#32;our&#32;gadget&#32;driver&#32;into&#32;which&#32;we&#32;will&#32;put&#32;our&#32;results:</emphasis>
40 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_classjevois_1_1RawImage">jevois::RawImage</link>&#32;outimg&#32;=&#32;outframe.get();
41 &#32;&#32;&#32;&#32;&#32;&#32;outimg.<link linkend="_classjevois_1_1RawImage_1aacde26c84586c08d1e913694670d2d8e">require</link>(<emphasis role="stringliteral">&quot;output&quot;</emphasis>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1a8b04939022b754b9e375772d3f3ee85f">width</link>,&#32;inimg.<link linkend="_classjevois_1_1RawImage_1aaa1eeb6405c5c5fceea6d772b52474b5">height</link>&#32;*&#32;4,&#32;V4L2_PIX_FMT_GREY);
42 
43 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Launch&#32;4&#32;Canny&#32;filters&#32;in&#32;parallel.&#32;We&#32;launch&#32;3&#32;threads&#32;and&#32;will&#32;do&#32;the&#32;fourth&#32;in&#32;the&#32;current&#32;thread:</emphasis>
44 &#32;&#32;&#32;&#32;&#32;&#32;std::vector&lt;std::future&lt;void&gt;&#32;&gt;&#32;fut;
45 &#32;&#32;&#32;&#32;&#32;&#32;
46 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;3;&#32;++i)
47 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fut.push_back(<link linkend="_namespacejevois_1a5c82f5b2b9dd4a98d343f9e54eea0fff">jevois::async</link>([&amp;](<emphasis role="keywordtype">int</emphasis>&#32;i)&#32;{
48 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Compute&#32;Canny&#32;edges&#32;directly&#32;into&#32;the&#32;output&#32;image,&#32;offset&#32;by&#32;i&#32;images&#32;down.&#32;The&#32;last&#32;argument&#32;of&#32;the</emphasis>
49 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;cv::Mat&#32;constructor&#32;below&#32;is&#32;the&#32;address&#32;of&#32;an&#32;already-allocated&#32;pixel&#32;buffer&#32;for&#32;the&#32;cv::Mat:</emphasis>
50 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;edges(grayimg.rows,&#32;grayimg.cols,&#32;CV_8UC1,&#32;outimg.pixelsw&lt;unsigned&#32;char&gt;()&#32;+&#32;i&#32;*&#32;grayimg.total());
51 
52 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cv::Canny(grayimg,&#32;edges,&#32;thresh1::get()&#32;+&#32;i&#32;*&#32;thresh1delta::get(),
53 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;thresh2::get()&#32;+&#32;i&#32;*&#32;thresh2delta::get(),&#32;aperture::get(),&#32;l2grad::get());
54 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;},&#32;i));
55 
56 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Fourth&#32;one&#32;(same&#32;code&#32;as&#32;above&#32;except&#32;for&#32;the&#32;async,&#32;and&#32;for&#32;i=3):</emphasis>
57 &#32;&#32;&#32;&#32;&#32;&#32;cv::Mat&#32;edges(grayimg.rows,&#32;grayimg.cols,&#32;CV_8UC1,&#32;outimg.<link linkend="_classjevois_1_1RawImage_1ac2202ecd3324959d17c06a191624d2a6">pixelsw</link>&lt;<emphasis role="keywordtype">unsigned</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&gt;()&#32;+&#32;3&#32;*&#32;grayimg.total());
58 &#32;&#32;&#32;&#32;&#32;&#32;cv::Canny(grayimg,&#32;edges,&#32;thresh1::get()&#32;+&#32;3&#32;*&#32;thresh1delta::get(),
59 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;thresh2::get()&#32;+&#32;3&#32;*&#32;thresh2delta::get(),&#32;aperture::get(),&#32;l2grad::get());
60 
61 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;fourth&#32;one&#32;is&#32;done&#32;now,&#32;wait&#32;for&#32;all&#32;the&#32;threads&#32;to&#32;complete.&#32;Note:&#32;using&#32;async()&#32;is&#32;preferred&#32;to&#32;using</emphasis>
62 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;std::thread,&#32;as&#32;get()&#32;below&#32;will&#32;throw&#32;if&#32;any&#32;exception&#32;was&#32;thrown&#32;by&#32;a&#32;thread,&#32;as&#32;opposed&#32;to&#32;std::thread</emphasis>
63 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;violently&#32;terminating&#32;the&#32;program&#32;on&#32;exception.&#32;In&#32;case&#32;two&#32;or&#32;more&#32;threads&#32;threw,&#32;we&#32;can&#32;here&#32;avoid</emphasis>
64 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;termination&#32;by&#32;catching&#32;the&#32;exceptions&#32;one&#32;by&#32;one.&#32;Here&#32;we&#32;just&#32;ignore&#32;(since&#32;we&#32;are&#32;done&#32;anyway)&#32;but&#32;could</emphasis>
65 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;throw&#32;just&#32;once&#32;if&#32;any&#32;of&#32;the&#32;threads&#32;threw:</emphasis>
66 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;&amp;&#32;f&#32;:&#32;fut)&#32;<emphasis role="keywordflow">try</emphasis>&#32;{&#32;f.get();&#32;}&#32;<emphasis role="keywordflow">catch</emphasis>&#32;(...)&#32;{&#32;<link linkend="_group__debugging_1ga7460b83ad6c4523ba897c81362742027">jevois::warnAndIgnoreException</link>();&#32;}
67 &#32;&#32;&#32;&#32;&#32;&#32;
68 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;Send&#32;the&#32;output&#32;image&#32;with&#32;our&#32;processing&#32;results&#32;to&#32;the&#32;host&#32;over&#32;USB:</emphasis>
69 &#32;&#32;&#32;&#32;&#32;&#32;outframe.send();
70 &#32;&#32;&#32;&#32;}
71 };
72 
73 <emphasis role="comment">//&#32;Allow&#32;the&#32;module&#32;to&#32;be&#32;loaded&#32;as&#32;a&#32;shared&#32;object&#32;(.so)&#32;file:</emphasis>
74 <link linkend="_Module_8H_1a19a74668397740a2cd4813240e547179">JEVOIS_REGISTER_MODULE</link>(TutorialEdgeDetectionX4);
</computeroutput></literallayout></para>

<para>让我们看看与前面的例子相比有什么新的：</para>

<para><itemizedlist>
<listitem>
<para>第 7 至 14 行：现在我们又有两个参数，<computeroutput>thresh1delta</computeroutput> 和 <computeroutput>thresh2delta</computeroutput> ，它们是我们在每个线程中增加 thresh1 和 thresh2 的量。因此，第一个边缘检测器将使用 thresh1，第二个将使用 thresh1 + thresh1delta，第三个将使用 thresh1 + 2 * thresh1delta，等等</para>
</listitem><listitem>
<para>第 41 行：我们的输出图像将把 4 个边缘图一个叠一个地存储，因此我们要求输出图像的宽度相同，但高度是输入图像的 4 倍。</para>
</listitem><listitem>
<para>第 44 行：如果在 Future 被销毁（超出范围）时尚未执行 get()，std::future 的析构函数将隐式调用 get()。因此，如果我们没有将使用 std::async 时返回的 Future 存储在某个地方，它们将被销毁，并且我们的进程将被阻止，直到下面循环的每次迭代所请求的处理完成，从而一个接一个地执行 4 个边缘检测。为了并行执行它们，我们将保持 std::async 返回的 Future 处于活动状态，直到我们准备好从我们的 4 个线程收集所有结果。</para>
</listitem><listitem>
<para>第 46 行：我们使用 std::async 启动 3 个并行线程，并将在当前线程中运行第 4 个边缘检测器。</para>
</listitem><listitem>
<para>第 47 行：每个线程将运行一个 lambda 函数，该函数将被授予访问权限（通过引用）当前范围（[&amp;] 符号）中存在的所有变量，并且该函数接受一个 <computeroutput>int</computeroutput> 参数 <computeroutput>i</computeroutput> （我们要运行的边缘检测器的实例编号）。</para>
</listitem><listitem>
<para>第 50 行：正如注释中所说，我们创建一个 cv::Mat，其中包含原始输出图像数组中的像素，<computeroutput>i</computeroutput> 图像向下。</para>
</listitem><listitem>
<para>第 52 - 53 行：我们在线程 <computeroutput>i</computeroutput> 中运行 Canny，使用参数 thresh1 + i * thresh1delta 等</para>
</listitem><listitem>
<para>第 57 - 59 行：这本质上与我们的 lambda 函数中的代码相同，但我们不需要使用 std::async 为我们的第 4 个边缘检测器创建另一个线程，我们可以在当前线程中运行它。</para>
</listitem><listitem>
<para>第 61 行：当我们到达这里时，cv::Canny 的第 4 次调用已完成。因此其他 3 次调用也应该已准备就绪。</para>
</listitem><listitem>
<para>第 66 行：我们只需在每个 Future 上运行 get() 即可等待所有线程完成。请注意，get() 具有异常转发功能，即，如果线程中运行的函数抛出异常，它也可能抛出异常。在这里，我们只需捕获、警告和忽略任何异常。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
<section xml:id="_ModuleTutorial_1moremoduletutorial">
<title>更多模块教程和示例</title>

<para>更多信息请参见：</para>

<para><itemizedlist>
<listitem>
<para><link linkend="_ProgrammerSDK">程序员 SDK 和编写新模块</link> 介绍如何创建和编译新模块</para>
</listitem><listitem>
<para><link xlink:href="/basedoc/">JeVoisBase 模块集合的文档</link> </para>
</listitem></itemizedlist>
</para>
</section>
    <section xml:id="_ModuleTips"><title>编写机器视觉模块的技巧</title>    </section>
<para><formalpara><title></title></formalpara>
</para>
<section xml:id="_ModuleTips_1moduletipsexceptions">
<title>处理异常</title>

<para>JeVois 框架完全支持使用异常。我们相信这提供了更易读的代码，其中主要流程是预期可以工作的流程。这与 Linux 内核等形成了鲜明对比，后者只是一大堆 <computeroutput>if</computeroutput> 语句来检查某些操作是否成功。</para>

<para>因此，在 Module process() 函数中，如果出现任何问题，正确的做法是抛出异常。Engine 将捕获异常，进行清理并继续处理下一个视频帧，希望能够取得更好的结果。</para>

<para>我们建议抛出 <computeroutput>std::runtime_error</computeroutput> ，因为这将向用户提供更详细的消息（错误消息将显示异常的 <computeroutput>what()</computeroutput> 字符串）。</para>

<para>为了实现异常安全并避免内存泄漏，最简单（也可能是最好的）的方法是始终使用动态分配内存的异常安全包装器。最常见的是 <computeroutput>std::shared_ptr</computeroutput> ，当没有人再引用它时，它将自动释放分配的内存。</para>

<para>因此，而不是：</para>

<para><literallayout><computeroutput>void&#32;process(jevois::InputFrame&#32;&amp;&amp;&#32;inframe)
{
&#32;&#32;char&#32;*&#32;tmpdata&#32;=&#32;new&#32;char[100];

&#32;&#32;do_something_that_could_throw();

&#32;&#32;delete&#32;[]&#32;tmpdata;
}
</computeroutput></literallayout></para>

<para>如果发生异常，则会泄漏 <computeroutput>tmpdata</computeroutput> 内存，只需使用：</para>

<para><literallayout><computeroutput>void&#32;process(jevois::InputFrame&#32;&amp;&amp;&#32;inframe)
{
&#32;&#32;std::shared_ptr&lt;char&gt;&#32;tmpdata(new&#32;char[100]);

&#32;&#32;do_something_that_could_throw();
}
</computeroutput></literallayout></para>

<para><computeroutput>shared_ptr</computeroutput> 会在超出范围时自动释放内存（因为 <computeroutput>process()</computeroutput> 函数正常结束，或者因为发生异常）。您也可以只使用 <computeroutput>std::string</computeroutput> 或 <computeroutput>std::vector</computeroutput> 作为 <computeroutput>tmpdata</computeroutput> ，因为它们会在超出范围时释放内存（包括因为引发异常）。<computeroutput>std::unique_ptr</computeroutput> 也适用于此。</para>

<para><formalpara><title></title></formalpara>
</para>
</section>
<section xml:id="_ModuleTips_1moduletipscoords">
<title>坐标</title>

<para>JeVois 可以处理各种视频分辨率的图像。如果它检测到帧中的某个物体并想将其坐标传达给 Arduino，那么就会出现使用哪种分辨率以及如何让 Arduino 知道的问题。</para>

<para>例如，如果算法处理 640x480 的视频，那么在坐标 320,240 处检测到的物体位于视野的中心。但如果相机在 320x240 处抓取，那么坐标 320,240 就在视野的右下角。仅仅让 Arduino 知道在 320,240 处检测到了某物可能会造成混淆。</para>

<para>我们不需要让 Arduino 来支持多种摄像头分辨率，而是在 JeVois 中提供一个标准化的坐标系：</para>

<para>参见 <link linkend="_group__coordhelpers">用于将坐标从相机分辨率转换为标准坐标的辅助函数</link></para>

<para>使用 <link linkend="_group__coordhelpers_1ga8ba21a5c6f04aaf017269c72329126cb">imgToStd()</link> 将图像坐标转换为标准坐标。</para>

<para>相反地​​使用 <link linkend="_group__coordhelpers_1ga353d977e4cee5c0ddd2b331fb4ff60d5">stdToImg()</link>。 </para>
</section>
    <section xml:id="_ProgrammerPython"><title>使用 Python 编程机器视觉模块</title>    </section>
<para>从 开始，您可以使用 Python 3.x 为 JeVois 编写机器视觉模块。</para>
<section xml:id="_ProgrammerPython_1autotoc_md83">
<title>概述</title>

<para>基本框架如下：</para>

<para><itemizedlist>
<listitem>
<para>核心 JeVois 软件提供的许多基本设施都经过了包装，以便可以通过 Python 访问。例如，这包括视频帧捕获、图像转换、通过 USB 输出视频帧、日志消息、向串行端口发送消息等。</para>
</listitem><listitem>
<para>OpenCV 也被包装到 Python 中，并且可以在用 Python 编写的 JeVois 模块中使用。这允许人们使用 OpenCV 提供的机器视觉和图像处理功能。在这个框架中，图像表示为 Python numpy 数组。JeVois 核心公开了函数，允许将摄像机视频帧和输出视频帧转换为 Python numpy 数组或相反。</para>
</listitem><listitem>
<para>用 Python 编写的 JeVois 模块应由一个公开特定接口的 Python 类组成，包括一个 process() 函数，每次模块要处理新的视频帧时 JeVois 引擎都会调用该函数，并且应通过 USB 将输出图像发送到主机，以及一个 processNoUSB() 函数，在没有 USB 视频输出的情况下处理摄像头帧时会调用该函数（这两个函数的名称不同，因为 Python 不支持成员函数重载）。请注意，由于 <link xlink:href="https://www.chiefdelphi.com/forums/showthread.php?t=159883&amp;page=6">此线程</link> 上的用户讨论，此问题已在 中得到修复。</para>
</listitem><listitem>
<para>因此，Python 集成以双向方式工作：<itemizedlist>
<listitem>
<para>JeVois 核心提供了一个 <emphasis role="bold">libjevois</emphasis> Python 库，可供用 Python 编写的模块使用。</para>
</listitem><listitem>
<para>用 Python 编写的模块公开一个具有特定成员函数的类，当模块加载时，JeVois 核心将实例化并调用该类。</para>
</listitem><listitem>
<para>JeVois 核心像调用 C++ 模块一样调用用 Python 编写的模块，使用 process() 函数，如 <link linkend="_Concepts">本文档中使用的概念</link> 中所述。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>用 Python 编写的 JeVois 模块在其他方面与用 C++ 编写的模块一样：当主机选择特定视频分辨率时，它们会被加载，这对应于 <emphasis role="bold">videomappings.cfg</emphasis> 中与感兴趣的模块匹配的条目。它们在 <emphasis role="bold">JEVOIS:/modules</emphasis> 下还有一个目录，并且它们可能具有与 C++ 模块相同的辅助文件。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerPython_1autotoc_md84">
<title>例子</title>

<para>jevoisbase 中的模块可以帮助您了解其工作原理：</para>

<para><itemizedlist>
<listitem>
<para><link xlink:href="/basedoc/jvpkg_2modules_2JeVois_2PythonTest_2PythonTest_8py_source.html">PythonTest</link> 使用 JeVois 导出的函数和类。</para>
</listitem><listitem>
<para><link xlink:href="/basedoc/jvpkg_2modules_2JeVois_2PythonOpenCV_2PythonOpenCV_8py_source.html">PythonOpenCV</link> 也使用 OpenCV。</para>
</listitem><listitem>
<para><link xlink:href="/basedoc/jvpkg_2modules_2JeVois_2PythonSandbox_2PythonSandbox_8py_source.html">PythonSandbox</link> 也使用 OpenCV。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerPython_1autotoc_md85">
<title>JeVois 核心对用 Python 编写的模块的期望</title>

<para>就像模块 C++ 抽象基类定义了 JeVois 引擎如何使用 C++ 模块的接口一样，Python 模块应该按如下方式组织：</para>

<para><itemizedlist>
<listitem>
<para><emphasis role="bold">JEVOIS:/modules/vendor/</emphasis> 下目录中的单个 .py 文件声明一个 Python 类，其文件名主干（不带扩展名）、目录名和类名完全匹配。</para>
</listitem><listitem>
<para>模块可以声明和实现（所有都是可选的，但大多数模块至少应该实现一个 process() 函数才有用）：<itemizedlist>
<listitem>
<para>无参数的构造函数：<computeroutput>__init__(self)</computeroutput></para>
</listitem><listitem>
<para>带有 USB 输出的 Process 函数：<computeroutput>process(self, inframe, outframe)</computeroutput></para>
</listitem><listitem>
<para>无 USB 输出的 Process 函数：<computeroutput>processNoUSB(self, inframe)</computeroutput></para>
</listitem><listitem>
<para> 带有 GUI 输出的 Process 函数：<computeroutput>processGUI(self, inframe, guihelper)</computeroutput></para>
</listitem><listitem>
<para>用于解析 JeVois <link linkend="_classjevois_1_1Engine">Engine</link> 转发给模块的串行命令的函数，返回一个字符串：<computeroutput>parseSerial(self, str)</computeroutput></para>
</listitem><listitem>
<para>用于返回描述模块支持的自定义命令的字符串的函数，用于 JeVois 帮助消息：<computeroutput>supportedCommands(self)</computeroutput></para>
</listitem><listitem>
<para>用于在模块卸载之前进行清理的函数：<computeroutput>uninit()</computeroutput>（在 及更高版本中）</para>
</listitem><listitem>
<para>请注意，sendSerial() 由 C++ 模块基类提供允许派生模块通过串行端口发送消息不应定义，也不会被调用（因为它是由 JeVois 核心库而不是模块实现的）；相反，JeVois 核心库向 Python 模块公开了一个函数 <computeroutput>jevois.sendSerial()</computeroutput>，该函数可实现相同的结果。对于访问原始相机或 <link linkend="_classjevois_1_1IMU">IMU</link> 寄存器的函数也是如此：</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>jevois.writeCamRegister()</para>
</listitem><listitem>
<para>jevois.readCamRegister()</para>
</listitem><listitem>
<para>jevois.writeIMUregister()</para>
</listitem><listitem>
<para>jevois.readIMUregister()</para>
</listitem><listitem>
<para>jevois.frameNum()</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammerPython_1autotoc_md86">
<title>JeVois 核心提供的 Python 绑定</title>

<para>JeVois 核心软件的以下函数和类已包装以供 Python 使用。要使用给定类或函数的 Python 版本，只需检查 C++ 文档并假设将使用相同的类名、函数名以及参数的数量和类型（下面提到的几个例外情况除外）。</para>

<para>请参阅 <link linkend="_PythonSupport_8C">PythonSupport.C</link> 中的 <emphasis>BOOST_PYTHON_MODULE()</emphasis> 中的源代码，了解最新的 Python 绑定列表。</para>

<para>可以通过以下方式将绑定导入 Python：</para>

<para><literallayout><computeroutput>import&#32;pyjevois
if&#32;pyjevois.pro:&#32;import&#32;libjevoispro&#32;as&#32;jevois
else:&#32;import&#32;libjevois&#32;as&#32;jevois
</computeroutput></literallayout></para>

<para>每个用 Python 编写的 JeVois 模块都应以该导入开始。</para>

<para>由于所有 Python 绑定都在 <emphasis role="bold">jevois</emphasis> 模块下（实际上是 libjevois，我们将其导入为 jevois），因此您应该通过在 <emphasis role="bold">jevois</emphasis> 模块名称前面加上前缀来调用它们。</para>

<para>例如，考虑在 jevois C++ 命名空间中定义的 C++ 函数 <link linkend="_group__utils_1gac76ed513027efe252fe64756fae6d0b6">fccstr()</link>，其签名为：</para>

<para><literallayout><computeroutput>//&#32;将&#32;V4L2&#32;four-cc&#32;代码（V4L2_PIX_FMT_...）转换为&#32;4&#32;个字符的字符串&#32;
std::string&#32;fccstr(unsigned&#32;int&#32;fcc);&#32;
</computeroutput></literallayout></para>

<para>从 Python 调用此函数的形式如下：</para>

<para><literallayout><computeroutput>s&#32;=&#32;jevois.fccstr(code)
</computeroutput></literallayout></para>

<para>将调用 JeVois 的 C++ 函数 <link linkend="_group__utils_1gac76ed513027efe252fe64756fae6d0b6">fccstr()</link>，将变量 <emphasis role="bold">code</emphasis> 的内容传递给它（该变量应为 C++ 函数所期望的正整数，否则绑定引擎将抛出输入参数类型不正确的异常）。然后，C++ 函数返回的 C++ 字符串将被复制到 Python 字符串 <emphasis role="bold">s</emphasis> ，并且可以在 Python 中进一步使用，就像任何 Python 字符串一样。</para>
<section xml:id="_ProgrammerPython_1autotoc_md87">
<title>绑定列表</title>

<para>单击下面的任何类或函数即可查看其文档。虽然该文档适用于 C++ 版本，但此处列出的函数和类与 Python 具有精确绑定，但您可以忽略任何 C++ 限定符（<computeroutput>const</computeroutput> 和类似）和引用/指针规范（参数名称前的 <computeroutput>&amp;</computeroutput> 或 <computeroutput>*）。</computeroutput> </para>

<para><note><title>Note</title>

<para>请参阅 <link linkend="_PythonSupport_8C">PythonSupport.C</link> 中 <emphasis>BOOST_PYTHON_MODULE()</emphasis> 的源代码，了解最新的 Python 绑定列表。</para>
</note>
<itemizedlist>
<listitem>
<para>在 <link linkend="_Util_2Utils_8H">Utils.H</link> 中声明的通用实用函数<itemizedlist>
<listitem>
<para><link linkend="_group__utils_1gac76ed513027efe252fe64756fae6d0b6">fccstr()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga5cf98a150bb5637de6bbbbb1607ef669">cvtypestr()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga34f3127327f6113672a16d3a041552df">strfcc()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga4f32c685308caf5e428e27b8ccaee14b">v4l2BytesPerPix()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1gafa5c6faaeefd12994a07c09ed748176c">v4l2ImageSize()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1gae3448a5e4bbd80efd03d6417974834d0">blackColor()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga7bf3f71d614429a46eda4d9c133e2866">whiteColor()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga3c42b68a3562220199677eed7cdceb51">flushcache()</link></para>
</listitem><listitem>
<para><link linkend="_group__utils_1ga63b839e0e7f2fa177df3755ee1205fee">system()</link></para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在 <link linkend="_Coordinates_8H">Coordinates.H</link> 中声明的坐标助手<itemizedlist>
<listitem>
<para><link linkend="_group__coordhelpers_1ga8ba21a5c6f04aaf017269c72329126cb">imgToStd()</link></para>
</listitem><listitem>
<para><link linkend="_group__coordhelpers_1ga353d977e4cee5c0ddd2b331fb4ff60d5">stdToImg()</link></para>
</listitem><listitem>
<para><link linkend="_group__coordhelpers_1ga22830c058b06d45804ac9acc9e43d939">imgToStdX()</link></para>
</listitem><listitem>
<para><link linkend="_group__coordhelpers_1ga3c03b605134727c861576a87ccd0fcb7">imgToStdY()</link></para>
</listitem><listitem>
<para><link linkend="_group__coordhelpers_1gac6b2bbdd9348f3da2e4f9dd304bf3343">imgToStdSize()</link></para>
</listitem><listitem>
<para><link linkend="_namespacejevois_1_1coords_1af348fba8df5bc4a080b59955dcccaae1">stdToImgSize()</link></para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>支持从相机和 USB 传输原始图像缓冲区，来自 <link linkend="_RawImage_8H">RawImage.H</link><itemizedlist>
<listitem>
<para>类 <link linkend="_classjevois_1_1RawImage">RawImage</link></para>
</listitem><listitem>
<para>成员函数：invalidate()、valid()、clear()、require()、bytesperpix()、bytesize()、coordsOk()</para>
</listitem><listitem>
<para>成员变量：width、height、fmt、fps</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>按名称表示原始格式的 YUYV 颜色，如 <link linkend="_RawImage_8H">RawImage.H</link><itemizedlist>
<listitem>
<para>这些颜色映射到 Python 枚举 <emphasis role="bold">jevois.YUYV</emphasis>，其值为 Black = 0x8000、DarkGrey = 0x8050、MedGrey = 0x8080、LightGrey = 0x80a0、White = 0x80ff、DarkGreen = 0x0000、MedGreen = 0x0040、LightGreen = 0x00ff、DarkTeal = 0x7070、MedTeal = 0x7090、LightTeal = 0x70b0、DarkPurple = 0xa030、MedPurple = 0xa050、LightPurple = 0xa080、DarkPink = 0xff00、MedPink = 0xff80、LightPink = 0xffff。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>相机传感器和 USB 输出支持的 Video4Linux2 (V4L2) <link linkend="_classjevois_1_1RawImage">RawImage</link> 像素格式：<itemizedlist>
<listitem>
<para>这些映射到常量 <emphasis role="bold">jevois.V4L2_PIX_FMT_SRGGB8、jevois.V4L2_PIX_FMT_YUYV、jevois.V4L2_PIX_FMT_GREY、jevois.V4L2_PIX_FMT_RGB565、jevois.V4L2_PIX_FMT_MJPEG 和 jevois.V4L2_PIX_FMT_BGR24</emphasis>。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>输入帧包装器，包装 <link linkend="_Module_8H">Module.H</link> 的 <link linkend="_classjevois_1_1InputFrame">InputFrame</link> 类<itemizedlist>
<listitem>
<para>class <link linkend="_classjevois_1_1InputFrame">InputFrame</link></para>
</listitem><listitem>
<para>成员函数的 <link linkend="_classjevois_1_1InputFrame">InputFrame</link> 类的输入帧包装器：get()、done()、getCvGRAY()、getCvBGR()、getCvRGB()、getCvRGBA()</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para><link linkend="_Module_8H">Module.H</link> 中 <link linkend="_classjevois_1_1OutputFrame">OutputFrame</link> 类的输出帧包装器<itemizedlist>
<listitem>
<para>class <link linkend="_classjevois_1_1OutputFrame">OutputFrame</link></para>
</listitem><listitem>
<para>成员函数的 <link linkend="_classjevois_1_1OutputFrame">OutputFrame</link> 类的输出帧包装器：get()、send()、sendCv()、sendCvGRAY()、sendCvBGR()、sendCvRGB()、sendCvRGBA()、sendScaledCvGRAY()、sendScaledCvBGR()、sendScaledCvRGB()、sendScaledCvRGBA()</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>对原始图像的操作，如 <link linkend="_RawImageOps_8H">RawImageOps.H</link> 中声明的<itemizedlist>
<listitem>
<para><link linkend="_group__image_1ga20c3651602d9b2d003988b9bcd674f03">cvImage()</link></para>
</listitem><listitem>
<para><link linkend="_namespacejevois_1_1rawimage_1a28053035013862dd0dd48c4601216655">convertToCvGray()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga6f005034f93fc03530498eae898f9b22">convertToCvBGR()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga41c623fdf6e26eca8908b1129b56312f">convertToCvRGB()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga028f56e85446eef9d27bd51c71867dd2">convertToCvRGBA()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gac56b219fa6df460b3a9beaf7712d5c77">byteSwap()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga05c4650464e447a89a2a2c60d1956748">paste()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gae83668f61639d6a6f4de5e11d02ca015">pasteGreyToYUYV()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gaa8a5444f39661f76fb160f1f6eead381">roipaste()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga529a42aed4e4681e38910e8793e6064c">drawDisk()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gae7d102e1c456f87337d66a9a2fc11a58">drawCircle()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga7cf2b2c4e6460835fbc671367a60feb9">drawLine()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gaa32b3e227c9904699d616e2a32c9506d">drawRect()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga2696d3febc217f295d5532c26255c26b">writeText()</link>，字体通过 Python 枚举 <emphasis role="bold">jevois.Font</emphasis> 选择，其值为 <emphasis role="bold">Font5x7, Font6x10, Font7x13, Font8x13bold, Font9x15bold, Font10x20, Font11x22, Font12x22, Font14x26, Font15x28, Font16x29, Font20x38</emphasis>。</para>
</listitem><listitem>
<para><link linkend="_group__image_1gad05785dce156be8a1e4d473ea07e3f67">convertCvGRAYtoRawImage()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga748b79664f7d9c00f2706e726276a09f">convertCvBGRtoRawImage()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga8d0578936bcb62de35eec980b933de52">convertCvRGBtoRawImage()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1ga5c34b763c90ed987d80a1dc58e75524c">convertCvRGBAtoRawImage()</link></para>
</listitem><listitem>
<para><link linkend="_namespacejevois_1_1rawimage_1a8d4333176ceabdbadb22ffcb6b2d9d52">unpackCvRGBAtoGrayRawImage()</link></para>
</listitem><listitem>
<para><link linkend="_group__image_1gaa830449161c068b13cd986844a2c428e">hFlipYUYV()</link></para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在 <link linkend="_Timer_8H">Timer.H</link> 中声明的 <link linkend="_classjevois_1_1Timer">Timer</link> 类<itemizedlist>
<listitem>
<para><link linkend="_classjevois_1_1Timer">Timer</link> 类（请注意，构造函数接受参数；请参阅下文了解日志级别定义）</para>
</listitem><listitem>
<para>成员函数：start()、stop()</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在 <link linkend="_Profiler_8H">Profiler.H</link> 中声明的 <link linkend="_classjevois_1_1Profiler">Profiler</link> 类<itemizedlist>
<listitem>
<para><link linkend="_classjevois_1_1Profiler">Profiler</link> 类（请注意，构造函数接受参数；请参阅下文了解日志级别定义）</para>
</listitem><listitem>
<para>成员函数：start()、checkpoint()、stop()</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在 SysInfo.H 中声明的系统实用程序<itemizedlist>
<listitem>
<para><link linkend="_group__debugging_1ga5cd0b0b867a9f033762819e8af37ca35">getSysInfoCPU()</link></para>
</listitem><listitem>
<para><link linkend="_group__debugging_1ga98e313acb940dfe5cb5168e8b0876ba8">getSysInfoMem()</link></para>
</listitem><listitem>
<para><link linkend="_group__debugging_1gacab36569297392a9a62000609f3d2193">getSysInfoVersion()</link></para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>日志记录函数，<link linkend="_Log_8H">Log.H</link> 中声明的宏的简化版本，采用单个字符串参数，而不是 C++ 端使用的流式接口（因此，Python 程序员应使用 Python 字符串 format() 函数将各种变量值放置在该字符串中）：<itemizedlist>
<listitem>
<para><link linkend="_group__debugging_1ga136d9d772791ddd40a7781b0f6b01dd6">LDEBUG()</link>、LINFO()、LERROR()、LFATAL()</para>
</listitem><listitem>
<para>定义为常量的日志级别：<emphasis role="bold">jevois.LOG_DEBUG、jevois.LOG_INFO、jevois.LOG_ERR、jevois.LOG_CRIT</emphasis>。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>在 上，GUIhelperPython 公开的函数，它是 <link linkend="_classjevois_1_1GUIhelper">GUIhelper</link> 的代理。</para>
</listitem></itemizedlist>
</para>
</section>
</section>
<section xml:id="_ProgrammerPython_1autotoc_md88">
<title>代码文档和附件文件</title>

<para>遵循与 <link linkend="_ProgrammerSDK">程序员 SDK 和编写新模块</link> 中 &quot;模块文档和元数据&quot; 下的相同规则</para>

<para>请参阅 jevoisbase 中的示例 Python 模块，了解如何将其转换为 Python doxygen 指令的示例。 </para>
</section>
    <section xml:id="_ModulePythonTutorial"><title>关于如何用 Python 编写新的机器视觉模块的教程</title>    </section><section xml:id="_ModulePythonTutorial_1pyoverview">
<title>概述</title>

<para>机器视觉 Python 模块被编程为单个类，该类公开了 JeVois Engine 所需的特定接口。请参阅 <link linkend="_ProgrammerPython">使用 Python 编程机器视觉模块</link> 了解简介。</para>

<para>作为初步（略微过于简化）的想法，JeVois 视觉模块的整体工作流程是它们实现一个处理功能，该功能将接收由相机传感器捕获的图像，以及将通过 USB 发送到主机的预分配输出图像。处理功能的任务是使用处理输入图像的结果填充输出图像。</para>

<para>在本教程中，我们首先向您展示如何编写几个非常简单的模块，以引入必要的概念。在本教程的最后，我们将为您指出进一步的详细阅读内容。</para>

<para>：以下教程创建在 JeVois-Pro 上以“传统模式”运行的模块，即模块接收一个图像作为输入并输出包含处理结果的新图像。有关使用 /jvpro 的新“Pro/GUI”模式的模块的示例，请查看 jevoisbase 中许多示例的源代码：<link linkend="_UserDemos">捆绑视觉模块和演示的用户指南</link></para>

<para>在开始之前，您应该了解 概念。</para>
<section xml:id="_ModulePythonTutorial.dox_1pymappings">
<title>像素格式和视频映射</title>

<para>提醒一下，JeVois 智能相机可以捕捉以下相机像素格式的图像：YUYV、BAYER 或 RGB565。这些格式是相机传感器芯片支持的格式。</para>

<para>JeVois 可以向通过 USB 连接的主机发送更广泛的像素格式：YUYV、GREY、MJPG、BAYER、RGB565 和 BGR24。</para>

<para>有关这些格式的解释，请参阅 <link linkend="_UserModes">视频模式和映射用户指南</link> 了解详情。</para>
</section>
<section xml:id="_ModulePythonTutorial.dox_1pyvideomappings">
<title>摄像头到 USB 视频映射</title>

<para>当主机通过 上的 USB 或 上的用户选择特定图像分辨率和像素格式时，将调用模块。视频映射列表将给定的输出分辨率和像素类型与应使用的相应相机分辨率和像素类型以及应调用的机器视觉模块关联起来。再次参阅 <link linkend="_UserModes">视频模式和映射用户指南</link> 了解详细信息。</para>

<para>由于输出视频格式由 上的主机或 上的用户选择，因此不可协商。如果在 <emphasis role="bold">videomappings.cfg</emphasis> 中指定了调用特定机器视觉模块的视频映射，则该模块必须执行（或抛出异常）并处理从相机接收的图像以生成所需的输出图像。</para>

<para>：对于 JeVois-Pro，将以下示例中的“import libjevois as jevois”替换为以下内容：</para>

<para><literallayout><computeroutput>导入&#32;pyjevois&#32;如果&#32;pyjevois.pro:&#32;导入&#32;libjevoispro&#32;作为&#32;jevois&#32;否则:&#32;导入&#32;libjevois&#32;作为&#32;jevois&#32;
</computeroutput></literallayout></para>

<para><formalpara><title>##############################################################################################@section pygetstarted 入门：边缘检测模块</title></formalpara>
</para>

<para>这里我们使用 OpenCV 的 Canny 边缘检测器在 Python 中编写了一个简单的边缘检测模块。我们将抓取一个彩色视频帧，将其转换为灰度，计算边缘图（也是灰度），然后通过 USB 将其发送到主机。</para>

<para>以下是完整、有效的代码。我们将逐步介绍它：</para>

<para><literallayout><computeroutput>1 <emphasis role="keyword">import</emphasis>&#32;libjevois&#32;<emphasis role="keyword">as</emphasis>&#32;jevois
2 <emphasis role="keyword">import</emphasis>&#32;cv2
3 <emphasis role="keyword">import</emphasis>&#32;numpy&#32;<emphasis role="keyword">as</emphasis>&#32;np
4 
5 <emphasis role="comment">##&#32;Simple&#32;example&#32;of&#32;image&#32;processing&#32;using&#32;OpenCV&#32;in&#32;Python&#32;on&#32;JeVois</emphasis>
6 <emphasis role="comment">#</emphasis>
7 <emphasis role="comment">#&#32;This&#32;module&#32;by&#32;default&#32;simply&#32;converts&#32;the&#32;input&#32;image&#32;to&#32;a&#32;grayscale&#32;OpenCV&#32;image,&#32;and&#32;then&#32;applies&#32;the&#32;Canny</emphasis>
8 <emphasis role="comment">#&#32;edge&#32;detection&#32;algorithm.&#32;Try&#32;to&#32;edit&#32;it&#32;to&#32;do&#32;something&#32;else&#32;(note&#32;that&#32;the&#32;videomapping&#32;associated&#32;with&#32;this</emphasis>
9 <emphasis role="comment">#&#32;module&#32;has&#32;grayscale&#32;image&#32;outputs,&#32;so&#32;that&#32;is&#32;what&#32;you&#32;should&#32;output).</emphasis>
10 <emphasis role="comment">#</emphasis>
11 <emphasis role="comment">#&#32;@author&#32;Laurent&#32;Itti</emphasis>
12 <emphasis role="comment">#&#32;</emphasis>
13 <emphasis role="comment">#&#32;@displayname&#32;Python&#32;Tutorial&#32;1</emphasis>
14 <emphasis role="comment">#&#32;@videomapping&#32;GRAY&#32;640&#32;480&#32;20.0&#32;YUYV&#32;640&#32;480&#32;20.0&#32;JeVois&#32;PythonOpenCV</emphasis>
15 <emphasis role="comment">#&#32;@email&#32;itti\@usc.edu</emphasis>
16 <emphasis role="comment">#&#32;@address&#32;University&#32;of&#32;Southern&#32;California,&#32;HNB-07A,&#32;3641&#32;Watt&#32;Way,&#32;Los&#32;Angeles,&#32;CA&#32;90089-2520,&#32;USA</emphasis>
17 <emphasis role="comment">#&#32;@copyright&#32;Copyright&#32;(C)&#32;2017&#32;by&#32;Laurent&#32;Itti,&#32;iLab&#32;and&#32;the&#32;University&#32;of&#32;Southern&#32;California</emphasis>
18 <emphasis role="comment">#&#32;@mainurl&#32;http://jevois.org</emphasis>
19 <emphasis role="comment">#&#32;@supporturl&#32;http://jevois.org/doc</emphasis>
20 <emphasis role="comment">#&#32;@otherurl&#32;http://iLab.usc.edu</emphasis>
21 <emphasis role="comment">#&#32;@license&#32;GPL&#32;v3</emphasis>
22 <emphasis role="comment">#&#32;@distribution&#32;Unrestricted</emphasis>
23 <emphasis role="comment">#&#32;@restrictions&#32;None</emphasis>
24 <emphasis role="comment">#&#32;@ingroup&#32;modules</emphasis>
25 <emphasis role="keyword">class&#32;</emphasis>PythonTutorial1:
26 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
27 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Process&#32;function&#32;with&#32;USB&#32;output</emphasis>
28 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>process(self,&#32;inframe,&#32;outframe):
29 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Get&#32;the&#32;next&#32;camera&#32;image&#32;(may&#32;block&#32;until&#32;it&#32;is&#32;captured)&#32;and&#32;convert&#32;it&#32;to&#32;OpenCV&#32;GRAY:</emphasis>
30 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inimggray&#32;=&#32;inframe.getCvGRAY()
31 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
32 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Detect&#32;edges&#32;using&#32;the&#32;Canny&#32;algorithm&#32;from&#32;OpenCV:</emphasis>
33 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;edges&#32;=&#32;cv2.Canny(inimggray,&#32;100,&#32;200,&#32;apertureSize&#32;=&#32;3)
34 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
35 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Convert&#32;our&#32;GRAY&#32;output&#32;image&#32;to&#32;video&#32;output&#32;format&#32;and&#32;send&#32;to&#32;host&#32;over&#32;USB:</emphasis>
36 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outframe.sendCvGRAY(edges)
</computeroutput></literallayout></para>

<para>解释：</para>

<para><itemizedlist>
<listitem>
<para>第 1 行：JeVois 核心向 Python 公开了一个名为 libjevois 的库。这允许 Python 模块使用 JeVois 中编写的一些核心功能。有关详细信息，请参阅 ProgrammerPython。在这里，我们将这个库以别名 <emphasis role="bold">jevois</emphasis> 导入到我们的模块中。</para>
</listitem><listitem>
<para>第 2 行：同样，OpenCV（用 C++ 编写）公开了绑定，允许 Python 程序调用 OpenCV 的图像处理函数。这里我们也导入了该库。</para>
</listitem><listitem>
<para>第 3 行：另一个库 numpy 可用于处理数组（包括图像）。实际上，OpenCV 使用 numpy ND 数组来表示图像。</para>
</listitem><listitem>
<para>第 5-24 行：我们使用 doxygen 和 JeVois 的自定义标签来记录代码，以便根据代码中的注释自动创建一个简单的文档页面。此模块的页面位于 <link xlink:href="/moddoc/PythonOpenCV/modinfo.html">此处</link>，它是根据代码中的注释自动生成的。有关详细信息，请参阅 ProgrammerSDK。</para>
</listitem><listitem>
<para>第 25 行：我们声明一个类。其名称必须与文件名（不带 .py 扩展名）和存储此模块的目录名完全匹配。</para>
</listitem><listitem>
<para>第 28 行：JeVois 引擎需要一个名为 <computeroutput>process()</computeroutput> 的函数，它将在每个视频帧上调用该函数。引擎将为我们提供一个名为 <emphasis role="bold">inframe</emphasis> 的输入帧（C++ 类 <link linkend="_classjevois_1_1InputFrame">jevois::InputFrame</link> 的包装器，它是相机传感器帧的代理），以及一个名为 <emphasis role="bold">outframe</emphasis> 的输出帧（C++ 类 <link linkend="_classjevois_1_1OutputFrame">jevois::OutputFrame</link> 的包装器，它是可以通过 USB 发送的视频缓冲区的代理）。我们在 <computeroutput>process()</computeroutput> 函数中的任务是从通过 <emphasis role="bold">inframe</emphasis> 包装器获取的输入图像创建一个输出图像，我们将使用 <emphasis role="bold">outframe</emphasis> 包装器通过 USB 链接发送该输出图像。</para>
</listitem><listitem>
<para>第 30 行：在本教程中，我们需要一张灰度输入图像。我们从内帧中提取它。此调用可能会阻塞，直到相机传感器完成下一帧的捕获。有关更多详细信息，请参阅 jevois::InputFrame。</para>
</listitem><listitem>
<para>第 33 行：我们使用 OpenCV 检测灰度图像中的边缘，请参阅http://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html 以获得关于其工作原理的非常详细的解释。</para>
</listitem><listitem>
<para>第 36 行：我们通过 USB 将输出图像发送到主机。请注意此处如何使用 <computeroutput>sendCvGRAY()，因为我们的边缘图是灰度图。sendCvGRAY()</computeroutput> 会将灰度图转换为主机所期望的任何图像（这取决于调用我们模块的视频映射）。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title>#################################################################################################@section pysandbox 自己尝试一下：沙盒模块</title></formalpara>
</para>

<para>这里我们使用 OpenCV 的拉普拉斯检测器编写了一个简单的彩色图像过滤模块。我们将抓取一个彩色视频帧，对其应用过滤器，并将颜色结果通过 USB 发送到主机。</para>

<para>以下是完整、有效的代码。我们将逐步介绍它：</para>

<para><literallayout><computeroutput>1 <emphasis role="keyword">import</emphasis>&#32;libjevois&#32;<emphasis role="keyword">as</emphasis>&#32;jevois
2 <emphasis role="keyword">import</emphasis>&#32;cv2
3 <emphasis role="keyword">import</emphasis>&#32;numpy&#32;<emphasis role="keyword">as</emphasis>&#32;np
4 
5 <emphasis role="comment">##&#32;Simple&#32;example&#32;of&#32;image&#32;processing&#32;using&#32;OpenCV&#32;in&#32;Python&#32;on&#32;JeVois</emphasis>
6 <emphasis role="comment">#</emphasis>
7 <emphasis role="comment">#&#32;This&#32;module&#32;is&#32;here&#32;for&#32;you&#32;to&#32;experiment&#32;with&#32;Python&#32;OpenCV&#32;on&#32;JeVois.</emphasis>
8 <emphasis role="comment">#</emphasis>
9 <emphasis role="comment">#&#32;By&#32;default,&#32;we&#32;get&#32;the&#32;next&#32;video&#32;frame&#32;from&#32;the&#32;camera&#32;as&#32;an&#32;OpenCV&#32;BGR&#32;(color)&#32;image&#32;named&#32;&apos;inimg&apos;.</emphasis>
10 <emphasis role="comment">#&#32;We&#32;then&#32;apply&#32;some&#32;image&#32;processing&#32;to&#32;it&#32;to&#32;create&#32;an&#32;output&#32;BGR&#32;image&#32;named&#32;&apos;outimg&apos;.</emphasis>
11 <emphasis role="comment">#&#32;We&#32;finally&#32;add&#32;some&#32;text&#32;drawings&#32;to&#32;outimg&#32;and&#32;send&#32;it&#32;to&#32;host&#32;over&#32;USB.</emphasis>
12 <emphasis role="comment">#</emphasis>
13 <emphasis role="comment">#&#32;@author&#32;Laurent&#32;Itti</emphasis>
14 <emphasis role="comment">#&#32;</emphasis>
15 <emphasis role="comment">#&#32;@displayname&#32;Python&#32;Tutorial&#32;2</emphasis>
16 <emphasis role="comment">#&#32;@videomapping&#32;YUYV&#32;352&#32;288&#32;30.0&#32;YUYV&#32;352&#32;288&#32;30.0&#32;JeVois&#32;PythonSandbox</emphasis>
17 <emphasis role="comment">#&#32;@email&#32;itti\@usc.edu</emphasis>
18 <emphasis role="comment">#&#32;@address&#32;University&#32;of&#32;Southern&#32;California,&#32;HNB-07A,&#32;3641&#32;Watt&#32;Way,&#32;Los&#32;Angeles,&#32;CA&#32;90089-2520,&#32;USA</emphasis>
19 <emphasis role="comment">#&#32;@copyright&#32;Copyright&#32;(C)&#32;2017&#32;by&#32;Laurent&#32;Itti,&#32;iLab&#32;and&#32;the&#32;University&#32;of&#32;Southern&#32;California</emphasis>
20 <emphasis role="comment">#&#32;@mainurl&#32;http://jevois.org</emphasis>
21 <emphasis role="comment">#&#32;@supporturl&#32;http://jevois.org/doc</emphasis>
22 <emphasis role="comment">#&#32;@otherurl&#32;http://iLab.usc.edu</emphasis>
23 <emphasis role="comment">#&#32;@license&#32;GPL&#32;v3</emphasis>
24 <emphasis role="comment">#&#32;@distribution&#32;Unrestricted</emphasis>
25 <emphasis role="comment">#&#32;@restrictions&#32;None</emphasis>
26 <emphasis role="comment">#&#32;@ingroup&#32;modules</emphasis>
27 <emphasis role="keyword">class&#32;</emphasis>PythonTutorial2:
28 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
29 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Constructor</emphasis>
30 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>__init__(self):
31 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Instantiate&#32;a&#32;JeVois&#32;Timer&#32;to&#32;measure&#32;our&#32;processing&#32;framerate:</emphasis>
32 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;self.timer&#32;=&#32;<link linkend="_classjevois_1_1Timer">jevois.Timer</link>(<emphasis role="stringliteral">&quot;sandbox&quot;</emphasis>,&#32;100,&#32;jevois.LOG_INFO)
33 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
34 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
35 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Process&#32;function&#32;with&#32;USB&#32;output</emphasis>
36 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>process(self,&#32;inframe,&#32;outframe):
37 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Get&#32;the&#32;next&#32;camera&#32;image&#32;(may&#32;block&#32;until&#32;it&#32;is&#32;captured)&#32;and&#32;here&#32;convert&#32;it&#32;to&#32;OpenCV&#32;BGR&#32;by&#32;default.&#32;If</emphasis>
38 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;you&#32;need&#32;a&#32;grayscale&#32;image&#32;instead,&#32;just&#32;use&#32;getCvGRAY()&#32;instead&#32;of&#32;getCvBGR().&#32;Also&#32;supported&#32;are&#32;getCvRGB()</emphasis>
39 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;and&#32;getCvRGBA():</emphasis>
40 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inimg&#32;=&#32;inframe.getCvBGR()
41 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
42 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Start&#32;measuring&#32;image&#32;processing&#32;time&#32;(NOTE:&#32;does&#32;not&#32;account&#32;for&#32;input&#32;conversion&#32;time):</emphasis>
43 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;self.timer.start()
44 
45 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Detect&#32;edges&#32;using&#32;the&#32;Laplacian&#32;algorithm&#32;from&#32;OpenCV:</emphasis>
46 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#</emphasis>
47 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Replace&#32;the&#32;line&#32;below&#32;by&#32;your&#32;own&#32;code!&#32;See&#32;for&#32;example</emphasis>
48 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;-&#32;http://docs.opencv.org/trunk/d4/d13/tutorial_py_filtering.html</emphasis>
49 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;-&#32;http://docs.opencv.org/trunk/d9/d61/tutorial_py_morphological_ops.html</emphasis>
50 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;-&#32;http://docs.opencv.org/trunk/d5/d0f/tutorial_py_gradients.html</emphasis>
51 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;-&#32;http://docs.opencv.org/trunk/d7/d4d/tutorial_py_thresholding.html</emphasis>
52 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#</emphasis>
53 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;and&#32;so&#32;on.&#32;When&#32;they&#32;do&#32;&quot;img&#32;=&#32;cv2.imread(&apos;name.jpg&apos;,&#32;0)&quot;&#32;in&#32;these&#32;tutorials,&#32;the&#32;last&#32;0&#32;means&#32;they&#32;want&#32;a</emphasis>
54 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;gray&#32;image,&#32;so&#32;you&#32;should&#32;use&#32;getCvGRAY()&#32;above&#32;in&#32;these&#32;cases.&#32;When&#32;they&#32;do&#32;not&#32;specify&#32;a&#32;final&#32;0&#32;in&#32;imread()</emphasis>
55 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;then&#32;usually&#32;they&#32;assume&#32;color&#32;and&#32;you&#32;should&#32;use&#32;getCvBGR()&#32;here.</emphasis>
56 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#</emphasis>
57 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;The&#32;simplest&#32;you&#32;could&#32;try&#32;is:</emphasis>
58 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;&#32;&#32;&#32;outimg&#32;=&#32;inimg</emphasis>
59 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;which&#32;will&#32;make&#32;a&#32;simple&#32;copy&#32;of&#32;the&#32;input&#32;image&#32;to&#32;output.</emphasis>
60 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outimg&#32;=&#32;cv2.Laplacian(inimg,&#32;-1,&#32;ksize=5,&#32;scale=0.25,&#32;delta=127)
61 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
62 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Write&#32;a&#32;title:</emphasis>
63 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cv2.putText(outimg,&#32;<emphasis role="stringliteral">&quot;JeVois&#32;Python&#32;Sandbox&quot;</emphasis>,&#32;(3,&#32;20),&#32;cv2.FONT_HERSHEY_SIMPLEX,&#32;0.5,&#32;(255,255,255),
64 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;1,&#32;cv2.LINE_AA)
65 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
66 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Write&#32;frames/s&#32;info&#32;from&#32;our&#32;timer&#32;into&#32;the&#32;edge&#32;map&#32;(NOTE:&#32;does&#32;not&#32;account&#32;for&#32;output&#32;conversion&#32;time):</emphasis>
67 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fps&#32;=&#32;self.timer.stop()
68 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;height,&#32;width,&#32;channels&#32;=&#32;outimg.shape&#32;<emphasis role="comment">#&#32;if&#32;outimg&#32;is&#32;grayscale,&#32;change&#32;to:&#32;height,&#32;width&#32;=&#32;outimg.shape</emphasis>
69 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;cv2.putText(outimg,&#32;fps,&#32;(3,&#32;height&#32;-&#32;6),&#32;cv2.FONT_HERSHEY_SIMPLEX,&#32;0.5,&#32;(255,255,255),&#32;1,&#32;cv2.LINE_AA)
70 
71 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Convert&#32;our&#32;BGR&#32;output&#32;image&#32;to&#32;video&#32;output&#32;format&#32;and&#32;send&#32;to&#32;host&#32;over&#32;USB.&#32;If&#32;your&#32;output&#32;image&#32;is&#32;not</emphasis>
72 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;BGR,&#32;you&#32;can&#32;use&#32;sendCvGRAY(),&#32;sendCvRGB(),&#32;or&#32;sendCvRGBA()&#32;as&#32;appropriate:</emphasis>
73 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outframe.sendCvBGR(outimg)
</computeroutput></literallayout></para>

<para>解释：</para>

<para><itemizedlist>
<listitem>
<para>第 1-27 行：与上面的教程相同。</para>
</listitem><listitem>
<para>第 30 行：构造函数。在此模块中，我们将使用我们类的持久成员对象，即 JeVois 提供的 Timer（请参阅 jevois::Timer）。它将测量处理每帧所需的时间，并每 100 帧报告一次平均帧速率。由于计时器将保留在许多帧中，因此我们将其声明为我们类的成员变量，并在我们模块的构造函数中对其进行初始化。</para>
</listitem><listitem>
<para>第 32 行：我们将计时器添加为我们类的新成员变量，并对其进行初始化。</para>
</listitem><listitem>
<para>第 36 行：JeVois 引擎需要一个名为 <computeroutput>process()</computeroutput> 的函数，它将在每个视频帧上调用该函数。与上面的上一个教程相同。</para>
</listitem><listitem>
<para>第 40 行：在本教程中，我们需要一个彩色输入图像。我们从内框中提取它，作为“BGR”颜色，因为出于历史原因，这是 OpenCV 的首选颜色格式（尽管 RGB 现在在其他机器视觉库中更受欢迎）。此调用可能会阻塞，直到相机传感器完成下一帧的捕获。有关更多详细信息，请参阅 jevois::InputFrame。</para>
</listitem><listitem>
<para>第 43 行：通过 <computeroutput>process()</computeroutput> 开始测量当前运行的时间</para>
</listitem><listitem>
<para>第 60 行：我们使用 OpenCV 计算彩色图像中的拉普拉斯算子，请参阅 <link xlink:href="http://docs.opencv.org/trunk/d5/db5/tutorial_laplace_operator.html">http://docs.opencv.org/trunk/d5/db5/tutorial_laplace_operator.html</link>，其中有关于其工作原理的非常详细的解释（请注意，他们在灰度图像上运行它，而我们在这里在彩色图像上运行它）。正如在推荐中所写，此模块邀请您尝试并尝试一些其他图像过滤器（选择那些接收彩色图像并输出相同大小的彩色图像的过滤器）。事实上，本教程也作为 <emphasis role="bold">jevoisbase</emphasis> 中的模块 <link xlink:href="/moddoc/PythonSandbox/modinfo.html">Python Sandbox</link> 存在，并预装在最新的 microSD 图像上。请参阅 <link xlink:href="/tutorials">JeVois 交互式教程</link> 以获取如何使用它的示例。</para>
</listitem><listitem>
<para>第 63-64 行：在输出图像顶部附近写一个标题。有关 <computeroutput>putText()</computeroutput> 的详细信息，请参阅 <link xlink:href="http://docs.opencv.org/3.2.0/d6/d6e/group__imgproc__draw.html">http://docs.opencv.org/3.2.0/d6/d6e/group__imgproc__draw.html</link></para>
</listitem><listitem>
<para>第 67 行：告诉我们的计时器停止测量此帧的时间。当我们停止它时，它还会返回一个字符串，其中包含平均帧数/秒、CPU 使用率、CPU 温度和 CPU 频率，并且每 100 帧更新一次。在这里，我们将该信息存储到字符串 <emphasis role="bold">fps</emphasis> 中，我们将在结果顶部显示该字符串。</para>
</listitem><listitem>
<para>第 68 行：获取图像宽度、高度和通道数。这里我们需要这些信息，以便计算框架底部的 Y 坐标，我们将使用该坐标在底部附近显示文本。</para>
</listitem><listitem>
<para>第 69 行：在帧底部附近写入 fps 信息。</para>
</listitem><listitem>
<para>第 73 行：我们通过 USB 将输出图像发送到主机。请注意此处如何使用 <computeroutput>sendCvBGR()，因为我们的输出图像具有</computeroutput> BGR 颜色。sendCvBGR() 将从 BGR 转换为主机期望的任何颜色（这取决于调用我们模块的视频映射）。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title>##############################################################################################@section pylowlevel 使用 JeVois 原始图像进行更细粒度的控制</title></formalpara>
</para>

<para>在上述两个教程中，我们使用了最简单的方法，即将输入图像转换为 OpenCV，然后处理 OpenCV 图像，并将输出图像从 OpenCV 转换为将通过 USB 发送的原始图像缓冲区。虽然这对于入门来说很棒，但我们确实需要花费一些成本（即时间）来转换图像。核心 JeVois 库还公开了对相机传感器原始图像数据和将通过 USB 发送的原始输出缓冲区的低级访问。</para>

<para>这里我们编写了一个完全不使用 OpenCV 的模块。它使用直接处理原始 YUYV 图像的 JeVois 绘图函数。这样就无需从 YUYV（相机传感器原始格式）转换为 BGR，然后再转换为 YUYV（通过 USB 链接本地发送的格式）。</para>

<para>以下是完整、有效的代码。我们将逐步介绍它：</para>

<para><literallayout><computeroutput>1 <emphasis role="keyword">import</emphasis>&#32;libjevois&#32;<emphasis role="keyword">as</emphasis>&#32;jevois
2 
3 <emphasis role="comment">##&#32;Simple&#32;test&#32;of&#32;programming&#32;JeVois&#32;modules&#32;in&#32;Python</emphasis>
4 <emphasis role="comment">#</emphasis>
5 <emphasis role="comment">#&#32;This&#32;module&#32;by&#32;default&#32;simply&#32;draws&#32;a&#32;cricle&#32;and&#32;a&#32;text&#32;message&#32;onto&#32;the&#32;grabbed&#32;video&#32;frames.</emphasis>
6 <emphasis role="comment">#</emphasis>
7 <emphasis role="comment">#&#32;Feel&#32;free&#32;to&#32;edit&#32;it&#32;and&#32;try&#32;something&#32;else.&#32;Note&#32;that&#32;this&#32;module&#32;does&#32;not&#32;import&#32;OpenCV,&#32;see&#32;the&#32;PythonOpenCV&#32;for&#32;a</emphasis>
8 <emphasis role="comment">#&#32;minimal&#32;JeVois&#32;module&#32;written&#32;in&#32;Python&#32;that&#32;uses&#32;OpenCV.</emphasis>
9 <emphasis role="comment">#</emphasis>
10 <emphasis role="comment">#&#32;@author&#32;Laurent&#32;Itti</emphasis>
11 <emphasis role="comment">#</emphasis>
12 <emphasis role="comment">#&#32;@displayname&#32;Python&#32;Tutorial&#32;3</emphasis>
13 <emphasis role="comment">#&#32;@videomapping&#32;YUYV&#32;640&#32;480&#32;15.0&#32;YUYV&#32;640&#32;480&#32;15.0&#32;JeVois&#32;PythonTutorial3</emphasis>
14 <emphasis role="comment">#&#32;@email&#32;itti\@usc.edu</emphasis>
15 <emphasis role="comment">#&#32;@address&#32;University&#32;of&#32;Southern&#32;California,&#32;HNB-07A,&#32;3641&#32;Watt&#32;Way,&#32;Los&#32;Angeles,&#32;CA&#32;90089-2520,&#32;USA</emphasis>
16 <emphasis role="comment">#&#32;@copyright&#32;Copyright&#32;(C)&#32;2017&#32;by&#32;Laurent&#32;Itti,&#32;iLab&#32;and&#32;the&#32;University&#32;of&#32;Southern&#32;California</emphasis>
17 <emphasis role="comment">#&#32;@mainurl&#32;http://jevois.org</emphasis>
18 <emphasis role="comment">#&#32;@supporturl&#32;http://jevois.org/doc</emphasis>
19 <emphasis role="comment">#&#32;@otherurl&#32;http://iLab.usc.edu</emphasis>
20 <emphasis role="comment">#&#32;@license&#32;GPL&#32;v3</emphasis>
21 <emphasis role="comment">#&#32;@distribution&#32;Unrestricted</emphasis>
22 <emphasis role="comment">#&#32;@restrictions&#32;None</emphasis>
23 <emphasis role="comment">#&#32;@ingroup&#32;modules</emphasis>
24 <emphasis role="keyword">class&#32;</emphasis>PythonTTutorial3:
25 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
26 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Constructor</emphasis>
27 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>__init__(self):
28 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(<emphasis role="stringliteral">&quot;PythonTest&#32;Constructor&quot;</emphasis>)
29 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(dir(jevois))
30 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;self.frame&#32;=&#32;0&#32;<emphasis role="comment">#&#32;a&#32;simple&#32;frame&#32;counter&#32;used&#32;to&#32;demonstrate&#32;sendSerial()</emphasis>
31 
32 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
33 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Process&#32;function&#32;with&#32;no&#32;USB&#32;output</emphasis>
34 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>processNoUSB(self,&#32;inframe):
35 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LFATAL(<emphasis role="stringliteral">&quot;process&#32;no&#32;usb&#32;not&#32;implemented&quot;</emphasis>)
36 
37 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
38 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Process&#32;function&#32;with&#32;USB&#32;output</emphasis>
39 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>process(self,&#32;inframe,&#32;outframe):
40 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(<emphasis role="stringliteral">&quot;process&#32;with&#32;usb&quot;</emphasis>)
41 
42 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Get&#32;the&#32;next&#32;camera&#32;image&#32;(may&#32;block&#32;until&#32;it&#32;is&#32;captured):</emphasis>
43 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inimg&#32;=&#32;inframe.get()
44 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(<emphasis role="stringliteral">&quot;Input&#32;image&#32;is&#32;{}&#32;{}x{}&quot;</emphasis>.format(<link linkend="_group__utils_1gac76ed513027efe252fe64756fae6d0b6">jevois.fccstr</link>(inimg.fmt),&#32;inimg.width,&#32;inimg.height))
45 
46 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Get&#32;the&#32;next&#32;available&#32;USB&#32;output&#32;image:</emphasis>
47 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outimg&#32;=&#32;outframe.get()
48 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(<emphasis role="stringliteral">&quot;Output&#32;image&#32;is&#32;{}&#32;{}x{}&quot;</emphasis>.format(<link linkend="_group__utils_1gac76ed513027efe252fe64756fae6d0b6">jevois.fccstr</link>(outimg.fmt),&#32;outimg.width,&#32;outimg.height))
49 
50 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Example&#32;of&#32;getting&#32;pixel&#32;data&#32;from&#32;the&#32;input&#32;and&#32;copying&#32;to&#32;the&#32;output:</emphasis>
51 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.paste(inimg,&#32;outimg,&#32;0,&#32;0)
52 
53 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;We&#32;are&#32;done&#32;with&#32;the&#32;input&#32;image:</emphasis>
54 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;inframe.done()
55 
56 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Example&#32;of&#32;in-place&#32;processing:</emphasis>
57 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.hFlipYUYV(outimg)
58 
59 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Example&#32;of&#32;simple&#32;drawings:</emphasis>
60 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.drawCircle(outimg,&#32;int(outimg.width/2),&#32;int(outimg.height/2),&#32;int(outimg.height/2.2),&#32;2,&#32;0x80ff)
61 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.writeText(outimg,&#32;<emphasis role="stringliteral">&quot;Hi&#32;from&#32;Python!&quot;</emphasis>,&#32;20,&#32;20,&#32;0x80ff,&#32;jevois.Font.Font10x20)
62 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
63 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;We&#32;are&#32;done&#32;with&#32;the&#32;output,&#32;ready&#32;to&#32;send&#32;it&#32;to&#32;host&#32;over&#32;USB:</emphasis>
64 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outframe.send()
65 
66 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;Send&#32;a&#32;string&#32;over&#32;serial&#32;(e.g.,&#32;to&#32;an&#32;Arduino).&#32;Remember&#32;to&#32;tell&#32;the&#32;JeVois&#32;Engine&#32;to&#32;display&#32;those&#32;messages,</emphasis>
67 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;as&#32;they&#32;are&#32;turned&#32;off&#32;by&#32;default.&#32;For&#32;example:&#32;&apos;setpar&#32;serout&#32;All&apos;&#32;in&#32;the&#32;JeVois&#32;console:</emphasis>
68 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.sendSerial(<emphasis role="stringliteral">&quot;DONE&#32;frame&#32;{}&quot;</emphasis>.format(self.frame));
69 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;self.frame&#32;+=&#32;1
70 
71 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
72 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Parse&#32;a&#32;serial&#32;command&#32;forwarded&#32;to&#32;us&#32;by&#32;the&#32;JeVois&#32;Engine,&#32;return&#32;a&#32;string</emphasis>
73 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>parseSerial(self,&#32;str):
74 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;jevois.LINFO(<emphasis role="stringliteral">&quot;parseserial&#32;received&#32;command&#32;[{}]&quot;</emphasis>.format(str))
75 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;str&#32;==&#32;<emphasis role="stringliteral">&quot;hello&quot;</emphasis>:
76 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;self.hello()
77 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;ERR&#32;Unsupported&#32;command&quot;</emphasis>
78 &#32;&#32;&#32;&#32;
79 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
80 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Return&#32;a&#32;string&#32;that&#32;describes&#32;the&#32;custom&#32;commands&#32;we&#32;support,&#32;for&#32;the&#32;JeVois&#32;help&#32;message</emphasis>
81 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>supportedCommands(self):
82 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;use&#32;\n&#32;seperator&#32;if&#32;your&#32;module&#32;supports&#32;several&#32;commands</emphasis>
83 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;hello&#32;-&#32;print&#32;hello&#32;using&#32;python&quot;</emphasis>
84 
85 &#32;&#32;&#32;&#32;<emphasis role="comment">#&#32;###################################################################################################</emphasis>
86 &#32;&#32;&#32;&#32;<emphasis role="comment">##&#32;Internal&#32;method&#32;that&#32;gets&#32;invoked&#32;as&#32;a&#32;custom&#32;command</emphasis>
87 &#32;&#32;&#32;&#32;<emphasis role="keyword">def&#32;</emphasis>hello(self):
88 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="stringliteral">&quot;Hello&#32;from&#32;python!&quot;</emphasis>
89 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
</computeroutput></literallayout></para>

<para>解释：</para>

<para><itemizedlist>
<listitem>
<para>第 1-24 行：与上文相同。</para>
</listitem><listitem>
<para>第 27-30 行：构造函数。我们使用 JeVois <link linkend="_group__debugging_1gadf127ca2262cc160830da49c37d04e85">LINFO()</link> 日志记录函数打印几条消息。这些消息将被发送到硬件串行端口（如果您在 JeVois 控制台中键入“setpar serlog Hard”）、USB 串行端口（如果键入“setpar serlog USB”）或两者（如果键入“setpar serlog All”）。有关 <emphasis role="bold">serlog</emphasis> 的详细信息，请参阅 UserCli。</para>
</listitem><listitem>
<para>第 34-35 行：JeVois 还支持处理来自摄像头传感器的视频帧但不产生任何视频输出的模块。这些模块通常只会通过串行端口产生文本输出。请参阅 概念。在 C++ 中，我们有两个 process() 函数的重载，但这在 Python 中是不可能的，因此这两个函数采用不同的名称：process() 和 processNoUSB()。在这里，我们没有实现仅接受摄像头图像的 <computeroutput>processNoUSB()</computeroutput> 函数，但我们为其提供了一个框架。在几个 <emphasis role="bold">jevoisbase</emphasis> C++ 模块中提供了此函数实现的示例。在 <link linkend="_UserDemos">捆绑视觉模块和演示的用户指南</link> 下查找声称<emphasis>​​支持无 USB 输出映射</emphasis>的模块以了解详细信息（例如，DemoArUco）。</para>
</listitem><listitem>
<para>第 39 行：这是我们的 <computeroutput>process()</computeroutput> 函数，将视频输出到 USB。</para>
</listitem><listitem>
<para>第 43 行：我们从相机传感器获取原始视频帧。根据我们推荐的视频映射（参见第 13 行的注释），我们预计这将是 YUYV。有关像素格式和视频映射的复习，请参阅 UserModes。此处 <computeroutput>get()</computeroutput> 返回的对象是 Python 包装的 <link linkend="_classjevois_1_1RawImage">jevois::RawImage</link> 对象。它包含指向 Linux 内核中分配的内存缓冲区的直接指针，相机传感器使用直接内存访问 (DMA) 将像素信息填充到该缓冲区中。因此，jevois::RawImage 是一个<emphasis>轻量级</emphasis>对象，它只保存指向像素数据的共享指针，并假定拥有该数据的副本。因此，与上面的教程不同，到目前为止，我们对来自相机传感器的原始像素数组没有进行任何复制或转换。这非常快。</para>
</listitem><listitem>
<para>第 47 行：我们还将输出视频缓冲区作为原始 YUYV <link linkend="_classjevois_1_1RawImage">jevois::RawImage</link> 获取。这里，RawImage 再次直接指向 Linux 内核分配的原始像素缓冲区，该缓冲区将直接用于通过 DMA 通过 USB 链路传输数据。非常高效的零拷贝访问。</para>
</listitem><listitem>
<para>第 51 行：在本教程模块中，我们首先将相机传感器中的像素复制到输出原始缓冲区中，以便用户可以看到相机所看到的内容。在更复杂的场景中，输入缓冲区可以复制到输出缓冲区内的一个小窗口（例如，如 中所示），或者可能根本不复制，只是以某种方式处理以产生将要发送的计算输出图像（例如，从输入图像计算边缘图）。因此，我们在这里只需将 <emphasis role="bold">inimg</emphasis> 粘贴到 <emphasis role="bold">outimg</emphasis> 中，从 <emphasis role="bold">outimg</emphasis> 中的左上角 (0,0) 位置开始。</para>
</listitem><listitem>
<para>第 54 行：从此点开始，我们将只处理输出图像，这样我们就可以释放输入图像，以便其缓冲区被回收到相机传感器内核驱动程序，以用于后续帧捕获。通常，最好尽早将输入帧标记为已完成，以便其缓冲区尽早可供相机传感器使用。</para>
</listitem><listitem>
<para>第 57 行：JeVois 核心提供了许多可直接在 YUYV 图像上进行的操作。例如，在这里，我们将输出图像水平翻转。有关更多操作，请参阅 image。</para>
</listitem><listitem>
<para>第 60-61 行：JeVois 核心还提供了可直接处理 YUYV 图像的简单绘图函数。同样，请参阅 <link linkend="_group__image">Raw 零拷贝/内存映射视频图像和支持函数</link> 了解详情。在这里，我们只画一个圆圈并写入一条文本消息。</para>
</listitem><listitem>
<para>第 64 行：一旦我们完成并确定输出图像，我们就可以通过 USB 将其发送到主机。在输出帧上对 <computeroutput>send()</computeroutput> 的调用是可选的，当 <computeroutput>process()</computeroutput> 结束时，它无论如何都会被调用。</para>
</listitem><listitem>
<para>第 68 行：这是将文本字符串发送到 <emphasis role="bold">serout</emphasis> 串行端口的示例，例如用于连接到 JeVois 的 Arduino。引擎参数 <emphasis role="bold">serout</emphasis> 决定该字符串将去往何处（硬件串行端口、USB 串行、无或两者）。请注意，默认情况下它不会去往任何端口。您需要在 JeVois 控制台（或配置文件中）发出“setpar serout Hard”以将输出发送到硬件串行端口。有关 <emphasis role="bold">serout</emphasis> 的更多信息，请参阅 UserCli。</para>
</listitem><listitem>
<para>第 69 行：我们增加内部帧计数器，此帧的处理已完成。JeVois 引擎将在下一帧再次调用 <computeroutput>process()。</computeroutput> </para>
</listitem><listitem>
<para>第 73-77 行：模块可以选择支持自定义命令，这些命令添加到 JeVois 引擎已经解释的命令中。这是通过在模块中实现 <computeroutput>parseSerial()</computeroutput> 函数来实现的。JeVois 引擎会将通过命令行界面收到的任何无法识别的命令转发给该函数。在这里，我们支持一个新命令 <computeroutput>hello，它将调用我们模块的</computeroutput> <computeroutput>hello()</computeroutput> 成员函数（第 87-88 行）。<computeroutput>parseSerial()</computeroutput> 函数应返回一个字符串，形式为“OK”或“ERR some error message”，或者它可能抛出一个异常（引擎将捕获该异常并以以“ERR ”开头的消息报告）。引擎会将此处返回的任何字符串转发到适当的 <emphasis role="bold">serlog</emphasis> 串行端口（有关 <emphasis role="bold">serlog</emphasis> 的详细信息，请参阅 UserCli）。</para>
</listitem><listitem>
<para>第 81-83 行：如果我们支持自定义命令，则应通过在 <computeroutput>帮助消息中描述它们来让用户知道。这是通过在模块中实现成员函数</computeroutput> <computeroutput>supportsCommands(self)</computeroutput> 来实现的。当用户在命令行界面中键入 <computeroutput>help</computeroutput> 时，引擎将调用它。此函数应返回一个包含命令名称和简要说明的字符串。如果模块支持多个命令，则仅返回一个字符串，并使用换行符 \n 分隔不同的命令。</para>
</listitem><listitem>
<para>第 87-88 行：这是当用户在命令行界面上输入 <computeroutput>hello</computeroutput> 时调用的模块成员函数。</para>
</listitem></itemizedlist>
</para>

<para><formalpara><title>##############################################################################################@section pymoremoduletutorial 更多模块教程和示例</title></formalpara>
</para>

<para>更多信息请参见：</para>

<para><itemizedlist>
<listitem>
<para><link xlink:href="/basedoc/">JeVoisBase 模块集合的文档</link>，查找用 Python 编写的文档（每个模块文档页面顶部的语言字段）。</para>
</listitem><listitem>
<para><link xlink:href="/tutorials/">JeVois 教程</link> </para>
</listitem></itemizedlist>
</para>
</section>
</section>
    <section xml:id="_Debugging"><title>调试 JeVois 软件</title>    </section><section xml:id="_Debugging_1autotoc_md27">
<title>在主机上调试</title>

<para>在 JeVois 上调试新的机器视觉模块的最简单方法是首先在您的桌面（主机）计算机上编译并运行它们（参见 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> 和 <link linkend="_CompilingJeVoisBase">从源代码编译 JeVoisBase 软件</link> ）。</para>

<para>当您在主机上运行 <emphasis role="bold">jevois-daemon</emphasis> （参见 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> ）时，错误消息将打印在您启动它的终端窗口中。</para>

<para>您还可以在 <emphasis role="bold">gdb</emphasis> （GNU 调试器）中运行 <emphasis role="bold">jevois-daemon</emphasis> 并查看它可能在哪里崩溃。</para>

<para>有时，由于我们在 JeVois 中使用了大量线程，因此运行效果不佳。您可以改为通过启用 coredump、运行 jevois-daemon 直到其崩溃，然后使用 gdb 检查 core 文件来进行离线调试。有关详细信息，请参阅 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> 。</para>
<section xml:id="_Debugging_1autotoc_md28">
<title>调试编译器和链接器错误</title>

<para>编译错误报告得相当详细。但链接器错误更难调试。如果您最终收到有关缺少库的错误消息，则查看哪个链接器命令被准确调用以及其中指定的所有路径很有用，以检查库丢失的原因。</para>

<para>CMake 允许您通过指定 <computeroutput>VERBOSE=1</computeroutput> 作为 make 选项切换到详细模式。因此，如果您收到缺少库的错误，那么</para>

<para><literallayout><computeroutput>cd hbuild/ # or pbuild/, phbuild/, etc
make VERBOSE=1
</computeroutput></literallayout></para>

<para>这将向您显示已运行的链接器命令。然后您可以查看所有 <computeroutput>-L...</computeroutput> 参数并检查 CMakeList.txt 以了解未找到库的原因。</para>
</section>
<section xml:id="_Debugging_1autotoc_md29">
<title>启用调试级别消息</title>

<para>您可以在编译 jevois 时打开 CMake 标志 <computeroutput>JEVOIS_LDEBUG_ENABLE</computeroutput> 和 <computeroutput>JEVOIS_TRACE_ENABLE</computeroutput> 以启用超详细调试消息（请参阅 <link linkend="_CompilingJeVois">从源代码编译 JeVois 核心软件</link> ）。请注意，这些标志仅允许编译这些消息。要查看它们，您还需要在运行时将参数 <computeroutput>loglevel</computeroutput> 设置为 <computeroutput>debug</computeroutput> （请参阅 <link linkend="_UserCli">命令行界面用户指南</link> ）。</para>

<para>如果您更改这些标志，则必须重新编译所有内容（重新编译 jevois、jevoisbase、您的模块等）。</para>
</section>
</section>
<section xml:id="_Debugging_1autotoc_md30">
<title>JeVois-Pro：在平台硬件上调试</title>

<para> 最简单的调试工作流程可能是：</para>

<para><itemizedlist>
<listitem>
<para>按照 <link linkend="_ProUserQuick">JeVois-Pro 快速入门用户指南</link> 中的说明切换到控制台启动</para>
</listitem><listitem>
<para>启用核心转储并运行 <computeroutput>jevoispro.sh</computeroutput>，然后使用 <computeroutput>gdb</computeroutput> 查找错误，按照 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> 中的说明</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_Debugging_1autotoc_md31">
<title>JeVois-A33：调试平台硬件上的启动过程</title>

<para>如果您正在修改 JeVois 智能相机硬件上的低级软件，并且在启动时遇到困难，您可以启用启动消息。这要求您在启动期间连接到 JeVois 4 针硬件串行端口，因为启动消息将发送到该串行端口。这对于解决任何启动问题非常有用，甚至可以在智能相机启动时进入登录提示符而不是自动启动 <emphasis role="bold">jevois-daemon。</emphasis> </para>

<para>这需要您将 JeVois 相机的 4 针串行端口连接到终端。您可以使用：</para>

<para><itemizedlist>
<listitem>
<para>USB 转串口电缆或 dongle（也称为 FTDI 电缆或 USBISP dongle 等）。然后按照 <link linkend="_UserSerial">串口使用指南</link> 中所示进行连接，并使用 <emphasis role="bold">screen</emphasis> 、<emphasis role="bold">HyperTerminal</emphasis> 等与其通信（请参阅 <link linkend="_UserCli">命令行界面用户指南</link> ，但将其中的 <emphasis role="bold">ttyACM0</emphasis> 替换为 <emphasis role="bold">ttyUSB0</emphasis> 或将 USB 转串口适配器插入主机时由 <emphasis role="bold">dmesg</emphasis> 命令创建和报告的任何设备）。</para>
</listitem><listitem>
<para>Arduino 或其他微控制器</para>
</listitem><listitem>
<para>任何其他提供 TTL 级串行终端的设备</para>
</listitem></itemizedlist>
</para>

<para>然后你可以：</para>

<para><itemizedlist>
<listitem>
<para>编辑 microSD 上的 <emphasis role="bold">BOOT:uEnv.txt</emphasis> ，以启用向串行端口发送详细启动消息</para>
</listitem><listitem>
<para>创建一个空文件 <emphasis role="bold">BOOT:login</emphasis> ，JeVois 相机启动时会检测到该文件。如果该文件存在，<emphasis role="bold">jevois-daemon</emphasis> 将不会自动启动，而是会在串行控制台上收到登录提示。用户名是 <emphasis role="bold">root</emphasis> ，没有密码。登录后，您可以通过运行 <emphasis role="bold">/usr/bin/jevois.sh</emphasis> 手动启动 JeVois 软件，就像它会自动启动一样。</para>
</listitem><listitem>
<para>如果您出于某种原因不想启动 USB 串行功能，请创建一个空文件 <emphasis role="bold">BOOT:nousbserial</emphasis> 。</para>
</listitem><listitem>
<para>如果您希望在 4 针硬件串行端口而不是 JeVois 控制台上获取登录提示，请 创建一个空文件 <emphasis role="bold">BOOT:serialtty</emphasis> 。</para>
</listitem><listitem>
<para>如果您希望在串行 USB 端口而不是 JeVois 控制台上获取登录提示，请创建一个空文件 <emphasis role="bold">BOOT:usbserialtty</emphasis> 。如果 <emphasis role="bold">BOOT:nousbserial</emphasis> 也存在，则无效。</para>
</listitem><listitem>
<para>如果您出于某种原因不想启用 microSD-over-USB 功能，请 创建一个空文件 <emphasis role="bold">BOOT:nousbsd</emphasis> 。</para>
</listitem><listitem>
<para> 如果您希望在启动时自动通过 USB 导出 microSD JEVOIS 分区，请创建一个空文件 <emphasis role="bold">BOOT:usbsdauto</emphasis> 。请注意，这将强制 JEVOIS 分区在设备端为只读（并且它将在主机上可读写），即 JeVois 处理器将无法 1) 编译 python 模块，2) 将任何视频文件或其他数据写入 microSD。</para>
</listitem><listitem>
<para> 创建一个空文件 <emphasis role="bold">BOOT:multicam</emphasis> 以降低 JeVois 请求的 USB 带宽。这将允许您将最多 3 个 JeVois 相机连接到单个 USB 端口（通过集线器）。默认情况下，JeVois 请求所有可用的 USB 同步带宽，以最大限度地减少主机图像捕获和图像接收之间的延迟。有关更多详细信息，请参阅 <link linkend="_Multicam">JeVois-A33 通过连接到一个 USB 总线的多个 JeVois 摄像机流式传输视频</link> 。</para>
</listitem><listitem>
<para> 创建一个空文件 <emphasis role="bold">BOOT:quietcmd</emphasis> ，以禁止在命令行上收到每个成功命令后向用户发送 &apos;OK&apos;。仅推荐高级用户使用。</para>
</listitem><listitem>
<para> 创建一个空文件 <emphasis role="bold">BOOT:nopython</emphasis> 禁用对用 python 编写的模块的支持。激活后，尝试加载 python 模块将引发异常。禁用 python 可节省大量内存，在使用运行大型深度神经网络的 C++ 模块时可能很有用。</para>
</listitem><listitem>
<para>编辑文件 <emphasis role="bold">~/jevois/bin/jevois.sh</emphasis>，该文件将作为 <emphasis role="bold">LINUX:/usr/bin/jevois.sh</emphasis> 安装到 microSD，例如在 <emphasis role="bold">gdb</emphasis> 中启动 <emphasis role="bold">jevois-daemon</emphasis> （参见 <link linkend="_JeVoisDaemon">jevois-daemon 可执行文件</link> ）。</para>
</listitem></itemizedlist>
</para>

<para></para>

<para>另请查看此视频（有些旧了，现在看起来可能有点不同）：</para>

<para> </para>
</section>
    <section xml:id="_ProgrammingGuidelines"><title>JeVois 核心框架贡献者的通用编程指南</title>    </section>
<para><note><title>Note</title>

<para>这些编程指南适用于希望为核心 JeVois 框架 (libjevois.so) 做出贡献的程序员，并且非常严格。对于只想编写使用 JeVois 核心框架的新机器视觉模块的程序员，指导方针要宽松得多，并在 jevoisbase 的文档中进行了描述。</para>
</note>
</para>
<section xml:id="_ProgrammingGuidelines_1general">
<title>一般规则和缩进</title>

<para><itemizedlist>
<listitem>
<para>JeVois 使用 doxygen 进行文档编制，使用感叹号 (!) 注释样式。在开始编写代码之前，您应该了解 doxygen 并查看 JeVois 其余部分的文档编制方式。未记录或记录不当的代码可能会被删除。另请参阅<link xlink:href="DocumentationRules.html">此处</link>，了解有关棘手文档案例的更多解释（一旦您了解 doxygen 的基础知识）。</para>
</listitem><listitem>
<para>JeVois 将所有警告视为错误。因此，如果有警告，您的代码将无法编译。这是一个功能：如果您的代码有警告，则说明您做错了！如果您包含的文件来自不是您编写的库，并且有警告，则可以使用以下命令： <literallayout><computeroutput>JEVOIS_BEGIN_UNCHECKED_INCLUDES
#include&#32;&lt;trashystuff.h&gt;
JEVOIS_END_UNCHECKED_INCLUDES
</computeroutput></literallayout></para>
</listitem><listitem>
<para>源代码行长度为 120。将其添加到您的 <emphasis role="bold">~/.emacs</emphasis> 进行设置：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>  ;; set default line wrap len:
  (setq default-fill-column 120)</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>JeVois 使用 astyle 来确保我们各种文本编辑器的缩进样式统一。JeVois 中包含一个样式文件，可以在 jevois/scripts/astylerc 中找到。要使用此样式文件，请使用 –options 标志调用 astyle，例如 <literallayout><computeroutput>astyle&#32;myfile&#32;--options=/path/to/jevois/scripts/astylerc
</computeroutput></literallayout></para>
</listitem><listitem>
<para>符合此样式的缩进由以下 emacs 规则定义，位于 emacs 缩进的默认 C 模式之上（将其添加到 <computeroutput>~/</computeroutput>.emacs 以激活）： <literallayout><computeroutput>  ;; JeVois indentation style for C++ and such
  (defun my-c-mode-common-hook ()
    (local-set-key &quot;\C-h&quot; &apos;backward-delete-char)
    ;; this will make sure spaces are used instead of tabs
    (setq tab-width 4 indent-tabs-mode nil)
    (setq indent-tabs-mode &apos;nil)
    (setq c-basic-offset 2)
    (c-set-offset &apos;substatement-open 0)
    (c-set-offset &apos;statement-case-open 0)
    (c-set-offset &apos;case-label 0)
    (c-set-offset &apos;brace-list-open 0)
    (c-set-offset &apos;access-label -2)
    (c-set-offset &apos;inclass 4)
    (c-set-offset &apos;member-init-intro 4)
    ;; include possible ! as comment start string so that indentation starts after it
    (setq comment-start-skip &quot;/\\*+!* *\\|//+ *&quot;)
     
    ;; type C-c C-s or C-c C-o while editing to see what other rules to add here...
  )
  
  (add-hook &apos;c-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;c++-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;perl-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;cperl-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;emacs-lisp-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;nroff-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;tcl-mode-hook &apos;my-c-mode-common-hook)
  (add-hook &apos;makefile-mode-hook &apos;my-c-mode-common-hook)</computeroutput></literallayout></para>
</listitem><listitem>
<para>如果您使用 vi，请使用以下配置： <literallayout><computeroutput>  &quot;-------------Essential JeVois Style Compliance Settings-------------
   
  &quot; Disable old-school vi compatability
  set nocompatible
  
  &quot; Allow plugins to control our indentation
  filetype plugin indent on
  
  &quot; Set each auto-indent level to equal two spaces
  set shiftwidth=2
  
  &quot; Let each tab equal two spaces
  set tabstop=2
  
  &quot; Make sure vim turns all tabs into spaces
  set expandtab
  
  &quot; Make vim indent our code properly
  set smartindent
  
  &quot; Make the maximum line length equal 120
  set textwidth=120
  
  &quot;-------------Other cool vim tricks-------------
  
  &quot; Use a cool menu when autocompleting filenames, commands, etc...
  set wildmenu
  set wildmode=list:longest
  
  &quot; Make vim automatically change directories to the directory of any file you open. 
  &quot; This means that when you open a file, then want to open another using :tabe, :o, etc,
  &quot; you can just type in the relative path from the file you&apos;re currently editing.
  set autochdir
  
  &quot; When editing the JeVois library, it is a total pain when you are editing a .H file in jevois/include/whatever/whatever, 
  &quot; and then decide you need to edit the source .C file in the jevois/src/whatever/whatever. This little function will 
  &quot; automatically back track in the directory tree for you, find the corresponding .C or .H file, and open it in a new
  &quot; tab. 
  &quot; To use it, just type ,o (that&apos;s a comma, and then a lower-case o). 
  function! OpenOther()
    if expand(&quot;%:e&quot;) == &quot;C&quot;
      exe &quot;tabe&quot; fnameescape(expand(&quot;%:p:r:s?src?include?&quot;).&quot;.H&quot;)
    elseif expand(&quot;%:e&quot;) == &quot;H&quot;
      exe &quot;tabe&quot; fnameescape(expand(&quot;%:p:r:s?include?src?&quot;).&quot;.C&quot;)
    endif
  endfunction
  nmap ,o :call OpenOther()&lt;CR&gt;</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammingGuidelines_1fileorg">
<title>文件组织</title>

<para><itemizedlist>
<listitem>
<para>JeVois 对 C++ 文件仅使用文件扩展名 .H 和 .C。</para>
</listitem><listitem>
<para>JeVois 使用 CamelCase 约定作为文件名和类名。模板元编程使用的辅助类是个例外，它们通常使用小写加下划线的名称，以类似于 STL（请参阅下文了解更多详细信息）。</para>
</listitem><listitem>
<para>JeVois 库主要分为 jevois/include/jevois/ 和 jevois/src/jevois/ 目录。然后这些目录进一步分为 Core、Debug、Image 等。构建系统从这些文件创建共享库 libjevois.so。视觉模块程序员通过在 jevois/include 下包含适当的头文件 (.H) 并链接到 libjevois.so（详情如下）来使用 JeVois 库。在添加到核心 JeVois 框架时（而不是仅仅编写新的视觉模块），请记住：<itemizedlist>
<listitem>
<para>jevois/ 下的每个目录都应包含可以逻辑分组在一起的文件 - 例如，Debug 目录用于调试函数和类，Image 用于图像处理等。每个目录都包含一组实现特定功能的类。</para>
</listitem><listitem>
<para>所有头文件必须以 .H 扩展名命名，并应放入包含目录中。应拆分头文件，以便用户不需要知道的所有后端功能都隐藏在 <computeroutput>details</computeroutput> 子目录中。通常，此类后端功能可以拆分为 Helpers 文件（包含任何帮助程序类，可包含在类定义主体之前）和 Impl 实现文件（包含任何内联代码）。例如，Parameter 框架涉及 jevois/include/jevois/Component/Parameter.H 中的主要定义和编程接口，它依赖于 jevois/include/jevois/Component/details/ParameterHelpers.H 中定义的一些帮助程序类（使用 Parameter 的程序员不需要知道），并且具有 jevois/include/jevois/Component/details/ParameterImpl.H 中定义的一些内联实现代码（使用 Parameter 的程序员也不需要知道）。这种组织方式使得生成省略所有令人讨厌的实施细节的用户文档变得容易。</para>
</listitem><listitem>
<para>所有非内联、非模板实现源文件都应以 .C 扩展名命名，并应按照与其 .H 文件相同的相对路径进入 jevois/src/ 目录。</para>
</listitem><listitem>
<para>应将尽可能多的代码移入 .C 文件，这样用户就不必一遍又一遍地重新编译我们的 .H 文件。模板代码是例外，在大多数情况下必须将其移入 .H 文件。</para>
</listitem><listitem>
<para>所有头文件和源文件都应包含样板序言/许可证。只需从另一个文件复制即可。</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>类成员变量的名称以 &quot;its&quot; 开头，以便向阅读代码的人表明它们是成员变量。</para>
</listitem><listitem>
<para>JeVois 成员函数使用以小写字母开头的 camelCase。</para>
</listitem><listitem>
<para>JeVois free 函数通常使用 name_with_underscores，或者以小写字母开头的 camelCase。</para>
</listitem><listitem>
<para>一般而言，每个类一个文件。文件名和类名必须完全匹配。如果几个类在概念上属于同一类，那么可以将它们放在同一个文件中。</para>
</listitem><listitem>
<para>所有 .H 文件都使用包含保护，这将防止文件被多次包含，从而产生一些关于重新定义内容的错误。没有 .C 文件使用包含保护。我们使用 g++ 支持的编译指示来包含保护：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>#pragma&#32;once

//&#32;....
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>因此，一个新类通常涉及以下一组文件：<itemizedlist>
<listitem>
<para><computeroutput>include/jevois/XXX/MyClass.H</computeroutput> ：仅包含声明和文档。绝对没有实际的实现代码。仅在此文件中声明将使用您的类且不需要关心其内部工作原理的程序员感兴趣的内容。此文件中的所有内容都应使用 doxygen 标记进行记录。</para>
</listitem><listitem>
<para><computeroutput>include/jevois/XXX/details/MyClassHelpers.H</computeroutput> ：包含 MyClass.H 中的主要声明生效之前必须知道的支持声明。例如，如果最终用户只使用派生类，而基类不包含他们应该关心的信息，则在 details/MyClassHelpers.H 中声明基类，并在 MyClass.H 的顶部包含 details/MyClassHelpers.H。此文件中没有 doxygen 标记，文档是可选的，主要面向高级程序员。</para>
</listitem><listitem>
<para><computeroutput>include/jevois/XXX/details/MyClassImpl.H</computeroutput> ：仅包含内联和模板实现。此文件中没有 doxygen 标记，文档是可选的，主要面向高级程序员。</para>
</listitem><listitem>
<para><computeroutput>src/jevois/XXX/MyClass.C</computeroutput> ：包含所有非模板、非内联实现。文档是可选的。</para>
</listitem></itemizedlist>
</para>

<para>例如参见以下文件：<itemizedlist>
<listitem>
<para>jevois/include/jevois/Component/details/ParameterHelpers.H 准备工作对只使用 JeVois 框架的程序员来说毫无意义</para>
</listitem><listitem>
<para>jevois/include/jevois/Component/Parameter.H 为使用 JeVois 框架的程序员提供文档接口</para>
</listitem><listitem>
<para>jevois/include/jevois/Component/details/ParameterImpl.H 内联函数和模板实现对仅使用 JeVois 框架的程序员来说毫无意义</para>
</listitem><listitem>
<para>jevois/src/jevois/Component/Parameter.C 不存在，因为 Parameter 是一个完全模板化、完全内联的类，但可能包含任何非模板、非内联的实现，而这些实现对于仅使用 JeVois 框架的程序员来说毫无意义</para>
</listitem></itemizedlist>
</para>
</listitem><listitem>
<para>要在 JeVois 源代码中查找特定单词，我们建议将以下宏添加到您的 <computeroutput>~/.bash_aliases</computeroutput> 或 <computeroutput>~/.bashrc</computeroutput>： <literallayout><computeroutput># do a grep on c sources (e.g., for kernel, u-boot, etc) or c++ sources (for JeVois, NRT, etc)
xg () {
   grep $* `find . -name &quot;*.[hcHC]&quot;`
}
</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>

<para>您可以按如下方式使用它，例如，查找引用 JeVois 提供的函数 <computeroutput><link linkend="_group__debugging_1gac5f7014e430b19db36d4284254f886ef">warnAndRethrowException()</link></computeroutput> 的所有文件，该函数可帮助程序员处理异常：<literallayout><computeroutput>itti@iLab1:~/jevois/software/jevois$ xg warnAndRethrowException ./include/jevois/Debug/Log.H: try { do_something_risky(); } catch (...) { jevois::warnAndRethrowException(); } ./include/jevois/Debug/Log.H: void warnAndRethrowException[[noreturn]](); ./src/jevois/Debug/Log.C:void jevois::warnAndRethrowException() </computeroutput></literallayout> 显示它是在 Log.H 中声明并在 <link linkend="_Log_8C">Log.C</link> 中实现的，因此您现在可以打开这些文件以获取更多信息。</para>
</section>
<section xml:id="_ProgrammingGuidelines_1constcorr">
<title>Const 正确性</title>

<para>JeVois 专门使用从右到左的约定来限定 const 限定符。这是因为这是清楚地阅读包含 const 的语句的最佳方式，只需从右到左大声朗读即可。例如：</para>

<para><literallayout><computeroutput>int&#32;const&#32;*&#32;prt1;&#32;//&#32;ptr1&#32;是指向&#32;const&#32;int&#32;的指针（从右向左读取；可以改变指针地址，但不能改变指向的&#32;int&#32;值）&#32;
int&#32;*&#32;const&#32;ptr2;&#32;//&#32;ptr2&#32;是指向&#32;int&#32;的&#32;const&#32;指针（不能改变地址，但可以改变&#32;int&#32;值）&#32;
int&#32;const&#32;*&#32;const&#32;ptr3;&#32;//&#32;ptr3&#32;是指向&#32;const&#32;int&#32;的&#32;const&#32;指针（const&#32;地址，const&#32;值）&#32;
</computeroutput></literallayout></para>

<para>有关更多详细信息和示例，请参阅 <link xlink:href="http://en.wikipedia.org/wiki/Const-correctness">http://en.wikipedia.org/wiki/Const-correctness</link>。另请参阅此文：http://www.dansaks.com/articles/1999-02%20const%20T%20vs%20T%20const.pdf 和此文：http://www.parashift.com/c++-faq-lite/const-correctness.html</para>

<para><itemizedlist>
<listitem>
<para>JeVois 是 const 正确的代码（除了错误和遗漏！）。编写 jevois 代码时，请确保它是 const 正确的。例如：<itemizedlist>
<listitem>
<para>函数的输入参数通常由 const 引用接收。例如： <literallayout><computeroutput>void&#32;myfunc(std::string&#32;const&#32;&amp;&#32;arg);
</computeroutput></literallayout></para>
</listitem><listitem>
<para>不修改对象任何成员变量的成员函数应声明为 const。例如： <literallayout><computeroutput>class&#32;MyClass&#32;
{
&#32;public:
&#32;&#32;int&#32;getX()&#32;const&#32;
&#32;&#32;{&#32;return&#32;x;&#32;}&#32;//&#32;由于我们不修改&#32;x&#32;或&#32;MyClass&#32;中的任何其他内容，因此&#32;getX()&#32;被声明为&#32;const&#32;
&#32;private:
&#32;&#32;int&#32;x;&#32;}&#32;
</computeroutput></literallayout></para>
</listitem><listitem>
<para>不会被修改的临时变量应声明为 const。例如： <literallayout><computeroutput>double&#32;const&#32;perimeter&#32;=&#32;2.0&#32;*&#32;M_PI&#32;*&#32;radius;&#32;//&#32;假设周长以后不会被修改&#32;
</computeroutput></literallayout></para>
</listitem><listitem>
<para>类中的互斥锁通常应声明为 <computeroutput>mutable</computeroutput> ，这将允许它在类的 const 实例或类的 const 成员函数中被锁定/解锁。</para>
</listitem><listitem>
<para>对于函数的返回值：如果可能，返回一个 const ref（即，您正在返回一个不会很快消失的 const ref，通常在返回类的数据成员之一时将其用于类的访问器函数），否则按值返回（非常量）。虽然按非常量值返回可能会带来危险，但它也允许移动语义。如果您返回向量、字符串等，这一点尤其重要，因为通过按非常量值返回它，它实际上将被移动（在大多数情况下），而不是复制。</para>
</listitem><listitem>
<para>在极少数情况下，如果从逻辑上讲这更有意义，则更希望将成员函数保持为 const，即使它可能会修改类的一些成员非可变变量。您必须对这些情况做出判断，并在函数内部使用 <computeroutput>const_cast</computeroutput> 。例如，考虑 Component 中 className() 访问器函数的实现，该函数返回组件类的名称。itsClassName 在 Component.H 中声明为 Component 的 const 字符串数据成员，这是有道理的，因为任何 Component 的类名都不能修改。对于所有 const 数据成员，为 itsClassName 赋值的唯一方法是在构造期间。但我们希望报告从 Component 派生的任何类的类名，而该类名在基 Component 类的构造期间是无法访问的。出于这个原因，我们将在第一次请求时设置类名（此时我们知道从 Component 派生的对象将被完全构造）： <literallayout><computeroutput>std::string&#32;const&#32;&amp;&#32;jevois::Component::className()&#32;const&#32;
{
&#32;&#32;boost::shared_lock&lt;boost::shared_mutex&gt;&#32;lck(itsMetaMtx);

&#32;&#32;//&#32;我们需要完全构造（派生！）组件以使&#32;demangle&#32;正常工作，因此这里有&#32;const_cast：
&#32;&#32;if&#32;(itsClassName.empty())&#32;*(const_cast&lt;std::string&#32;*&gt;(&amp;itsClassName))&#32;=&#32;jevois::demangle(typeid(*this).name());

&#32;&#32;return&#32;itsClassName;&#32;}&#32;
</computeroutput></literallayout> 因此我们使用 <computeroutput>const_cast</computeroutput> 在第一次请求时设置 const 成员变量 itsClassName。</para>
</listitem><listitem>
<para>有关更多详细信息和示例，请参阅http://en.wikipedia.org/wiki/Const-correctness。</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammingGuidelines_1localvar">
<title>局部变量</title>

<para><itemizedlist>
<listitem>
<para>局部变量名应该选择较长、更具描述性的名称，而不是较短的名称。例如</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>//&#32;Bad...
for&#32;(int&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;c;&#32;++i);
&#32;
//&#32;Better...
for&#32;(int&#32;itemIdx&#32;=&#32;0;&#32;itemIdx&#32;&lt;&#32;itemCount;&#32;++itemIdx);
</computeroutput></literallayout></para>
</section>
<section xml:id="_ProgrammingGuidelines_1useinline">
<title>正确使用 inline、virtual、override、final 等</title>

<para><itemizedlist>
<listitem>
<para>在声明中，不要写 inline（例如，在类声明中）。Inline 是一个实现细节，只看你的接口（声明）的人不应该被它打扰。</para>
</listitem><listitem>
<para>在定义（函数的实现）中，这是添加 inline 的正确位置。对于模板函数，将 inline 添加到与模板相同的行。</para>
</listitem></itemizedlist>
</para>

<para>例子：</para>

<para><literallayout><computeroutput>template&#32;&lt;class&#32;T&gt;
class&#32;Stuff
{
&#32;&#32;public:
&#32;&#32;&#32;&#32;void&#32;doit();&#32;&#32;&#32;//&#32;NO&#32;INLINE&#32;HERE&#32;IN&#32;DECLARATION
};

...

//&#32;IN&#32;IMPLEMENTATION&#32;FILE:
template&#32;&lt;class&#32;T&gt;&#32;inline
Stuff&lt;T&gt;::doit()
{&#32;...&#32;}
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>virtual、override、final 的规则与 inline 相反：在声明中指定它（类的用户需要知道什么是虚拟的，并且可以安全地由派生类重新实现），从定义中省略它（一旦函数被声明为虚拟的，它就会保持这种状态）。</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_ProgrammingGuidelines_1capi">
<title>大小写规则</title>

<para><itemizedlist>
<listitem>
<para>类名应该以大写字母开头，采用 CamelCase 命名法，例如：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>class&#32;MyCoolClass;
class&#32;ImageSegmenter;
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>变量应采用驼峰式命名法，以小写字母开头，例如 <literallayout><computeroutput>bool&#32;isRunning;
size_t&#32;arraySize;
</computeroutput></literallayout></para>
</listitem><listitem>
<para>成员变量应采用驼峰命名法 (camelCase)，以前缀 &quot;its&quot; 开头，例如：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>class&#32;MyClass
{
&#32;&#32;size_t&#32;itsCounter;
&#32;&#32;std::vector&lt;int&gt;&#32;itsStorage;
}
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>函数名称应采用驼峰命名法 (camelCase)，以小写字母开头，例如：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>void&#32;doSomething(int&#32;paramOne);
&#32;
class&#32;MyClass
{
&#32;&#32;void&#32;doSomethingElse(int&#32;paramTwo);
}
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>Typedef 只是类型的简单别名，应该是以大写字母开头的 CamelCase，例如：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>typedef&#32;jevois::Dims&lt;float&gt;&#32;FloatingDims;
</computeroutput></literallayout></para>

<para><itemizedlist>
<listitem>
<para>任何花哨的元编程的结果（例如，编译时检查设置的静态 const 变量或 typedef）都应全部用小写字母书写，并用下划线分隔单词，例如：</para>
</listitem></itemizedlist>
</para>

<para><literallayout><computeroutput>template&#32;&lt;class&#32;T1,&#32;class&#32;T2&gt;&#32;
struct&#32;simple_promotion
{
&#32;&#32;//&#32;Even&#32;though&#32;this&#32;is&#32;a&#32;typedef,&#32;we&#32;use&#32;lowercase&#32;and&#32;an&#32;underscore&#32;to&#32;emphasize
&#32;&#32;//&#32;that&#32;it&#32;is&#32;part&#32;of&#32;some&#32;fancy&#32;metaprogramming
&#32;&#32;typedef&#32;decltype(*(T1*)nullptr&#32;+&#32;*(T2*)nullptr))&#32;promoted_type;
};
</computeroutput></literallayout> </para>
</section>
    <section xml:id="_DocumentationRules"><title>文档规则和指南</title>    </section>
<para><warning><title>Warning</title>

<para>此页面包含大量损坏内容，需要进行重大修复</para>
</warning>
</para>
<section xml:id="_DocumentationRules_1tags">
<title>标记你的代码</title>

<para>在您的评论中使用以下内容代替纯字符串：</para>

<para><itemizedlist>
<listitem>
<para>\todo 将在待办事项列表中添加一项</para>
</listitem><listitem>
<para>\test 将在测试列表中添加一项</para>
</listitem><listitem>
<para>\bug 将在错误列表中添加一项</para>
</listitem><listitem>
<para>\deprecated 将在弃用列表中添加一项</para>
</listitem></itemizedlist>
</para>

<para>例如：</para>

<para><literallayout><computeroutput>//!&#32;Cool&#32;class
/*!&#32;做一些很酷的事情的类。
&#32;&#32;&#32;&#32;\todo&#32;Make&#32;it&#32;hot&#32;too&#32;*/
class&#32;CoolClass&#32;{&#32;...&#32;};
</computeroutput></literallayout></para>
</section>
<section xml:id="_DocumentationRules_1grel">
<title>Modules，相关函数组</title>

<para>一般来说，我们的目标是用户应该能够访问信息：</para>

<para><itemizedlist>
<listitem>
<para>通过浏览文档的 Modules 部分</para>
</listitem><listitem>
<para>通过搜索名称，或浏览各种类列表、文件列表等</para>
</listitem><listitem>
<para>通过相关文档页面之间的链接</para>
</listitem></itemizedlist>
</para>

<para>看看 GenericImage 是如何实现的。</para>

<para><itemizedlist>
<listitem>
<para>首先，在 GenericImage.H 中，我们从一个顶级组开始，它将很好地显示在文档的 <computeroutput>Modules</computeroutput> 部分下： <literallayout><computeroutput>/*!&#32;\defgroup&#32;genericimage&#32;GenericImage&#32;类和概念

&#32;&#32;&#32;&#32;GenericImage&#32;是任何像素类型图像的薄包装器。编写适用于&#32;GenericImage&#32;的通用算法可将其应用于任何图像类型。&#32;*/
</computeroutput></literallayout></para>
</listitem><listitem>
<para>然后，我们记录 GenericImage 本身，使其属于 genericimage 组： <literallayout><computeroutput>/*!&#32;GenericImage&#32;class
&#32;&#32;&#32;&#32;...
&#32;&#32;&#32;&#32;\ingroup&#32;genericimage&#32;*/
class&#32;GenericImage&#32;{&#32;...&#32;};
</computeroutput></literallayout></para>
</listitem><listitem>
<para>最后，如果您想交叉链接到其他组，请使用 \see 命令；例如： <literallayout><computeroutput>/*!&#32;\defgroup&#32;genericimageoperators&#32;GenericImage&#32;Operators
&#32;&#32;&#32;&#32;...
&#32;&#32;&#32;&#32;\ingroup&#32;genericimage
&#32;&#32;&#32;&#32;\see&#32;image&#32;*/

/*!&#32;@{&#32;*/&#32;//&#32;**********************************************************************
...
/*!&#32;@}&#32;*/&#32;//&#32;**********************************************************************
</computeroutput></literallayout></para>
</listitem></itemizedlist>
</para>

<para>请注意我们如何使用 arrobas 花括号将所有将要定义的运算符包含到我们的组中。</para>

<para><note><title>Note</title>

<para>为什么要使用这个而不是每个操作符中的一堆 \relates 指令？这将使每个操作符出现在 GenericImage 类的文档页面中，这很好，只是它掩盖了我们关于所有 GenericImage 操作符如何工作、提升像素等的一般注释块。</para>
</note>
</para>
</section>
<section xml:id="_DocumentationRules_1enumhelp">
<title>辅助枚举或其他辅助程序</title>

<para>对于具有帮助程序的类，例如，一些枚举定义了与类相关的函数的参数：只需将您的组定义为仅包含类；然后为每个帮助程序指明它与类相关。这将在类的文档页面中列出帮助程序，而不是使组的页面杂乱无章。例如，请参阅 Image.H 中如何完成：<itemizedlist>
<listitem>
<para>我们定义一个名为 &apos;image&apos; 的组</para>
</listitem><listitem>
<para>在图像的文档中，我们提到它在 image 组中</para>
</listitem><listitem>
<para>但在 ImageInitPolicy 和 ImageFlags 的文档中，我们只是将它们标记为与图像类相关，而不是在组中。因此，它们将出现在图像类的文档中，但不会出现在描述组的页面中。这是所需的行为，因为在组的页面中，我们希望有一个清晰、整洁的高级视图，而在类文档中，我们需要了解详细信息。</para>
</listitem></itemizedlist>
</para>

<para>但是，对于仅在函数中使用且不能与类关联的枚举，我们必须将它们添加到函数所属的组中。请查看 Text.H 中的示例：TextAnchor 已记录并添加到 textdrawing 组中，就像 drawText() 函数一样。</para>
</section>
<section xml:id="_DocumentationRules_1macro">
<title>记录宏</title>

<para><itemizedlist>
<listitem>
<para>所有内部 JeVois 宏（不能由用户直接使用）的名称都应以 <computeroutput>JEVOIS_MACRO_</computeroutput> 开头</para>
</listitem><listitem>
<para>用户可能使用的所有 JeVois 宏的名称都应以 <computeroutput>JEVOIS_</computeroutput> 开头</para>
</listitem><listitem>
<para>仅定义值的简单宏可以像类、变量等一样记录下来</para>
</listitem><listitem>
<para>声明复杂函数的宏（其内部内容对最终用户毫无意义）应按如下方式记录。首先，在 .H 文件中，只编写一个不附加任何内容的文档块，其中包含宏名称的 \def： <literallayout><computeroutput>//!&#32;宏的可选简要说明
/*!&#32;\def&#32;JEVOIS_MY_MACRO(x,&#32;y)
&#32;&#32;&#32;&#32;\hideinitializer

&#32;&#32;&#32;&#32;实现&#32;blah&#32;的便利宏。&#32;*/
</computeroutput></literallayout> 然后，在隐藏在 details/ 子目录中的 Impl.H 文件中定义您的宏，但不要记录宏定义本身。最后，要从其他文档中创建指向您的宏定义的链接，请使用 <literallayout><computeroutput>/*!&#32;blah&#32;blah.&#32;See&#32;for&#32;example&#32;#JEVOIS_MY_MACRO(x,&#32;y)&#32;*/
</computeroutput></literallayout></para>

<para>例如，请参阅 Types/Enum.H 和 Types/details/EnumImpl.H 中的 #JEVOIS_DEFINE_ENUM_CLASS(name, SEQ)</para>
</listitem></itemizedlist>
</para>
</section>
<section xml:id="_DocumentationRules_1enums">
<title>JeVois 枚举</title>

<para>对于使用 JeVois_DEFINE_ENUM_CLASS 定义的枚举，我们基本上手动指示 doxygen 我们正在创建一个新类。将以下内容调整为您自己的枚举：</para>

<para><literallayout><computeroutput>//!&#32;假设的&#32;BoundedSet&#32;插入策略
/*!&#32;\class&#32;BoundedSetInsertPolicy
&#32;&#32;&#32;&#32;尝试将新元素推送到集合中时，如果它与集合中已有的元素匹配：

&#32;&#32;&#32;&#32;-&#32;if&#32;\c&#32;jevois::BoundedSetInsertPolicy::Preserve,&#32;则保留旧策略并丢弃新传入的策略，或者，
&#32;&#32;&#32;&#32;-&#32;if&#32;\c&#32;jevois::BoundedSetInsertPolicy::Replace,&#32;则用新策略替换旧策略。

&#32;&#32;&#32;&#32;\relates&#32;BoundedSet&#32;*/
JEVOIS_DEFINE_ENUM_CLASS(BoundedSetInsertPolicy,&#32;(Preserve)&#32;(Replace)&#32;);
</computeroutput></literallayout> </para>
</section>
</section>
