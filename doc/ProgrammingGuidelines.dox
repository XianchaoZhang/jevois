/*! \page ProgrammingGuidelines JeVois 核心框架贡献者的通用编程指南


\note 这些编程指南适用于希望为核心 JeVois 框架 (libjevois.so) 做出贡献的程序员，并且非常严格。对于只想编写使用 JeVois 核心框架的新机器视觉模块的程序员，指导方针要宽松得多，并在 jevoisbase 的文档中进行了描述。

\section general 一般规则和缩进

- JeVois 使用 doxygen 进行文档编制，使用感叹号 (!) 注释样式。在开始编写代码之前，您应该了解 doxygen 并查看 JeVois 其余部分的文档编制方式。未记录或记录不当的代码可能会被删除。另请参阅<A href="DocumentationRules.html">此处</A>，了解有关棘手文档案例的更多解释（一旦您了解 doxygen 的基础知识）。

- JeVois 将所有警告视为错误。因此，如果有警告，您的代码将无法编译。这是一个功能：如果您的代码有警告，则说明您做错了！如果您包含的文件来自不是您编写的库，并且有警告，则可以使用以下命令：
  \code
  JEVOIS_BEGIN_UNCHECKED_INCLUDES
  #include <trashystuff.h>
  JEVOIS_END_UNCHECKED_INCLUDES
  \endcode

- 源代码行长度为 120。将其添加到您的 <b>~/.emacs</b> 进行设置：

  \verbatim
  ;; set default line wrap len:
  (setq default-fill-column 120)
  \endverbatim

- JeVois 使用 astyle 来确保我们各种文本编辑器的缩进样式统一。JeVois 中包含一个样式文件，可以在 jevois/scripts/astylerc 中找到。要使用此样式文件，请使用 –options 标志调用 astyle，例如
  \code 
  astyle myfile --options=/path/to/jevois/scripts/astylerc
  \endcode

- 符合此样式的缩进由以下 emacs 规则定义，位于 emacs 缩进的默认 C 模式之上（将其添加到 \c ~/.emacs 以激活）：
  \verbatim
  ;; JeVois indentation style for C++ and such
  (defun my-c-mode-common-hook ()
    (local-set-key "\C-h" 'backward-delete-char)
    ;; this will make sure spaces are used instead of tabs
    (setq tab-width 4 indent-tabs-mode nil)
    (setq indent-tabs-mode 'nil)
    (setq c-basic-offset 2)
    (c-set-offset 'substatement-open 0)
    (c-set-offset 'statement-case-open 0)
    (c-set-offset 'case-label 0)
    (c-set-offset 'brace-list-open 0)
    (c-set-offset 'access-label -2)
    (c-set-offset 'inclass 4)
    (c-set-offset 'member-init-intro 4)
    ;; include possible ! as comment start string so that indentation starts after it
    (setq comment-start-skip "/\\*+!* *\\|//+ *")
     
    ;; type C-c C-s or C-c C-o while editing to see what other rules to add here...
  )
  
  (add-hook 'c-mode-hook 'my-c-mode-common-hook)
  (add-hook 'c++-mode-hook 'my-c-mode-common-hook)
  (add-hook 'perl-mode-hook 'my-c-mode-common-hook)
  (add-hook 'cperl-mode-hook 'my-c-mode-common-hook)
  (add-hook 'emacs-lisp-mode-hook 'my-c-mode-common-hook)
  (add-hook 'nroff-mode-hook 'my-c-mode-common-hook)
  (add-hook 'tcl-mode-hook 'my-c-mode-common-hook)
  (add-hook 'makefile-mode-hook 'my-c-mode-common-hook)
  \endverbatim

- 如果您使用 vi，请使用以下配置：
  \verbatim
  
  "-------------Essential JeVois Style Compliance Settings-------------
   
  " Disable old-school vi compatability
  set nocompatible
  
  " Allow plugins to control our indentation
  filetype plugin indent on
  
  " Set each auto-indent level to equal two spaces
  set shiftwidth=2
  
  " Let each tab equal two spaces
  set tabstop=2
  
  " Make sure vim turns all tabs into spaces
  set expandtab
  
  " Make vim indent our code properly
  set smartindent
  
  " Make the maximum line length equal 120
  set textwidth=120
  
  "-------------Other cool vim tricks-------------
  
  " Use a cool menu when autocompleting filenames, commands, etc...
  set wildmenu
  set wildmode=list:longest
  
  " Make vim automatically change directories to the directory of any file you open. 
  " This means that when you open a file, then want to open another using :tabe, :o, etc,
  " you can just type in the relative path from the file you're currently editing.
  set autochdir
  
  " When editing the JeVois library, it is a total pain when you are editing a .H file in jevois/include/whatever/whatever, 
  " and then decide you need to edit the source .C file in the jevois/src/whatever/whatever. This little function will 
  " automatically back track in the directory tree for you, find the corresponding .C or .H file, and open it in a new
  " tab. 
  " To use it, just type ,o (that's a comma, and then a lower-case o). 
  function! OpenOther()
    if expand("%:e") == "C"
      exe "tabe" fnameescape(expand("%:p:r:s?src?include?").".H")
    elseif expand("%:e") == "H"
      exe "tabe" fnameescape(expand("%:p:r:s?include?src?").".C")
    endif
  endfunction
  nmap ,o :call OpenOther()<CR>
  \endverbatim

\section fileorg 文件组织

- JeVois 对 C++ 文件仅使用文件扩展名 .H 和 .C。

- JeVois 使用 CamelCase 约定作为文件名和类名。模板元编程使用的辅助类是个例外，它们通常使用小写加下划线的名称，以类似于 STL（请参阅下文了解更多详细信息）。

- JeVois 库主要分为 jevois/include/jevois/ 和 jevois/src/jevois/ 目录。然后这些目录进一步分为 Core、Debug、Image 等。构建系统从这些文件创建共享库 libjevois.so。视觉模块程序员通过在 jevois/include 下包含适当的头文件 (.H) 并链接到 libjevois.so（详情如下）来使用 JeVois 库。在添加到核心 JeVois 框架时（而不是仅仅编写新的视觉模块），请记住：

  + jevois/ 下的每个目录都应包含可以逻辑分组在一起的文件 - 例如，Debug 目录用于调试函数和类，Image 用于图像处理等。每个目录都包含一组实现特定功能的类。

  + 所有头文件必须以 .H 扩展名命名，并应放入包含目录中。应拆分头文件，以便用户不需要知道的所有后端功能都隐藏在 \c details 子目录中。通常，此类后端功能可以拆分为 Helpers 文件（包含任何帮助程序类，可包含在类定义主体之前）和 Impl 实现文件（包含任何内联代码）。例如，Parameter 框架涉及 jevois/include/jevois/Component/Parameter.H 中的主要定义和编程接口，它依赖于 jevois/include/jevois/Component/details/ParameterHelpers.H 中定义的一些帮助程序类（使用 Parameter 的程序员不需要知道），并且具有 jevois/include/jevois/Component/details/ParameterImpl.H 中定义的一些内联实现代码（使用 Parameter 的程序员也不需要知道）。这种组织方式使得生成省略所有令人讨厌的实施细节的用户文档变得容易。

  + 所有非内联、非模板实现源文件都应以 .C 扩展名命名，并应按照与其 .H 文件相同的相对路径进入 jevois/src/ 目录。

  + 应将尽可能多的代码移入 .C 文件，这样用户就不必一遍又一遍地重新编译我们的 .H 文件。模板代码是例外，在大多数情况下必须将其移入 .H 文件。

  + 所有头文件和源文件都应包含样板序言/许可证。只需从另一个文件复制即可。

- 类成员变量的名称以 "its" 开头，以便向阅读代码的人表明它们是成员变量。

- JeVois 成员函数使用以小写字母开头的 camelCase。

- JeVois free 函数通常使用 name_with_underscores，或者以小写字母开头的 camelCase。

- 一般而言，每个类一个文件。文件名和类名必须完全匹配。如果几个类在概念上属于同一类，那么可以将它们放在同一个文件中。

- 所有 .H 文件都使用包含保护，这将防止文件被多次包含，从而产生一些关于重新定义内容的错误。没有 .C 文件使用包含保护。我们使用 g++ 支持的编译指示来包含保护：

  \code
#pragma once

// ....

  \endcode


- 因此，一个新类通常涉及以下一组文件：

  + \c include/jevois/XXX/MyClass.H ：仅包含声明和文档。绝对没有实际的实现代码。仅在此文件中声明将使用您的类且不需要关心其内部工作原理的程序员感兴趣的内容。此文件中的所有内容都应使用 doxygen 标记进行记录。

  + \c include/jevois/XXX/details/MyClassHelpers.H ：包含 MyClass.H 中的主要声明生效之前必须知道的支持声明。例如，如果最终用户只使用派生类，而基类不包含他们应该关心的信息，则在 details/MyClassHelpers.H 中声明基类，并在 MyClass.H 的顶部包含 details/MyClassHelpers.H。此文件中没有 doxygen 标记，文档是可选的，主要面向高级程序员。

  + \c include/jevois/XXX/details/MyClassImpl.H ：仅包含内联和模板实现。此文件中没有 doxygen 标记，文档是可选的，主要面向高级程序员。

  + \c src/jevois/XXX/MyClass.C ：包含所有非模板、非内联实现。文档是可选的。

  例如参见以下文件：

  + jevois/include/jevois/Component/details/ParameterHelpers.H 准备工作对只使用 JeVois 框架的程序员来说毫无意义

  + jevois/include/jevois/Component/Parameter.H 为使用 JeVois 框架的程序员提供文档接口

  + jevois/include/jevois/Component/details/ParameterImpl.H 内联函数和模板实现对仅使用 JeVois 框架的程序员来说毫无意义

  + jevois/src/jevois/Component/Parameter.C 不存在，因为 Parameter 是一个完全模板化、完全内联的类，但可能包含任何非模板、非内联的实现，而这些实现对于仅使用 JeVois 框架的程序员来说毫无意义

- 要在 JeVois 源代码中查找特定单词，我们建议将以下宏添加到您的 `~/.bash_aliases` 或 `~/.bashrc`：
\verbatim
# do a grep on c sources (e.g., for kernel, u-boot, etc) or c++ sources (for JeVois, NRT, etc)
xg () {
   grep $* `find . -name "*.[hcHC]"`
}
\endverbatim

您可以按如下方式使用它，例如，查找引用 JeVois 提供的函数 \c warnAndRethrowException() 的所有文件，该函数可帮助程序员处理异常：\verbatim itti@iLab1:~/jevois/software/jevois$ xg warnAndRethrowException ./include/jevois/Debug/Log.H: try { do_something_risky(); } catch (...) { jevois::warnAndRethrowException(); } ./include/jevois/Debug/Log.H: void warnAndRethrowException[[noreturn]](); ./src/jevois/Debug/Log.C:void jevois::warnAndRethrowException() \endverbatim 显示它是在 Log.H 中声明并在 Log.C 中实现的，因此您现在可以打开这些文件以获取更多信息。

\section constcorr Const 正确性

JeVois 专门使用从右到左的约定来限定 const 限定符。这是因为这是清楚地阅读包含 const 的语句的最佳方式，只需从右到左大声朗读即可。例如：

\code 
int const * prt1; // ptr1 是指向 const int 的指针（从右向左读取；可以改变指针地址，但不能改变指向的 int 值） 
int * const ptr2; // ptr2 是指向 int 的 const 指针（不能改变地址，但可以改变 int 值） 
int const * const ptr3; // ptr3 是指向 const int 的 const 指针（const 地址，const 值） 
\endcode

  有关更多详细信息和示例，请参阅 http://en.wikipedia.org/wiki/Const-correctness。另请参阅此文：http://www.dansaks.com/articles/1999-02%20const%20T%20vs%20T%20const.pdf 和此文：http://www.parashift.com/c++-faq-lite/const-correctness.html

- JeVois 是 const 正确的代码（除了错误和遗漏！）。编写 jevois 代码时，请确保它是 const 正确的。例如：
  - 函数的输入参数通常由 const 引用接收。例如：
\code
void myfunc(std::string const & arg);
\endcode
  - 不修改对象任何成员变量的成员函数应声明为 const。例如：
\code 
class MyClass 
{
 public:
  int getX() const 
  { return x; } // 由于我们不修改 x 或 MyClass 中的任何其他内容，因此 getX() 被声明为 const 
 private:
  int x; } 
\endcode
  - 不会被修改的临时变量应声明为 const。例如：
\code 
double const perimeter = 2.0 * M_PI * radius; // 假设周长以后不会被修改 
\endcode
  - 类中的互斥锁通常应声明为 \c mutable ，这将允许它在类的 const 实例或类的 const 成员函数中被锁定/解锁。
  - 对于函数的返回值：如果可能，返回一个 const ref（即，您正在返回一个不会很快消失的 const ref，通常在返回类的数据成员之一时将其用于类的访问器函数），否则按值返回（非常量）。虽然按非常量值返回可能会带来危险，但它也允许移动语义。如果您返回向量、字符串等，这一点尤其重要，因为通过按非常量值返回它，它实际上将被移动（在大多数情况下），而不是复制。

  - 在极少数情况下，如果从逻辑上讲这更有意义，则更希望将成员函数保持为 const，即使它可能会修改类的一些成员非可变变量。您必须对这些情况做出判断，并在函数内部使用 \c const_cast 。例如，考虑 Component 中 className() 访问器函数的实现，该函数返回组件类的名称。itsClassName 在 Component.H 中声明为 Component 的 const 字符串数据成员，这是有道理的，因为任何 Component 的类名都不能修改。对于所有 const 数据成员，为 itsClassName 赋值的唯一方法是在构造期间。但我们希望报告从 Component 派生的任何类的类名，而该类名在基 Component 类的构造期间是无法访问的。出于这个原因，我们将在第一次请求时设置类名（此时我们知道从 Component 派生的对象将被完全构造）：
\code 
std::string const & jevois::Component::className() const 
{
  boost::shared_lock<boost::shared_mutex> lck(itsMetaMtx);

  // 我们需要完全构造（派生！）组件以使 demangle 正常工作，因此这里有 const_cast：
  if (itsClassName.empty()) *(const_cast<std::string *>(&itsClassName)) = jevois::demangle(typeid(*this).name());

  return itsClassName; } 
\endcode 
    因此我们使用 \c const_cast 在第一次请求时设置 const 成员变量 itsClassName。
  - 有关更多详细信息和示例，请参阅http://en.wikipedia.org/wiki/Const-correctness。

\section localvar 局部变量

- 局部变量名应该选择较长、更具描述性的名称，而不是较短的名称。例如

\code
// Bad...
for (int i = 0; i < c; ++i);
 
// Better...
for (int itemIdx = 0; itemIdx < itemCount; ++itemIdx);
\endcode

\section useinline 正确使用 inline、virtual、override、final 等

- 在声明中，不要写 inline（例如，在类声明中）。Inline 是一个实现细节，只看你的接口（声明）的人不应该被它打扰。

- 在定义（函数的实现）中，这是添加 inline 的正确位置。对于模板函数，将 inline 添加到与模板相同的行。

例子：

\code
  template <class T>
  class Stuff
  {
    public:
      void doit();   // NO INLINE HERE IN DECLARATION
  };

  ...
  
  // IN IMPLEMENTATION FILE:
  template <class T> inline
  Stuff<T>::doit()
  { ... }
\endcode


- virtual、override、final 的规则与 inline 相反：在声明中指定它（类的用户需要知道什么是虚拟的，并且可以安全地由派生类重新实现），从定义中省略它（一旦函数被声明为虚拟的，它就会保持这种状态）。

\section capi 大小写规则

- 类名应该以大写字母开头，采用 CamelCase 命名法，例如：

  \code
  class MyCoolClass;
  class ImageSegmenter;
  \endcode

- 变量应采用驼峰式命名法，以小写字母开头，例如
  \code
  bool isRunning;
  size_t arraySize;
  \endcode

- 成员变量应采用驼峰命名法 (camelCase)，以前缀 "its" 开头，例如：

  \code
  class MyClass
  {
    size_t itsCounter;
    std::vector<int> itsStorage;
  }
  \endcode

- 函数名称应采用驼峰命名法 (camelCase)，以小写字母开头，例如：

  \code
  void doSomething(int paramOne);
   
  class MyClass
  {
    void doSomethingElse(int paramTwo);
  }
  \endcode

- Typedef 只是类型的简单别名，应该是以大写字母开头的 CamelCase，例如：

  \code
  typedef jevois::Dims<float> FloatingDims;
  \endcode

- 任何花哨的元编程的结果（例如，编译时检查设置的静态 const 变量或 typedef）都应全部用小写字母书写，并用下划线分隔单词，例如：

  \code
  template <class T1, class T2> 
  struct simple_promotion
  {
    // Even though this is a typedef, we use lowercase and an underscore to emphasize
    // that it is part of some fancy metaprogramming
    typedef decltype(*(T1*)nullptr + *(T2*)nullptr)) promoted_type;
  };
  \endcode

*/

