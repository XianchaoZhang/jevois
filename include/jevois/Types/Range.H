// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// JeVois Smart Embedded Machine Vision Toolkit - Copyright (C) 2016 by Laurent Itti, the University of Southern
// California (USC), and iLab at USC. See http://iLab.usc.edu and http://jevois.org for information about this project.
//
// This file is part of the JeVois Smart Embedded Machine Vision Toolkit.  This program is free software; you can
// redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
// Foundation, version 2.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
// License for more details.  You should have received a copy of the GNU General Public License along with this program;
// if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// Contact information: Laurent Itti - 3641 Watt Way, HNB-07A - Los Angeles, CA 90089-2520 - USA.
// Tel: +1 213 740 3527 - itti@pollux.usc.edu - http://iLab.usc.edu - http://jevois.org
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \file */

// This file has been modified / imported from the Neuromorphic Robotics Toolkit (NRT). Original copyright is:

/* author Laurent Itti
    // ////////////////////////////////////////////////////////////////////////
    //              The iLab Neuromorphic Robotics Toolkit (NRT)             //
    // Copyright 2010-2012 by the University of Southern California (USC)    //
    //                          and the iLab at USC.                         //
    //                                                                       //
    //                iLab - University of Southern California               //
    //                Hedco Neurociences Building, Room HNB-10               //
    //                    Los Angeles, Ca 90089-2520 - USA                   //
    //                                                                       //
    //      See http://ilab.usc.edu for information about this project.      //
    // ////////////////////////////////////////////////////////////////////////
    // This file is part of The iLab Neuromorphic Robotics Toolkit.          //
    //                                                                       //
    // The iLab Neuromorphic Robotics Toolkit is free software: you can      //
    // redistribute it and/or modify it under the terms of the GNU General   //
    // Public License as published by the Free Software Foundation, either   //
    // version 3 of the License, or (at your option) any later version.      //
    //                                                                       //
    // The iLab Neuromorphic Robotics Toolkit is distributed in the hope     //
    // that it will be useful, but WITHOUT ANY WARRANTY; without even the    //
    // implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR       //
    // PURPOSE.  See the GNU General Public License for more details.        //
    //                                                                       //
    // You should have received a copy of the GNU General Public License     //
    // along with The iLab Neuromorphic Robotics Toolkit.  If not, see       //
    // <http://www.gnu.org/licenses/>.                                       //
    // ////////////////////////////////////////////////////////////////////////
*/

#pragma once

#include <istream>
#include <ostream>

namespace jevois
{
  //! 通用 Range 类 
  /*! Range 类用于表示从 [min .. max] 的范围

      请注意，Range 的运算符不使用类型提升。这是为了最大限度地减少模板负担，也是为了减少程序员的困惑。例如，虽然原则上可以定义
       Range<int> + float 并返回 Range<float>，但这里我们没有定义这样的运算符。通过首先转换范围然后添加常量可以实现相同的结
       果：

      @code
      jevois::Range<int> r1(0, 100);
      // NOT ALLOWED: jevois::Range<float> r2 = r1 + 1.23F;
      jevois::Range<float> r2 = jevois::Range<float>(r1) + 1.23F; // OK, 没有隐藏转换，易于阅读，明确
      @endcode

      Range 上的运算符在内部使用范围检查和限制。因此，使用 Range<byte> 时要小心。例如：
      @code
      jevois::Range<jevois::byte> r(jevois::byte(0), jevois::byte(250));
      r += jevois::byte(100); // new range is 100-255
      @endcode

      \ingroup types */
  template <typename T>
  class Range
  {
    public:
      //! Default constructor, range is [0 .. 0]
      explicit Range();

      //! Constructor
      explicit Range(T const mini, T const maxi);

      //! Copy constructor
      Range(Range<T> const & other) = default;

      //! Move constructor
      Range(Range<T> && other) = default;

      //! 复制转换构造函数，内部使用 jevois::clamped_convert<T,U> 
      /*！请注意，此构造函数是 \e explicit 的，即您需要显式提及它。这是为了避免在程序员不知情的情况下发生转换。例如：
          @code
          void myFunc(jevois::Range<float> const & rng) { ... }
          jevois::Range<int> r1(0, 100);
          jevois::Range<float> r2(r1); // ok, 显式构造函数调用
          myFunc(r2);  // ok, no conversion necessary
          //myFunc(r1) // NO: 将 Range<int> 传递给接受 Range<float> 参数的函数会导致编译失败
          myFunc(jevois::Range<float>(r1)); // ok, nice and explicit; 并且您可以首先考虑 r1 是否应该是一个 Range<float>，
                                         // 这样您就不会浪费 CPU 进行这种转换（而不是只是没有意识到浪费）
          @endcode */
      template <typename U>
      explicit Range(Range<U> const & other);

      //! Assignment
      Range<T> & operator=(Range<T> const & other) = default;

      //! Move assignment
      Range<T> & operator=(Range<T> && other) = default;

      //! Return the minimum value
      T const & min() const;

      //! Return the maximum value
      T const & max() const;

      //! Return whether min() == max()
      bool empty() const;

      //! Extend the range, if needed, so that it includes val
      void extend(T const val);

      //! Return true if val is within [min ... max]
      bool contains(T const & val) const;
      
    private:
      T itsMin;
      T itsMax;
  };

  // ######################################################################
  // Free functions for Range<T>
  // ######################################################################

  //! Merge two ranges
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> merge(Range<T> const & r1, Range<T> const & r2);

  //! Stream out as "[min ... max]"
  /*! \relates jevois::Range */
  template <typename T>
  std::ostream & operator<<(std::ostream & out, Range<T> const & r);

  //! Stream in as "[min ... max]"
  /*! \relates jevois::Range */
  template <typename T>
  std::istream & operator>>(std::istream & in, Range<T> & r);

  //! 机器可读的输出为字符串，用于 jevois::Parameter：outputs \c min...max (e.g., 0...100)
  /*! \relates jevois::Range */
  template <class T>
  void paramValToString(Range<T> const & val, std::string & result);

  //! 来自字符串的机器可读输入， 用于 jevois::Parameter: reads \c min...max (e.g., 0...100)
  /*! \relates jevois::Range */
  template <class T>
  void paramStringToVal(std::string const & valstring, Range<T> & result);

  //! 相等性测试： Range<T> == Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  bool operator==(Range<T> const & range1, Range<T> const & range2);

  //! 不等式测试： Range<T> != Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  bool operator!=(Range<T> const & range1, Range<T> const & range2);

  //! 在范围的两端添加常数： Range<T> + T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator+(Range<T> const & range, T const & scalar);

  //! 在范围的两端添加常数： T + Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator+(T const & scalar, Range<T> const & range);

  //! 从范围的两端减去常数：Range<T> - T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator-(Range<T> const & range, T const & scalar);

  //! 从范围的两端减去常数：T - Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator-(T const & scalar, Range<T> const & range);

  //! Divide both ends of a range by a factor: Range<T> / T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator/(Range<T> const & range, T const & scalar);

  //! 将范围的两端除以一个因子： T / Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator/(T const & scalar, Range<T> const & range);

  //! 将范围的两端乘以一个因子： Range<T> * T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator*(Range<T> const & range, T const & scalar);

  //! 将一个因子乘以范围的两端： T * Range<T>
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> operator*(T const & scalar, Range<T> const & range);

  //! 在范围的两端添加常数：Range<T> += T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> & operator+=(Range<T> & range, T const & scalar);

  //! 从范围的两端减去常数：Range<T> -= T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> & operator-=(Range<T> & range, T const & scalar);

  //! 将范围的两端乘以一个因子： Range<T> *= T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> & operator*=(Range<T> & range, T const & scalar);

  //! 将范围的两端除以一个因子：Range<T> /= T
  /*! \relates jevois::Range */
  template <typename T>
  Range<T> & operator/=(Range<T> & range, T const & scalar);

} // namespace jevois

// Include inlined implementation details that are of no interest to the end user
#include <jevois/Types/details/RangeImpl.H>
